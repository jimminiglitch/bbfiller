<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tripscape - 3D Psychedelic Experience</title>
  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
        "Helvetica Neue", sans-serif;
      background-color: #000;
      color: #fff;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Loading screen */
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s ease;
    }

    .loading-container {
      width: 100%;
      max-width: 400px;
      padding: 0 20px;
      text-align: center;
    }

    .loading-title {
      font-size: 3.5rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
      background: linear-gradient(to right, #ff00ff, #00ffff, #ffff00);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: glitch 1s infinite, rainbow 4s infinite linear;
    }

    .loading-text {
      color: #22d3ee;
      font-family: monospace;
      letter-spacing: 0.1em;
      margin-bottom: 2rem;
    }

    .progress-bar {
      position: relative;
      height: 8px;
      background-color: #1f2937;
      border-radius: 9999px;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    .progress-fill {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: linear-gradient(to right, #ff00ff, #00ffff, #ffff00);
      border-radius: 9999px;
      transition: width 0.3s ease;
      animation: rainbow 2s infinite linear;
    }

    .progress-text {
      color: #22d3ee;
      font-family: monospace;
      font-size: 0.875rem;
    }

    .loading-info {
      margin-top: 2rem;
      font-size: 0.75rem;
      color: #6b7280;
    }

    /* Audio visualizer */
    #audio-visualizer {
      position: absolute;
      bottom: 16px;
      left: 16px;
      z-index: 50;
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 0, 255, 0.3);
      border-radius: 8px;
      width: 256px;
      height: 80px;
      display: none;
    }

    /* Track info */
    #track-info {
      position: absolute;
      bottom: 104px;
      left: 16px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00ffff;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 0.875rem;
      z-index: 50;
      display: none;
      max-width: 256px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Audio status */
    #audio-status {
      position: absolute;
      bottom: 80px;
      left: 16px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #ff00ff;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 0.875rem;
      z-index: 50;
      display: none;
    }

    /* Control buttons */
    .control-buttons {
      position: absolute;
      bottom: 16px;
      right: 16px;
      display: flex;
      gap: 12px;
      z-index: 50;
    }

    .control-button {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid #ff00ff;
      color: #ff00ff;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
    }

    .control-button:hover {
      background-color: rgba(0, 0, 0, 0.7);
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
    }

    .control-button.active {
      background-color: rgba(255, 0, 255, 0.3);
      border-color: #00ffff;
      color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
    }

    /* Track selector */
    #track-selector {
      position: absolute;
      bottom: 16px;
      left: 280px;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid #ff00ff;
      border-radius: 8px;
      padding: 8px;
      color: #00ffff;
      z-index: 100;
      display: none;
      max-width: 300px;
      max-height: 300px;
      overflow-y: auto;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    #track-selector h3 {
      margin: 0 0 8px 0;
      color: #ff00ff;
      font-size: 1rem;
      text-align: center;
    }

    .track-option {
      padding: 6px 10px;
      margin-bottom: 4px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .track-option:hover {
      background-color: rgba(255, 0, 255, 0.3);
    }

    .track-option.active {
      background-color: rgba(0, 255, 255, 0.3);
    }

    /* Theme indicator */
    #theme-indicator {
      position: absolute;
      top: 16px;
      left: 16px;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid #ff00ff;
      border-radius: 8px;
      padding: 4px 12px;
      color: #ff00ff;
      font-size: 0.9rem;
      z-index: 100;
      text-align: center;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    /* Error message */
    #error-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      border: 1px solid #ff0000;
      border-radius: 8px;
      padding: 16px;
      color: #ff0000;
      font-size: 1rem;
      z-index: 2000;
      text-align: center;
      max-width: 80%;
      display: none;
    }

    /* Performance indicator */
    #performance-indicator {
      position: absolute;
      top: 16px;
      right: 16px;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      padding: 4px 8px;
      color: #00ffff;
      font-size: 0.75rem;
      z-index: 50;
      display: none;
    }

    /* Settings panel */
    #settings-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      border: 1px solid #ff00ff;
      border-radius: 8px;
      padding: 16px;
      color: #fff;
      font-size: 0.9rem;
      z-index: 1000;
      width: 300px;
      max-width: 90%;
      display: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #settings-panel h3 {
      margin: 0 0 16px 0;
      color: #ff00ff;
      font-size: 1.2rem;
      text-align: center;
    }

    .settings-group {
      margin-bottom: 16px;
    }

    .settings-group h4 {
      margin: 0 0 8px 0;
      color: #00ffff;
      font-size: 1rem;
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      padding-bottom: 4px;
    }

    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .setting-label {
      flex: 1;
    }

    .setting-control {
      flex: 1;
      text-align: right;
    }

    .setting-control input[type="range"] {
      width: 100%;
      background: #1f2937;
      height: 6px;
      border-radius: 3px;
      -webkit-appearance: none;
    }

    .setting-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ff00ff;
      cursor: pointer;
    }

    .setting-control input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .setting-control select {
      background-color: #1f2937;
      color: #fff;
      border: 1px solid #ff00ff;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
    }

    .settings-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 16px;
    }

    .settings-button {
      background-color: rgba(255, 0, 255, 0.3);
      border: 1px solid #ff00ff;
      border-radius: 4px;
      padding: 6px 12px;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .settings-button:hover {
      background-color: rgba(255, 0, 255, 0.5);
    }

    /* Controls info */
    #controls-info {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      border: 1px solid #ff00ff;
      border-radius: 8px;
      padding: 16px;
      color: #fff;
      font-size: 0.9rem;
      z-index: 1000;
      width: 300px;
      max-width: 90%;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #controls-info h4 {
      margin: 0 0 8px 0;
      color: #00ffff;
      font-size: 1rem;
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      padding-bottom: 4px;
    }

    #controls-info ul {
      list-style: none;
      padding: 0;
      margin: 0 0 16px 0;
    }

    #controls-info li {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }

    .key {
      display: inline-block;
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.4);
      border-radius: 4px;
      padding: 2px 6px;
      margin-right: 8px;
      font-family: monospace;
      min-width: 20px;
      text-align: center;
    }

    .controls-note {
      margin-top: 16px;
      text-align: center;
      color: #ff00ff;
      font-style: italic;
    }

    /* Crosshair */
    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.7);
      z-index: 10;
      pointer-events: none;
    }

    /* Animations */
    @keyframes glitch {
      0% {
        text-shadow: 0.05em 0 0 rgba(255, 0, 255, 0.75), -0.05em -0.025em 0 rgba(0, 255, 255, 0.75), -0.025em 0.05em 0
          rgba(255, 255, 0, 0.75);
      }
      14% {
        text-shadow: 0.05em 0 0 rgba(255, 0, 255, 0.75), -0.05em -0.025em 0 rgba(0, 255, 255, 0.75), -0.025em 0.05em 0
          rgba(255, 255, 0, 0.75);
      }
      15% {
        text-shadow: -0.05em -0.025em 0 rgba(255, 0, 255, 0.75), 0.025em 0.025em 0 rgba(0, 255, 255, 0.75), -0.05em -0.05em
          0 rgba(255, 255, 0, 0.75);
      }
      49% {
        text-shadow: -0.05em -0.025em 0 rgba(255, 0, 255, 0.75), 0.025em 0.025em 0 rgba(0, 255, 255, 0.75), -0.05em -0.05em
          0 rgba(255, 255, 0, 0.75);
      }
      50% {
        text-shadow: 0.025em 0.05em 0 rgba(255, 0, 255, 0.75), 0.05em 0 0 rgba(0, 255, 255, 0.75), 0 -0.05em 0
          rgba(255, 255, 0, 0.75);
      }
      99% {
        text-shadow: 0.025em 0.05em 0 rgba(255, 0, 255, 0.75), 0.05em 0 0 rgba(0, 255, 255, 0.75), 0 -0.05em 0
          rgba(255, 255, 0, 0.75);
      }
      100% {
        text-shadow: -0.025em 0 0 rgba(255, 0, 255, 0.75), -0.025em -0.025em 0 rgba(0, 255, 255, 0.75), -0.025em -0.05em 0
          rgba(255, 255, 0, 0.75);
      }
    }

    @keyframes rainbow {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }

    .rainbow-text {
      background: linear-gradient(to right, #ff00ff, #00ffff, #ffff00, #ff00ff);
      background-size: 200% auto;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: rainbow 4s linear infinite;
    }

    /* Pulse animation for audio status */
    @keyframes pulse {
      0% {
        opacity: 0.7;
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0.7;
      }
    }

    .pulse {
      animation: pulse 1.5s infinite ease-in-out;
    }

    /* Fade in/out animation */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
      }
    }

    .fade-in {
      animation: fadeIn 0.5s forwards;
    }

    .fade-out {
      animation: fadeOut 0.5s forwards;
    }
  </style>
</head>
<body>
  <!-- Main Canvas (Three.js will use this) -->
  <canvas id="scene-canvas"></canvas>

  <!-- Audio Visualizer -->
  <canvas id="audio-visualizer" width="256" height="80"></canvas>

  <!-- Track Info -->
  <div id="track-info">
    Now Playing: Initializing...
  </div>

  <!-- Audio Status -->
  <div id="audio-status" class="pulse">
    Loading audio...
  </div>

  <!-- Error Message -->
  <div id="error-message"></div>

  <!-- Performance Indicator -->
  <div id="performance-indicator">FPS: 60</div>

  <!-- Loading Screen -->
  <div id="loading-screen">
    <div class="loading-container">
      <h1 class="loading-title">TRIPSCAPE</h1>
      <p id="loading-text" class="loading-text">INITIALIZING NEURAL INTERFACE</p>
      
      <div class="progress-bar">
        <div id="progress-fill" class="progress-fill" style="width: 0%; background-size: 200% auto;"></div>
      </div>
      
      <div class="progress-text">
        <span id="progress-percent">0%</span>
      </div>
      
      <div class="loading-info">
        <p>CALIBRATING PSYCHEDELIC PARAMETERS</p>
        <p>LOADING DIMENSIONAL GATEWAYS</p>
      </div>
    </div>
  </div>

  <!-- Theme Indicator -->
  <div id="theme-indicator">
    RAVE MADNESS
  </div>

  <!-- Track Selector -->
  <div id="track-selector">
    <h3>SELECT TRACK</h3>
    <!-- Track options will be added dynamically -->
  </div>

  <!-- Settings Panel -->
  <div id="settings-panel">
    <h3>SETTINGS</h3>
    
    <div class="settings-group">
      <h4>Performance</h4>
      <div class="setting-item">
        <div class="setting-label">Quality</div>
        <div class="setting-control">
          <select id="quality-setting">
            <option value="low">Low</option>
            <option value="medium" selected>Medium</option>
            <option value="high">High</option>
            <option value="ultra">Ultra</option>
          </select>
        </div>
      </div>
      <div class="setting-item">
        <div class="setting-label">Particle Density</div>
        <div class="setting-control">
          <input type="range" id="density-setting" min="10" max="100" value="40">
        </div>
      </div>
      <div class="setting-item">
        <div class="setting-label">Show FPS</div>
        <div class="setting-control">
          <input type="checkbox" id="fps-setting">
        </div>
      </div>
    </div>
    
    <div class="settings-group">
      <h4>Visual Effects</h4>
      <div class="setting-item">
        <div class="setting-label">Bloom Intensity</div>
        <div class="setting-control">
          <input type="range" id="bloom-setting" min="0" max="2" step="0.1" value="1">
        </div>
      </div>
      <div class="setting-item">
        <div class="setting-label">Glitch Effect</div>
        <div class="setting-control">
          <input type="range" id="glitch-setting" min="0" max="1" step="0.05" value="0.15">
        </div>
      </div>
      <div class="setting-item">
        <div class="setting-label">Color Shift Speed</div>
        <div class="setting-control">
          <input type="range" id="color-shift-setting" min="0" max="2" step="0.1" value="1">
        </div>
      </div>
    </div>
    
    <div class="settings-group">
      <h4>Audio</h4>
      <div class="setting-item">
        <div class="setting-label">Volume</div>
        <div class="setting-control">
          <input type="range" id="volume-setting" min="0" max="1" step="0.05" value="0.7">
        </div>
      </div>
      <div class="setting-item">
        <div class="setting-label">Bass Impact</div>
        <div class="setting-control">
          <input type="range" id="bass-setting" min="0" max="3" step="0.1" value="1.5">
        </div>
      </div>
      <div class="setting-item">
        <div class="setting-label">Randomize Tracks</div>
        <div class="setting-control">
          <input type="checkbox" id="random-tracks-setting" checked>
        </div>
      </div>
    </div>
    
    <div class="settings-group">
      <h4>Movement</h4>
      <div class="setting-item">
        <div class="setting-label">Movement Speed</div>
        <div class="setting-control">
          <input type="range" id="movement-speed-setting" min="0.5" max="5" step="0.5" value="2">
        </div>
      </div>
      <div class="setting-item">
        <div class="setting-label">Flying Enabled</div>
        <div class="setting-control">
          <input type="checkbox" id="flying-setting" checked>
        </div>
      </div>
      <div class="setting-item">
        <div class="setting-label">Mouse Sensitivity</div>
        <div class="setting-control">
          <input type="range" id="sensitivity-setting" min="0.1" max="2" step="0.1" value="1">
        </div>
      </div>
    </div>
    
    <div class="settings-buttons">
      <button class="settings-button" id="settings-apply">Apply</button>
      <button class="settings-button" id="settings-close">Close</button>
    </div>
  </div>

  <!-- Control Buttons -->
  <div class="control-buttons">
    <button id="fullscreen-button" class="control-button" title="Toggle Fullscreen">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="15 3 21 3 21 9"></polyline>
        <polyline points="9 21 3 21 3 15"></polyline>
        <line x1="21" y1="3" x2="14" y2="10"></line>
        <line x1="3" y1="21" x2="10" y2="14"></line>
      </svg>
    </button>
    
    <button id="settings-button" class="control-button" title="Settings">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    </button>
    
    <button id="theme-button" class="control-button" title="Change Theme">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
      </svg>
    </button>
    
    <button id="track-button" class="control-button" title="Change Track">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="5.5" cy="17.5" r="2.5"></circle>
        <circle cx="17.5" cy="15.5" r="2.5"></circle>
        <path d="M8 17V5l12-2v12"></path>
      </svg>
    </button>
    
    <button id="audio-button" class="control-button" title="Toggle Audio">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
    </button>
    
    <button id="help-button" class="control-button" title="Show Controls">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
    </button>
  </div>

  <!-- Controls Info -->
  <div id="controls-info">
    <h4>Movement Controls</h4>
    <ul>
      <li><span class="key">W</span> Move forward</li>
      <li><span class="key">S</span> Move backward</li>
      <li><span class="key">A</span> Move left</li>
      <li><span class="key">D</span> Move right</li>
      <li><span class="key">Space</span> Fly up</li>
      <li><span class="key">Shift</span> Fly down</li>
      <li><span class="key">Mouse</span> Look around</li>
      <li><span class="key">Esc</span> Release mouse</li>
    </ul>
    <h4>Other Controls</h4>
    <ul>
      <li><span class="key">F</span> Fullscreen</li>
      <li><span class="key">M</span> Toggle music</li>
      <li><span class="key">T</span> Change theme</li>
      <li><span class="key">N</span> Next track</li>
      <li><span class="key">P</span> Settings</li>
      <li><span class="key">H</span> Toggle this help</li>
    </ul>
    <p class="controls-note">Click anywhere to lock mouse and start exploring!</p>
  </div>

  <!-- Load Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/RGBShiftShader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/DigitalGlitch.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/GlitchPass.min.js"></script>
  
  <!-- Main Application Script -->
  <script>
    // Tripscape - 3D Psychedelic Experience
    // A first-person immersive rave experience

    // Main Tripscape object
    const Tripscape = {
      // Configuration and state
      config: {
        density: 60,
        movementSpeed: 2.0,
        flyingEnabled: true,
        visualTheme: "rave",
        audioReactive: true,
        volume: 0.7,
        bassImpact: 1.5,
        audioTrack: "melodic-techno",
        randomizeTracks: true,
        trippyLevel: 1.0,
        glitchIntensity: 0.15,
        colorShiftSpeed: 1.0,
        bloomEnabled: true,
        showDancers: true,
        dancerCount: 100,
        regularPeopleCount: 50,
        showBuildings: true,
        buildingCount: 200,
        showSkyObjects: true,
        skyObjectCount: 100,
        showLasers: true,
        laserCount: 50,
        showSmoke: true,
        smokeCount: 8,
        isMobile: false,
        showFps: false,
        quality: "medium",
        mouseSensitivity: 1.0,
      },

      // Visual themes
      visualThemes: {
        rave: {
          name: "RAVE MADNESS",
          fogColor: 0x000022,
          particleColor1: 0xff00ff,
          particleColor2: 0x00ffff,
          gridColor: 0xffff00,
          buildingColor1: 0xff00ff,
          buildingColor2: 0x00ffff,
          skyColor: 0x000033,
          bloomStrength: 1.2,
          bloomRadius: 0.7,
          bloomThreshold: 0.1,
        },
        hyperspace: {
          name: "HYPERSPACE",
          fogColor: 0x000033,
          particleColor1: 0xff00ff,
          particleColor2: 0x00ffff,
          gridColor: 0xffff00,
          buildingColor1: 0x8800ff,
          buildingColor2: 0x0088ff,
          skyColor: 0x000066,
          bloomStrength: 1.0,
          bloomRadius: 0.6,
          bloomThreshold: 0.2,
        },
        vaporwave: {
          name: "VAPORWAVE",
          fogColor: 0x551a8b,
          particleColor1: 0xff71ce,
          particleColor2: 0x01cdfe,
          gridColor: 0x05ffa1,
          buildingColor1: 0xff71ce,
          buildingColor2: 0x05ffa1,
          skyColor: 0x2d1b4e,
          bloomStrength: 0.8,
          bloomRadius: 0.4,
          bloomThreshold: 0.3,
        },
        cyberpunk: {
          name: "CYBERPUNK",
          fogColor: 0x0a001a,
          particleColor1: 0xff3c6f,
          particleColor2: 0x00f9ff,
          gridColor: 0xffff00,
          buildingColor1: 0xff3c6f,
          buildingColor2: 0x00f9ff,
          skyColor: 0x0a001a,
          bloomStrength: 1.5,
          bloomRadius: 0.5,
          bloomThreshold: 0.1,
        },
        neon: {
          name: "NEON DREAMS",
          fogColor: 0x000000,
          particleColor1: 0xff00ff,
          particleColor2: 0x00ffff,
          gridColor: 0x00ff00,
          buildingColor1: 0xff00ff,
          buildingColor2: 0x00ffff,
          skyColor: 0x000000,
          bloomStrength: 1.8,
          bloomRadius: 0.8,
          bloomThreshold: 0.1,
        },
      },

      // Audio tracks
      audioTracks: {
        "melodic-techno": {
          url: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/melodic-techno-03-extended-version-moogify-9867.mp3?v=1747323781216",
          title: "Melodic Techno",
        },
        "berlin-techno": {
          url: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/berlin-techno-106820.mp3?v=1747327926985",
          title: "Berlin Techno",
        },
        "dopetronic-echoes": {
          url: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/dopetronic-echoes-from-nowhere-original-mix-gift-track-321994.mp3?v=1747327850182",
          title: "Dopetronic - Echoes From Nowhere",
        },
        "unknown-planet": {
          url: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/unknown-planet-driving-techno-music-312478.mp3?v=1747327934012",
          title: "Unknown Planet - Driving Techno",
        },
      },

      // DOM Elements
      elements: {},

      // Movement state
      movement: {
        forward: false,
        backward: false,
        left: false,
        right: false,
        up: false,
        down: false,
        speed: 0.15,
        velocity: new THREE.Vector3(),
        direction: new THREE.Vector3(),
        pointerLocked: false,
      },

      // Animation state
      animationFrameId: null,
      time: 0,
      lastTime: 0,
      fps: 0,
      frameCount: 0,
      lastFpsUpdate: 0,

      // Audio state
      audioContext: null,
      audioSource: null,
      audioAnalyser: null,
      audioData: null,
      frequencyData: null,
      audioElement: null,
      isPlaying: false,
      audioLoaded: false,
      trackQueue: [],

      // Three.js variables
      scene: null,
      camera: null,
      renderer: null,
      composer: null,
      controls: null,
      clock: null,
      raycaster: null,
      particles: null,
      floorMesh: null,
      skyMesh: null,
      bloomPass: null,
      glitchPass: null,
      rgbShiftPass: null,
      characters: [],
      buildings: [],
      skyObjects: [],
      lasers: [],
      smokeMachines: [],
      zones: [],
      lastGenerationPosition: null,
      generationRadius: 500,
      generationDistance: 300,

      // Initialize the application
      init: function () {
        try {
          console.log("Initializing Tripscape...");
          
          // Get DOM elements
          this.getElements();

          // Check if device is mobile
          this.checkMobile();

          // Initialize loading screen
          this.initLoadingScreen();

          // Load dependencies
          this.loadDependencies()
            .then(() => {
              console.log("Dependencies loaded successfully");
              
              // Initialize scene
              this.initScene();

              // Initialize audio
              this.initAudio();

              // Initialize controls
              this.initControls();

              // Start animation loop
              this.animate();
              
              // Hide controls info initially
              setTimeout(() => {
                // Auto-hide controls after 3 seconds if not clicked
                if (!this.movement.pointerLocked) {
                  this.elements.controlsInfo.style.display = "none";
                }
              }, 3000);
            })
            .catch((error) => {
              console.error("Failed to load dependencies:", error);
              this.showError(`Failed to load dependencies: ${error.message}`);
            });
        } catch (error) {
          console.error("Initialization error:", error);
          this.showError(`Initialization error: ${error.message}`);
        }
      },

      // Get DOM elements
      getElements: function () {
        this.elements = {
          loadingScreen: document.getElementById("loading-screen"),
          loadingText: document.getElementById("loading-text"),
          progressFill: document.getElementById("progress-fill"),
          progressPercent: document.getElementById("progress-percent"),
          sceneCanvas: document.getElementById("scene-canvas"),
          audioVisualizer: document.getElementById("audio-visualizer"),
          trackInfo: document.getElementById("track-info"),
          audioStatus: document.getElementById("audio-status"),
          errorMessage: document.getElementById("error-message"),
          controlsInfo: document.getElementById("controls-info"),
          themeIndicator: document.getElementById("theme-indicator"),
          themeButton: document.getElementById("theme-button"),
          trackButton: document.getElementById("track-button"),
          trackSelector: document.getElementById("track-selector"),
          audioButton: document.getElementById("audio-button"),
          fullscreenButton: document.getElementById("fullscreen-button"),
          helpButton: document.getElementById("help-button"),
          settingsButton: document.getElementById("settings-button"),
          settingsPanel: document.getElementById("settings-panel"),
          settingsApply: document.getElementById("settings-apply"),
          settingsClose: document.getElementById("settings-close"),
          performanceIndicator: document.getElementById("performance-indicator"),
        };

        // Canvas contexts
        this.visualizerCtx = this.elements.audioVisualizer.getContext("2d");
      },

      // Check if device is mobile
      checkMobile: function () {
        this.config.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (this.config.isMobile) {
          // Reduce quality for mobile
          this.config.quality = "low";
          this.applyQualitySettings("low");
        }
      },

      // Apply quality settings
      applyQualitySettings: function (quality) {
        switch (quality) {
          case "low":
            this.config.density = 20;
            this.config.dancerCount = 30;
            this.config.regularPeopleCount = 15;
            this.config.skyObjectCount = 30;
            this.config.buildingCount = 50;
            this.config.laserCount = 15;
            this.config.showSmoke = false;
            this.config.bloomEnabled = false;
            break;
          case "medium":
            this.config.density = 40;
            this.config.dancerCount = 60;
            this.config.regularPeopleCount = 30;
            this.config.skyObjectCount = 60;
            this.config.buildingCount = 100;
            this.config.laserCount = 30;
            this.config.showSmoke = true;
            this.config.bloomEnabled = true;
            break;
          case "high":
            this.config.density = 60;
            this.config.dancerCount = 100;
            this.config.regularPeopleCount = 50;
            this.config.skyObjectCount = 100;
            this.config.buildingCount = 150;
            this.config.laserCount = 50;
            this.config.showSmoke = true;
            this.config.bloomEnabled = true;
            break;
          case "ultra":
            this.config.density = 100;
            this.config.dancerCount = 150;
            this.config.regularPeopleCount = 75;
            this.config.skyObjectCount = 150;
            this.config.buildingCount = 200;
            this.config.laserCount = 80;
            this.config.showSmoke = true;
            this.config.bloomEnabled = true;
            break;
        }
      },

      // Initialize loading screen
      initLoadingScreen: function () {
        // Glitch text effect
        setInterval(() => {
          if (Math.random() > 0.6) {
            const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+{}|:<>?";
            let glitched = "";
            const originalText = "INITIALIZING NEURAL INTERFACE";

            for (let i = 0; i < originalText.length; i++) {
              if (Math.random() > 0.7) {
                glitched += characters.charAt(Math.floor(Math.random() * characters.length));
              } else {
                glitched += originalText[i];
              }
            }

            this.elements.loadingText.textContent = glitched;
          } else {
            this.elements.loadingText.textContent = "INITIALIZING NEURAL INTERFACE";
          }
        }, 80);
      },

      // Load dependencies
      loadDependencies: function () {
        return new Promise((resolve, reject) => {
          // Simulate loading progress
          let progress = 0;
          const interval = setInterval(() => {
            progress += Math.random() * 10;
            if (progress >= 100) {
              progress = 100;
              clearInterval(interval);
              resolve();
            }
            this.elements.progressFill.style.width = `${progress}%`;
            this.elements.progressPercent.textContent = `${Math.round(progress)}%`;
          }, 150);
        });
      },

      // Show error message
      showError: function (message) {
        console.error(message);
        this.elements.errorMessage.textContent = message;
        this.elements.errorMessage.style.display = "block";
      },

      // Initialize Three.js scene
      initScene: function () {
        try {
          console.log("Initializing 3D scene...");
          
          // Create scene
          this.scene = new THREE.Scene();

          // Add fog for depth
          const theme = this.visualThemes[this.config.visualTheme];
          this.scene.fog = new THREE.FogExp2(theme.fogColor, 0.008); // Reduced fog density for more visibility

          // Create camera
          this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
          this.camera.position.set(0, 5, 20);

          // Create renderer
          this.renderer = new THREE.WebGLRenderer({
            canvas: this.elements.sceneCanvas,
            antialias: true,
            alpha: true,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

          // Create clock for animation
          this.clock = new THREE.Clock();

          // Create raycaster for collision detection
          this.raycaster = new THREE.Raycaster();

          // Create pointer lock controls for first-person movement
          this.controls = new THREE.PointerLockControls(this.camera, document.body);

          // Add crosshair
          this.createCrosshair();

          // Set up post-processing
          this.setupPostProcessing();

          // Create scene objects
          this.createSceneObjects();

          // Handle window resize
          window.addEventListener("resize", () => this.onWindowResize());

          // Hide loading screen
          setTimeout(() => {
            this.elements.loadingScreen.style.opacity = "0";
            setTimeout(() => {
              this.elements.loadingScreen.style.display = "none";
            }, 500);
          }, 1000);
          
          console.log("3D scene initialized successfully");
        } catch (error) {
          console.error("Failed to initialize 3D scene:", error);
          this.showError(`Failed to initialize 3D scene: ${error.message}`);
        }
      },

      // Create crosshair
      createCrosshair: () => {
        const crosshair = document.createElement("div");
        crosshair.className = "crosshair";
        document.body.appendChild(crosshair);
      },

      // Set up post-processing
      setupPostProcessing: function () {
        try {
          const theme = this.visualThemes[this.config.visualTheme];

          // Create composer
          this.composer = new THREE.EffectComposer(this.renderer);

          // Add render pass
          const renderPass = new THREE.RenderPass(this.scene, this.camera);
          this.composer.addPass(renderPass);

          // Add bloom pass if enabled
          if (this.config.bloomEnabled) {
            this.bloomPass = new THREE.UnrealBloomPass(
              new THREE.Vector2(window.innerWidth, window.innerHeight),
              theme.bloomStrength,
              theme.bloomRadius,
              theme.bloomThreshold,
            );
            this.composer.addPass(this.bloomPass);
          }

          // Add RGB shift pass
          this.rgbShiftPass = new THREE.ShaderPass(THREE.RGBShiftShader);
          this.rgbShiftPass.uniforms.amount.value = 0.0015;
          this.rgbShiftPass.uniforms.angle.value = 0;
          this.composer.addPass(this.rgbShiftPass);

          // Add glitch pass
          this.glitchPass = new THREE.GlitchPass();
          this.glitchPass.goWild = false;
          this.glitchPass.enabled = true;
          this.composer.addPass(this.glitchPass);
        } catch (error) {
          console.error("Failed to set up post-processing:", error);
          this.showError(`Failed to set up post-processing: ${error.message}`);
        }
      },

      // Create scene objects
      createSceneObjects: function () {
        try {
          const theme = this.visualThemes[this.config.visualTheme];

          // Create floor (dance floor)
          this.createDanceFloor(theme);

          // Create sky dome
          this.createSkyDome(theme);

          // Create particle system
          this.createParticles(theme);

          // Create characters
          this.createCharacters(theme);

          // Create buildings
          this.createBuildings(theme);

          // Create lasers
          this.createLasers(theme);

          // Create smoke machines
          if (this.config.showSmoke) {
            this.createSmokeMachines(theme);
          }

          // Create zones (different party areas)
          this.createZones(theme);

          // Set up infinite world generation
          this.setupInfiniteWorld();
        } catch (error) {
          console.error("Failed to create scene objects:", error);
          this.showError(`Failed to create scene objects: ${error.message}`);
        }
      },

      // Set up infinite world generation
      setupInfiniteWorld: function () {
        // Create a much larger floor that extends "infinitely"
        this.updateDanceFloor(2000); // Extremely large floor
        
        // Set up procedural generation based on player position
        this.lastGenerationPosition = new THREE.Vector3();
        this.generationRadius = 500;
        this.generationDistance = 300;
      },

      // Update dance floor size
      updateDanceFloor: function(size) {
        // Remove old floor
        if (this.floorMesh) {
          this.scene.remove(this.floorMesh);
        }
        
        const theme = this.visualThemes[this.config.visualTheme];
        
        // Create a much larger grid floor
        const floorSize = size;
        const floorSegments = 200;

        const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize, floorSegments, floorSegments);
        const floorMaterial = new THREE.MeshBasicMaterial({
          color: theme.gridColor,
          wireframe: true,
          transparent: true,
          opacity: 0.5,
        });

        this.floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        this.floorMesh.rotation.x = -Math.PI / 2;
        this.floorMesh.position.y = -2;
        this.scene.add(this.floorMesh);

        // Add a reflective surface under the wireframe
        const reflectiveGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
        const reflectiveMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.3,
        });

        const reflectiveMesh = new THREE.Mesh(reflectiveGeometry, reflectiveMaterial);
        reflectiveMesh.rotation.x = -Math.PI / 2;
        reflectiveMesh.position.y = -2.1;
        this.scene.add(reflectiveMesh);
      },

      // Check if we need to generate more content based on player position
      checkProceduralGeneration: function() {
        if (!this.lastGenerationPosition) return;
        
        const distanceMoved = this.camera.position.distanceTo(this.lastGenerationPosition);
        
        // If player has moved far enough, generate new content
        if (distanceMoved > this.generationDistance) {
          this.generateWorldContent();
          this.lastGenerationPosition.copy(this.camera.position);
        }
      },

      // Generate new world content around the player
      generateWorldContent: function() {
        const theme = this.visualThemes[this.config.visualTheme];
        const playerPos = this.camera.position.clone();
        
        // Generate new buildings
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = this.generationRadius * 0.5 + Math.random() * this.generationRadius * 0.5;
          
          const x = playerPos.x + Math.cos(angle) * distance;
          const z = playerPos.z + Math.sin(angle) * distance;
          
          this.createBuilding(x, z, theme);
        }
        
        // Generate new characters
        for (let i = 0; i < 15; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = this.generationRadius * 0.3 + Math.random() * this.generationRadius * 0.3;
          
          const x = playerPos.x + Math.cos(angle) * distance;
          const z = playerPos.z + Math.sin(angle) * distance;
          
          this.createCharacter(x, z, theme, Math.random() > 0.5);
        }
        
        // Generate new sky objects
        for (let i = 0; i < 10; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = this.generationRadius * 0.7 + Math.random() * this.generationRadius * 0.3;
          const height = 50 + Math.random() * 300;
          
          const x = playerPos.x + Math.cos(angle) * distance;
          const z = playerPos.z + Math.sin(angle) * distance;
          
          this.createSkyObject(x, height, z, theme);
        }
      },

      // Create a single building at specified position
      createBuilding: function(x, z, theme) {
        // Random building properties
        const width = 5 + Math.random() * 15;
        const height = 20 + Math.random() * 80;
        const depth = 5 + Math.random() * 15;
        
        // Random color
        const color1 = new THREE.Color(theme.buildingColor1);
        const color2 = new THREE.Color(theme.buildingColor2);
        const mixRatio = Math.random();
        const buildingColor = new THREE.Color().lerpColors(color1, color2, mixRatio);
        
        // Create building geometry
        const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
        const buildingMaterial = new THREE.MeshBasicMaterial({
          color: buildingColor,
          wireframe: true,
          transparent: true,
          opacity: 0.7,
        });
        
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        building.position.set(x, height / 2 - 2, z);
        
        this.scene.add(building);
        this.buildings.push(building);
        
        return building;
      },

      // Create a single character at specified position
      createCharacter: function(x, z, theme, isDancing) {
        // Create a simple character
        const bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
        const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
        
        // Random color
        const color1 = new THREE.Color(theme.particleColor1);
        const color2 = new THREE.Color(theme.particleColor2);
        const mixRatio = Math.random();
        const characterColor = new THREE.Color().lerpColors(color1, color2, mixRatio);
        
        const bodyMaterial = new THREE.MeshBasicMaterial({
          color: characterColor,
          wireframe: true,
        });
        
        const headMaterial = new THREE.MeshBasicMaterial({
          color: characterColor,
          wireframe: true,
        });
        
        // Create body and head
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        const head = new THREE.Mesh(headGeometry, headMaterial);
        
        // Position head on top of body
        head.position.y = 1.5;
        
        // Create character group
        const character = new THREE.Group();
        character.add(body);
        character.add(head);
        
        // Position character
        character.position.set(x, 0, z);
        
        // Add animation data
        character.userData = {
          isDancing: isDancing,
          danceSpeed: 0.5 + Math.random() * 1.5,
          danceOffset: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.05,
        };
        
        this.scene.add(character);
        this.characters.push(character);
        
        return character;
      },

      // Create a single sky object at specified position
      createSkyObject: function(x, y, z, theme) {
        // Random color
        const color1 = new THREE.Color(theme.particleColor1);
        const color2 = new THREE.Color(theme.particleColor2);
        const mixRatio = Math.random();
        const objectColor = new THREE.Color().lerpColors(color1, color2, mixRatio);
        
        // Create a random geometric shape
        let object;
        const shapeType = Math.floor(Math.random() * 5);
        
        const material = new THREE.MeshBasicMaterial({
          color: objectColor,
          wireframe: true,
          transparent: true,
          opacity: 0.7,
        });
        
        switch (shapeType) {
          case 0: // Cube
            const cubeGeometry = new THREE.BoxGeometry(
              10 + Math.random() * 20,
              10 + Math.random() * 20,
              10 + Math.random() * 20,
            );
            object = new THREE.Mesh(cubeGeometry, material);
            break;
          case 1: // Sphere
            const sphereGeometry = new THREE.SphereGeometry(5 + Math.random() * 15, 8, 8);
            object = new THREE.Mesh(sphereGeometry, material);
            break;
          case 2: // Torus
            const torusGeometry = new THREE.TorusGeometry(10 + Math.random() * 10, 3 + Math.random() * 5, 8, 16);
            object = new THREE.Mesh(torusGeometry, material);
            break;
          case 3: // Tetrahedron
            const tetraGeometry = new THREE.TetrahedronGeometry(10 + Math.random() * 15);
            object = new THREE.Mesh(tetraGeometry, material);
            break;
          case 4: // Octahedron
            const octaGeometry = new THREE.OctahedronGeometry(10 + Math.random() * 15);
            object = new THREE.Mesh(octaGeometry, material);
            break;
        }
        
        // Position
        object.position.set(x, y, z);
        
        // Add animation data
        object.userData = {
          rotationSpeed: {
            x: (Math.random() - 0.5) * 0.01,
            y: (Math.random() - 0.5) * 0.01,
            z: (Math.random() - 0.5) * 0.01,
          },
          floatSpeed: 0.2 + Math.random() * 0.8,
          floatOffset: Math.random() * Math.PI * 2,
          originalY: y,
        };
        
        this.scene.add(object);
        this.skyObjects.push(object);
        
        return object;
      },

      // Create dance floor
      createDanceFloor: function (theme) {
        // Create a grid floor for the dance floor
        const floorSize = 500; // Much larger floor
        const floorSegments = 100;

        const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize, floorSegments, floorSegments);
        const floorMaterial = new THREE.MeshBasicMaterial({
          color: theme.gridColor,
          wireframe: true,
          transparent: true,
          opacity: 0.5,
        });

        this.floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        this.floorMesh.rotation.x = -Math.PI / 2;
        this.floorMesh.position.y = -2;
        this.scene.add(this.floorMesh);

        // Add a reflective surface under the wireframe
        const reflectiveGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
        const reflectiveMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.3,
        });

        const reflectiveMesh = new THREE.Mesh(reflectiveGeometry, reflectiveMaterial);
        reflectiveMesh.rotation.x = -Math.PI / 2;
        reflectiveMesh.position.y = -2.1;
        this.scene.add(reflectiveMesh);
      },

      // Create sky dome
      createSkyDome: function (theme) {
        // Create a large sphere for the sky
        const skyGeometry = new THREE.SphereGeometry(5000, 64, 64);
        const skyMaterial = new THREE.MeshBasicMaterial({
          color: theme.skyColor,
          side: THREE.BackSide,
          transparent: true,
          opacity: 0.8,
        });

        this.skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
        this.scene.add(this.skyMesh);

        // Add stars to the sky dome
        const starCount = 3000;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
          // Create stars in a full sphere around the scene
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const radius = 900 + Math.random() * 100;

          starPositions[i * 3] = radius * Math.sin(theta) * Math.cos(theta);
          starPositions[i * 3 + 1] = radius * Math.cos(phi);
          starPositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
        }

        starGeometry.setAttribute("position", new THREE.BufferAttribute(starPositions, 3));

        const starMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 2,
          transparent: true,
          opacity: 0.8,
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        this.scene.add(stars);
        this.skyObjects.push(stars);

        // Add floating objects in the sky
        this.createSkyObjects(theme);
      },

      // Create sky objects
      createSkyObjects: function (theme) {
        if (!this.config.showSkyObjects) return;

        for (let i = 0; i < this.config.skyObjectCount; i++) {
          // Random position in the sky
          const radius = 100 + Math.random() * 400;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;

          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = 50 + Math.random() * 300; // Higher up in the sky
          const z = radius * Math.sin(phi) * Math.sin(theta);

          // Random color
          const color1 = new THREE.Color(theme.particleColor1);
          const color2 = new THREE.Color(theme.particleColor2);
          const mixRatio = Math.random();
          const objectColor = new THREE.Color().lerpColors(color1, color2, mixRatio);

          // Create a random geometric shape
          let object;
          const shapeType = Math.floor(Math.random() * 5);

          const material = new THREE.MeshBasicMaterial({
            color: objectColor,
            wireframe: true,
            transparent: true,
            opacity: 0.7,
          });

          switch (shapeType) {
            case 0: // Cube
              const cubeGeometry = new THREE.BoxGeometry(
                10 + Math.random() * 20,
                10 + Math.random() * 20,
                10 + Math.random() * 20,
              );
              object = new THREE.Mesh(cubeGeometry, material);
              break;
            case 1: // Sphere
              const sphereGeometry = new THREE.SphereGeometry(5 + Math.random() * 15, 8, 8);
              object = new THREE.Mesh(sphereGeometry, material);
              break;
            case 2: // Torus
              const torusGeometry = new THREE.TorusGeometry(10 + Math.random() * 10, 3 + Math.random() * 5, 8, 16);
              object = new THREE.Mesh(torusGeometry, material);
              break;
            case 3: // Tetrahedron
              const tetraGeometry = new THREE.TetrahedronGeometry(10 + Math.random() * 15);
              object = new THREE.Mesh(tetraGeometry, material);
              break;
            case 4: // Octahedron
              const octaGeometry = new THREE.OctahedronGeometry(10 + Math.random() * 15);
              object = new THREE.Mesh(octaGeometry, material);
              break;
          }

          // Position
          object.position.set(x, y, z);

          // Add animation data
          object.userData = {
            rotationSpeed: {
              x: (Math.random() - 0.5) * 0.01,
              y: (Math.random() - 0.5) * 0.01,
              z: (Math.random() - 0.5) * 0.01,
            },
            floatSpeed: 0.2 + Math.random() * 0.8,
            floatOffset: Math.random() * Math.PI * 2,
            originalY: y,
          };

          this.scene.add(object);
          this.skyObjects.push(object);
        }
      },

      // Create particles
      createParticles: function (theme) {
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = this.config.density * 200; // More particles

        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        const color1 = new THREE.Color(theme.particleColor1);
        const color2 = new THREE.Color(theme.particleColor2);

        for (let i = 0; i < particleCount; i++) {
          // Position - spread out over a much larger area
          const x = (Math.random() - 0.5) * 500;
          const y = Math.random() * 200;
          const z = (Math.random() - 0.5) * 500;

          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;

          // Color
          const mixRatio = Math.random();
          const mixedColor = new THREE.Color().lerpColors(color1, color2, mixRatio);

          colors[i * 3] = mixedColor.r;
          colors[i * 3 + 1] = mixedColor.g;
          colors[i * 3 + 2] = mixedColor.b;
        }

        particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const particleMaterial = new THREE.PointsMaterial({
          size: 4,
          vertexColors: true,
          transparent: true,
          opacity: 0.7,
        });

        this.particles = new THREE.Points(particleGeometry, particleMaterial);
        this.scene.add(this.particles);
      },

      // Create characters
      createCharacters: function (theme) {
        if (!this.config.showDancers) return;

        for (let i = 0; i < this.config.dancerCount; i++) {
          // Random position
          const x = (Math.random() - 0.5) * 400;
          const z = (Math.random() - 0.5) * 400;

          this.createCharacter(x, z, theme, true);
        }

        for (let i = 0; i < this.config.regularPeopleCount; i++) {
          // Random position
          const x = (Math.random() - 0.5) * 400;
          const z = (Math.random() - 0.5) * 400;

          this.createCharacter(x, z, theme, false);
        }
      },

      // Create buildings
      createBuildings: function (theme) {
        if (!this.config.showBuildings) return;

        for (let i = 0; i < this.config.buildingCount; i++) {
          // Random position
          const x = (Math.random() - 0.5) * 800;
          const z = (Math.random() - 0.5) * 800;

          this.createBuilding(x, z, theme);
        }
      },

      // Create lasers
      createLasers: function (theme) {
        if (!this.config.showLasers) return;

        for (let i = 0; i < this.config.laserCount; i++) {
          // Random start and end points
          const startX = (Math.random() - 0.5) * 400;
          const startY = 5 + Math.random() * 50;
          const startZ = (Math.random() - 0.5) * 400;

          const endX = (Math.random() - 0.5) * 400;
          const endY = 5 + Math.random() * 50;
          const endZ = (Math.random() - 0.5) * 400;

          // Random color
          const color1 = new THREE.Color(theme.particleColor1);
          const color2 = new THREE.Color(theme.particleColor2);
          const mixRatio = Math.random();
          const laserColor = new THREE.Color().lerpColors(color1, color2, mixRatio);

          // Create laser geometry using BufferGeometry instead of Geometry
          const laserGeometry = new THREE.BufferGeometry();
          const vertices = new Float32Array([
            startX, startY, startZ,
            endX, endY, endZ
          ]);
          laserGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

          const laserMaterial = new THREE.LineBasicMaterial({
            color: laserColor,
            transparent: true,
            opacity: 0.6,
          });

          const laser = new THREE.Line(laserGeometry, laserMaterial);
          this.scene.add(laser);
          this.lasers.push(laser);

          // Add animation data
          laser.userData = {
            color1: color1,
            color2: color2,
            mixRatio: Math.random(),
            colorChangeSpeed: 0.01 + Math.random() * 0.05,
          };
        }
      },

      // Create smoke machines
      createSmokeMachines: function (theme) {
        for (let i = 0; i < this.config.smokeCount; i++) {
          // Random position
          const x = (Math.random() - 0.5) * 400;
          const y = 0;
          const z = (Math.random() - 0.5) * 400;

          // Create smoke particle system using BufferGeometry
          const particleCount = 50;
          const smokeGeometry = new THREE.BufferGeometry();
          const positions = new Float32Array(particleCount * 3);
          const velocities = [];

          for (let j = 0; j < particleCount; j++) {
            positions[j * 3] = x;
            positions[j * 3 + 1] = y;
            positions[j * 3 + 2] = z;
            
            // Store velocity separately since BufferGeometry doesn't support custom attributes like Geometry did
            velocities.push(new THREE.Vector3(0, 0.5 + Math.random(), 0));
          }

          smokeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

          const smokeMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 5 + Math.random() * 10,
            transparent: true,
            opacity: 0.3,
          });

          const smoke = new THREE.Points(smokeGeometry, smokeMaterial);
          smoke.userData = { velocities: velocities }; // Store velocities in userData
          this.scene.add(smoke);
          this.smokeMachines.push(smoke);
        }
      },

      // Create zones
      createZones: function (theme) {
        // Create different party zones
        const zoneCount = 4;
        for (let i = 0; i < zoneCount; i++) {
          // Random position
          const x = (Math.random() - 0.5) * 800;
          const z = (Math.random() - 0.5) * 800;

          // Create zone geometry
          const zoneGeometry = new THREE.CircleGeometry(50 + Math.random() * 100, 32);
          const zoneMaterial = new THREE.MeshBasicMaterial({
            color: theme.gridColor,
            wireframe: true,
            transparent: true,
            opacity: 0.3,
          });

          const zone = new THREE.Mesh(zoneGeometry, zoneMaterial);
          zone.rotation.x = -Math.PI / 2;
          zone.position.set(x, -1.9, z);
          this.scene.add(zone);
          this.zones.push(zone);
        }
      },

      // Animate the scene
      animate: function () {
        this.animationFrameId = requestAnimationFrame(() => this.animate());

        // Get delta time
        const deltaTime = this.clock.getDelta();
        this.time += deltaTime;

        // Update movement
        this.updateMovement(deltaTime);

        // Update objects
        this.updateObjects(deltaTime);

        this.checkProceduralGeneration();

        // Update audio visualizer
        if (this.config.audioReactive && this.isPlaying) {
          this.updateAudioVisualizer();
        }

        // Render the scene
        this.render();

        // Update FPS counter
        this.updateFps(deltaTime);
      },

      // Update movement
      updateMovement: function (deltaTime) {
        // Only apply movement if pointer is locked
        if (!this.movement.pointerLocked) return;

        // Get camera direction
        this.camera.getWorldDirection(this.movement.direction);
        
        // Reset velocity
        this.movement.velocity.x = 0;
        this.movement.velocity.z = 0;
        this.movement.velocity.y = 0;

        // Calculate movement speed with delta time
        const speed = this.movement.speed * this.config.movementSpeed * deltaTime * 60;

        // Forward/backward
        if (this.movement.forward) {
          this.movement.velocity.x += this.movement.direction.x * speed;
          this.movement.velocity.z += this.movement.direction.z * speed;
        }
        if (this.movement.backward) {
          this.movement.velocity.x -= this.movement.direction.x * speed;
          this.movement.velocity.z -= this.movement.direction.z * speed;
        }

        // Left/right (strafe)
        if (this.movement.left) {
          this.movement.velocity.x += this.movement.direction.z * speed;
          this.movement.velocity.z -= this.movement.direction.x * speed;
        }
        if (this.movement.right) {
          this.movement.velocity.x -= this.movement.direction.z * speed;
          this.movement.velocity.z += this.movement.direction.x * speed;
        }

        // Up/down (flying)
        if (this.config.flyingEnabled) {
          if (this.movement.up) {
            this.movement.velocity.y += speed;
          }
          if (this.movement.down) {
            this.movement.velocity.y -= speed;
          }
        }

        // Apply velocity to camera position
        this.camera.position.x += this.movement.velocity.x;
        this.camera.position.z += this.movement.velocity.z;
        this.camera.position.y += this.movement.velocity.y;

        // Prevent going below the floor
        if (this.camera.position.y < 0) {
          this.camera.position.y = 0;
        }
      },

      // Update objects
      updateObjects: function (deltaTime) {
        // Update particles
        if (this.particles) {
          const positions = this.particles.geometry.attributes.position.array;

          for (let i = 0; i < positions.length; i += 3) {
            // Slightly move particles up and down
            positions[i + 1] += Math.sin(this.time + i) * 0.01;
          }

          this.particles.geometry.attributes.position.needsUpdate = true;
        }

        // Update characters
        this.characters.forEach((character) => {
          if (character.userData.isDancing) {
            // Make characters dance
            character.position.y = Math.sin(this.time * character.userData.danceSpeed + character.userData.danceOffset) * 2;
          }

          // Rotate characters slowly
          character.rotation.y += character.userData.rotationSpeed;
        });

        // Update sky objects
        this.skyObjects.forEach((object) => {
          // Rotate objects
          if (object.userData && object.userData.rotationSpeed) {
            object.rotation.x += object.userData.rotationSpeed.x;
            object.rotation.y += object.userData.rotationSpeed.y;
            object.rotation.z += object.userData.rotationSpeed.z;
          }

          // Float objects up and down
          if (object.userData && object.userData.floatSpeed) {
            object.position.y = object.userData.originalY + Math.sin(this.time * object.userData.floatSpeed + object.userData.floatOffset) * 10;
          }
        });

        // Update lasers
        this.lasers.forEach((laser) => {
          // Change laser color over time
          laser.userData.mixRatio += laser.userData.colorChangeSpeed;
          if (laser.userData.mixRatio > 1) {
            laser.userData.mixRatio = 0;
            laser.userData.colorChangeSpeed = 0.01 + Math.random() * 0.05;
          }

          const laserColor = new THREE.Color().lerpColors(laser.userData.color1, laser.userData.color2, laser.userData.mixRatio);
          laser.material.color.set(laserColor);
        });

        // Update smoke machines
        this.smokeMachines.forEach((smoke) => {
          if (smoke.userData && smoke.userData.velocities) {
            const positions = smoke.geometry.attributes.position.array;
            const velocities = smoke.userData.velocities;
            
            for (let i = 0; i < velocities.length; i++) {
              const idx = i * 3;
              positions[idx + 1] += velocities[i].y * deltaTime * 10;
              
              // Reset particle if it goes too high
              if (positions[idx + 1] > 100) {
                positions[idx + 1] = 0;
              }
            }
            
            smoke.geometry.attributes.position.needsUpdate = true;
          }
        });

        // Update sky dome position to follow camera
        if (this.skyMesh) {
          this.skyMesh.position.copy(this.camera.position);
        }
      },

      // Update audio visualizer
      updateAudioVisualizer: function () {
        if (!this.audioAnalyser) return;

        // Get frequency data
        this.frequencyData = new Uint8Array(this.audioAnalyser.frequencyBinCount);
        this.audioAnalyser.getByteFrequencyData(this.frequencyData);

        // Normalize frequency data
        const normalizedData = Array.from(this.frequencyData).map((value) => value / 256);

        // Clear visualizer
        this.visualizerCtx.clearRect(0, 0, this.elements.audioVisualizer.width, this.elements.audioVisualizer.height);

        // Draw frequency bars
        const barWidth = this.elements.audioVisualizer.width / normalizedData.length;
        let x = 0;

        normalizedData.forEach((value) => {
          const barHeight = value * this.elements.audioVisualizer.height;
          this.visualizerCtx.fillStyle = "#ff00ff";
          this.visualizerCtx.fillRect(x, this.elements.audioVisualizer.height - barHeight, barWidth, barHeight);
          x += barWidth;
        });

        // Adjust trippy level based on audio
        const averageFrequency = normalizedData.reduce((a, b) => a + b, 0) / normalizedData.length;
        this.config.trippyLevel = 0.5 + averageFrequency * 1.5;

        // Adjust bloom intensity based on bass
        const bassFrequency = normalizedData[1];
        const bassImpact = bassFrequency * this.config.bassImpact;

        if (this.bloomPass) {
          this.bloomPass.strength = this.visualThemes[this.config.visualTheme].bloomStrength + bassImpact * 0.5;
        }

        // Adjust glitch intensity based on audio
        this.glitchPass.enabled = bassImpact > 0.2;
        this.glitchPass.goWild = bassImpact > 0.5;

        // Adjust RGB shift amount based on audio
        this.rgbShiftPass.uniforms.amount.value = 0.0015 + bassImpact * 0.001;
      },

      // Update FPS counter
      updateFps: function (deltaTime) {
        this.frameCount++;
        const now = performance.now();
        if (now - this.lastFpsUpdate >= 1000) {
          this.fps = Math.round(this.frameCount / ((now - this.lastFpsUpdate) / 1000));
          this.frameCount = 0;
          this.lastFpsUpdate = now;

          if (this.config.showFps) {
            this.elements.performanceIndicator.textContent = `FPS: ${this.fps}`;
            this.elements.performanceIndicator.style.display = "block";
          } else {
            this.elements.performanceIndicator.style.display = "none";
          }
        }
      },

      // Render the scene
      render: function () {
        if (this.composer) {
          this.composer.render();
        } else {
          this.renderer.render(this.scene, this.camera);
        }
      },

      // Handle window resize
      onWindowResize: function () {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        if (this.composer) {
          this.composer.setSize(window.innerWidth, window.innerHeight);
        }
      },

      // Initialize audio
      initAudio: function () {
        try {
          console.log("Initializing audio...");
          
          // Create audio context
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

          // Create analyser
          this.audioAnalyser = this.audioContext.createAnalyser();
          this.audioAnalyser.fftSize = 2048;

          // Load audio track
          this.loadAudioTrack(this.config.audioTrack);

          // Set initial volume
          this.setVolume(this.config.volume);
          
          console.log("Audio initialized successfully");
        } catch (error) {
          console.error("Failed to initialize audio:", error);
          this.showError(`Failed to initialize audio: ${error.message}`);
        }
      },

      // Load audio track
      loadAudioTrack: function (trackName) {
        if (!this.audioTracks[trackName]) {
          console.error(`Audio track "${trackName}" not found.`);
          this.showError(`Audio track "${trackName}" not found.`);
          return;
        }

        const track = this.audioTracks[trackName];
        this.elements.trackInfo.textContent = `Loading: ${track.title}`;
        this.elements.audioStatus.textContent = "Loading audio...";
        this.elements.audioStatus.style.display = "block";

        fetch(track.url)
          .then((response) => response.arrayBuffer())
          .then((buffer) => this.audioContext.decodeAudioData(buffer))
          .then((audioBuffer) => {
            if (this.audioSource) {
              this.audioSource.stop();
              this.audioSource.disconnect(this.audioAnalyser);
            }

            this.audioSource = this.audioContext.createBufferSource();
            this.audioSource.buffer = audioBuffer;
            this.audioSource.loop = true;
            this.audioSource.connect(this.audioAnalyser);
            this.audioAnalyser.connect(this.audioContext.destination);

            this.audioSource.onended = () => {
              console.log("Track ended, playing next track");
              this.playNextTrack();
            };

            this.audioElement = track;
            this.audioLoaded = true;
            this.elements.trackInfo.textContent = `Now Playing: ${track.title}`;
            this.elements.audioStatus.textContent = "Audio loaded, ready to play";

            if (this.isPlaying) {
              this.audioSource.start(0);
              this.elements.audioStatus.textContent = "Playing";
            } else {
              this.elements.audioStatus.style.display = "none";
            }
          })
          .catch((error) => {
            console.error("Failed to load audio track:", error);
            this.showError(`Failed to load audio track: ${error.message}`);
            this.elements.audioStatus.textContent = "Error loading audio";
          });
      },

      // Play audio
      playAudio: function () {
        if (!this.audioLoaded) {
          console.warn("Audio not loaded yet.");
          this.elements.audioStatus.textContent = "Audio not loaded yet";
          this.elements.audioStatus.style.display = "block";
          return;
        }

        if (this.isPlaying) {
          console.log("Audio is already playing.");
          return;
        }

        this.audioContext.resume().then(() => {
          this.audioSource.start(0);
          this.isPlaying = true;
          this.elements.audioStatus.textContent = "Playing";
          this.elements.audioStatus.style.display = "block";
        });
      },

      // Pause audio
      pauseAudio: function () {
        if (!this.isPlaying) {
          console.log("Audio is already paused.");
          return;
        }

        this.audioSource.stop();
        this.isPlaying = false;
        this.elements.audioStatus.textContent = "Paused";
        this.elements.audioStatus.style.display = "block";

        // Re-create audio source to allow playing again
        this.loadAudioTrack(this.config.audioTrack);
      },

      // Toggle audio
      toggleAudio: function () {
        if (this.isPlaying) {
          this.pauseAudio();
        } else {
          this.playAudio();
        }
      },

      // Set volume
      setVolume: function (volume) {
        if (!this.audioSource) return;

        const gainNode = this.audioContext.createGain();
        gainNode.gain.value = volume;
        this.audioSource.disconnect(this.audioContext.destination);
        this.audioSource.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
      },

      // Play next track
      playNextTrack: function () {
        if (this.config.randomizeTracks) {
          const trackNames = Object.keys(this.audioTracks);
          let nextTrack = trackNames[Math.floor(Math.random() * trackNames.length)];

          // Ensure we don't play the same track twice in a row
          if (nextTrack === this.config.audioTrack && trackNames.length > 1) {
            let newTrackIndex = (trackNames.indexOf(nextTrack) + 1) % trackNames.length;
            nextTrack = trackNames[newTrackIndex];
          }

          this.config.audioTrack = nextTrack;
          this.loadAudioTrack(nextTrack);
          if (this.isPlaying) {
            this.playAudio();
          }
        } else {
          // Play tracks in order
          const trackNames = Object.keys(this.audioTracks);
          const currentTrackIndex = trackNames.indexOf(this.config.audioTrack);
          let nextTrackIndex = (currentTrackIndex + 1) % trackNames.length;
          this.config.audioTrack = trackNames[nextTrackIndex];
          this.loadAudioTrack(trackNames[nextTrackIndex]);
          if (this.isPlaying) {
            this.playAudio();
          }
        }
      },

      // Initialize controls
      initControls: function () {
        // Pointer lock
        document.body.addEventListener("click", () => {
          this.controls.lock();
        });

        document.addEventListener("pointerlockchange", () => {
          this.movement.pointerLocked = document.pointerLockElement === document.body;
          this.elements.controlsInfo.style.display = this.movement.pointerLocked ? "none" : "block";
        });

        // Keyboard controls
        document.addEventListener("keydown", (event) => {
          switch (event.code) {
            case "KeyW":
              this.movement.forward = true;
              break;
            case "KeyS":
              this.movement.backward = true;
              break;
            case "KeyA":
              this.movement.left = true;
              break;
            case "KeyD":
              this.movement.right = true;
              break;
            case "Space":
              this.movement.up = true;
              break;
            case "ShiftLeft":
              this.movement.down = true;
              break;
            case "Escape":
              this.controls.unlock();
              break;
            case "KeyF":
              this.toggleFullscreen();
              break;
            case "KeyM":
              this.toggleAudio();
              break;
            case "KeyT":
              this.changeTheme();
              break;
            case "KeyN":
              this.playNextTrack();
              break;
            case "KeyP":
              this.toggleSettings();
              break;
            case "KeyH":
              this.toggleControlsInfo();
              break;
          }
        });

        document.addEventListener("keyup", (event) => {
          switch (event.code) {
            case "KeyW":
              this.movement.forward = false;
              break;
            case "KeyS":
              this.movement.backward = false;
              break;
            case "KeyA":
              this.movement.left = false;
              break;
            case "KeyD":
              this.movement.right = false;
              break;
            case "Space":
              this.movement.up = false;
              break;
            case "ShiftLeft":
              this.movement.down = false;
              break;
          }
        });

        // Button controls
        this.elements.fullscreenButton.addEventListener("click", () => this.toggleFullscreen());
        this.elements.themeButton.addEventListener("click", () => this.changeTheme());
        this.elements.trackButton.addEventListener("click", () => this.toggleTrackSelector());
        this.elements.audioButton.addEventListener("click", () => this.toggleAudio());
        this.elements.helpButton.addEventListener("click", () => this.toggleControlsInfo());
        this.elements.settingsButton.addEventListener("click", () => this.toggleSettings());
        this.elements.settingsApply.addEventListener("click", () => this.applySettings());
        this.elements.settingsClose.addEventListener("click", () => this.toggleSettings());

        // Track selector
        this.populateTrackSelector();

        // Theme indicator
        this.updateThemeIndicator();
      },

      // Toggle fullscreen
      toggleFullscreen: function () {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          document.body.requestFullscreen();
        }
      },

      // Change theme
      changeTheme: function () {
        const themeNames = Object.keys(this.visualThemes);
        const currentThemeIndex = themeNames.indexOf(this.config.visualTheme);
        const nextThemeIndex = (currentThemeIndex + 1) % themeNames.length;
        this.config.visualTheme = themeNames[nextThemeIndex];

        // Update theme
        this.updateTheme();
      },

      // Update theme
      updateTheme: function () {
        const theme = this.visualThemes[this.config.visualTheme];

        // Update fog color
        this.scene.fog.color.set(theme.fogColor);

        // Update floor color
        if (this.floorMesh) {
          this.floorMesh.material.color.set(theme.gridColor);
        }

        // Update sky color
        if (this.skyMesh) {
          this.skyMesh.material.color.set(theme.skyColor);
        }

        // Update particles color
        if (this.particles) {
          const color1 = new THREE.Color(theme.particleColor1);
          const color2 = new THREE.Color(theme.particleColor2);
          const colors = this.particles.geometry.attributes.color.array;

          for (let i = 0; i < colors.length; i += 3) {
            const mixRatio = Math.random();
            const mixedColor = new THREE.Color().lerpColors(color1, color2, mixRatio);

            colors[i] = mixedColor.r;
            colors[i + 1] = mixedColor.g;
            colors[i + 2] = mixedColor.b;
          }

          this.particles.geometry.attributes.color.needsUpdate = true;
        }

        // Update buildings color
        this.buildings.forEach((building) => {
          const color1 = new THREE.Color(theme.buildingColor1);
          const color2 = new THREE.Color(theme.buildingColor2);
          const mixRatio = Math.random();
          const buildingColor = new THREE.Color().lerpColors(color1, color2, mixRatio);
          building.material.color.set(buildingColor);
        });

        // Update lasers color
        this.lasers.forEach((laser) => {
          laser.userData.color1.set(theme.particleColor1);
          laser.userData.color2.set(theme.particleColor2);
        });

        // Update bloom pass
        if (this.bloomPass) {
          this.bloomPass.strength = theme.bloomStrength;
          this.bloomPass.radius = theme.bloomRadius;
          this.bloomPass.threshold = theme.bloomThreshold;
        }

        // Update theme indicator
        this.updateThemeIndicator();
      },

      // Update theme indicator
      updateThemeIndicator: function () {
        this.elements.themeIndicator.textContent = this.visualThemes[this.config.visualTheme].name;
        this.elements.themeIndicator.classList.add("fade-in");
        this.elements.themeIndicator.style.opacity = 1;

        setTimeout(() => {
          this.elements.themeIndicator.classList.remove("fade-in");
          this.elements.themeIndicator.classList.add("fade-out");
          setTimeout(() => {
            this.elements.themeIndicator.classList.remove("fade-out");
            this.elements.themeIndicator.style.opacity = 0;
          }, 500);
        }, 3000);
      },

      // Populate track selector
      populateTrackSelector: function () {
        const trackNames = Object.keys(this.audioTracks);

        trackNames.forEach((trackName) => {
          const track = this.audioTracks[trackName];
          const trackOption = document.createElement("div");
          trackOption.className = "track-option";
          trackOption.textContent = track.title;
          trackOption.dataset.track = trackName;

          trackOption.addEventListener("click", () => {
            this.config.audioTrack = trackName;
            this.loadAudioTrack(trackName);
            this.toggleTrackSelector();

            // Update active state
            document.querySelectorAll(".track-option").forEach((option) => {
              option.classList.remove("active");
            });
            trackOption.classList.add("active");
          });

          this.elements.trackSelector.appendChild(trackOption);
        });
      },

      // Toggle track selector
      toggleTrackSelector: function () {
        this.elements.trackSelector.style.display = this.elements.trackSelector.style.display === "none" ? "block" : "none";
      },

      // Toggle controls info
      toggleControlsInfo: function () {
        this.elements.controlsInfo.style.display = this.elements.controlsInfo.style.display === "none" ? "block" : "none";
      },

      // Toggle settings
      toggleSettings: function () {
        this.elements.settingsPanel.style.display = this.elements.settingsPanel.style.display === "none" ? "block" : "none";
      },

      // Apply settings
      applySettings: function () {
        // Get settings values
        const quality = document.getElementById("quality-setting").value;
        const density = document.getElementById("density-setting").value;
        const showFps = document.getElementById("fps-setting").checked;
        const bloomIntensity = document.getElementById("bloom-setting").value;
        const glitchIntensity = document.getElementById("glitch-setting").value;
        const colorShiftSpeed = document.getElementById("color-shift-setting").value;
        const volume = document.getElementById("volume-setting").value;
        const bassImpact = document.getElementById("bass-setting").value;
        const ambientSound = document.getElementById("ambient-setting").checked;
        const randomizeTracks = document.getElementById("random-tracks-setting").checked;
        const movementSpeed = document.getElementById("movement-speed-setting").value;
        const flyingEnabled = document.getElementById("flying-setting").checked;
        const sensitivity = document.getElementById("sensitivity-setting").value;

        // Apply settings
        this.config.quality = quality;
        this.applyQualitySettings(quality);
        this.config.density = density;
        this.config.showFps = showFps;
        this.config.volume = volume;
        this.config.bassImpact = bassImpact;
        this.config.randomizeTracks = randomizeTracks;
        this.config.movementSpeed = movementSpeed;
        this.config.flyingEnabled = flyingEnabled;
        this.config.mouseSensitivity = sensitivity;

        // Apply audio settings
        this.setVolume(volume);

        // Apply visual effects settings
        this.config.glitchIntensity = glitchIntensity;
        this.config.colorShiftSpeed = colorShiftSpeed;

        if (this.bloomPass) {
          this.bloomPass.strength = bloomIntensity;
        }

        // Update scene objects
        this.updateScene();

        // Toggle settings panel
        this.toggleSettings();
      },

      // Update scene
      updateScene: function () {
        // Clear scene
        this.clearScene();

        // Create scene objects
        this.createSceneObjects();
      },

      // Clear scene
      clearScene: function () {
        // Remove all objects from the scene
        while (this.scene.children.length > 0) {
          this.scene.remove(this.scene.children[0]);
        }

        // Dispose of geometries and materials
        if (this.particles) this.particles.geometry.dispose();
        if (this.particles) this.particles.material.dispose();
        if (this.floorMesh) this.floorMesh.geometry.dispose();
        if (this.floorMesh) this.floorMesh.material.dispose();
        if (this.skyMesh) this.skyMesh.geometry.dispose();
        if (this.skyMesh) this.skyMesh.material.dispose();

        this.characters.forEach((character) => {
          character.children.forEach((child) => {
            child.geometry.dispose();
            child.material.dispose();
          });
        });

        this.buildings.forEach((building) => {
          building.geometry.dispose();
          building.material.dispose();
        });

        this.lasers.forEach((laser) => {
          laser.geometry.dispose();
          laser.material.dispose();
        });

        this.smokeMachines.forEach((smoke) => {
          smoke.geometry.dispose();
          smoke.material.dispose();
        });

        this.zones.forEach((zone) => {
          zone.geometry.dispose();
          zone.material.dispose();
        });

        this.characters = [];
        this.buildings = [];
        this.lasers = [];
        this.smokeMachines = [];
        this.zones = [];
      },
    };

    // Initialize Tripscape when the page loads
    window.onload = () => {
      Tripscape.init();
    };
  </script>
</body>
</html>
