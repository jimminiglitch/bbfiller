<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate ASCII Art Studio</title>
  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    @font-face {
      font-family: 'Cyberpunk';
      src: url('https://fonts.gstatic.com/s/pressstart2p/v14/e3t4euO8T-267oIAQAu6jDQyK3nVivNm4I81.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
    }

    @keyframes gradientBG {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes glitch {
      0% {
        text-shadow: 0.05em 0 0 rgba(255, 0, 255, 0.75), -0.05em -0.025em 0 rgba(0, 255, 255, 0.75);
      }
      14% {
        text-shadow: 0.05em 0 0 rgba(255, 0, 255, 0.75), -0.05em -0.025em 0 rgba(0, 255, 255, 0.75);
      }
      15% {
        text-shadow: -0.05em -0.025em 0 rgba(255, 0, 255, 0.75), 0.025em 0.025em 0 rgba(0, 255, 255, 0.75);
      }
      49% {
        text-shadow: -0.05em -0.025em 0 rgba(255, 0, 255, 0.75), 0.025em 0.025em 0 rgba(0, 255, 255, 0.75);
      }
      50% {
        text-shadow: 0.025em 0.05em 0 rgba(255, 0, 255, 0.75), 0.05em 0 0 rgba(0, 255, 255, 0.75);
      }
      99% {
        text-shadow: 0.025em 0.05em 0 rgba(255, 0, 255, 0.75), 0.05em 0 0 rgba(0, 255, 255, 0.75);
      }
      100% {
        text-shadow: -0.025em 0 0 rgba(255, 0, 255, 0.75), -0.025em -0.025em 0 rgba(0, 255, 255, 0.75);
      }
    }

    @keyframes scanline {
      0% {
        transform: translateY(-100%);
      }
      100% {
        transform: translateY(100%);
      }
    }

    @keyframes matrixRain {
      0% {
        transform: translateY(-100%);
        opacity: 1;
      }
      85% {
        opacity: 1;
      }
      100% {
        transform: translateY(100%);
        opacity: 0;
      }
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.6;
      }
      100% {
        opacity: 1;
      }
    }

    @keyframes flicker {
      0% {
        opacity: 1;
      }
      5% {
        opacity: 0.8;
      }
      10% {
        opacity: 1;
      }
      15% {
        opacity: 0.3;
      }
      20% {
        opacity: 1;
      }
      55% {
        opacity: 1;
      }
      60% {
        opacity: 0.5;
      }
      65% {
        opacity: 1;
      }
      70% {
        opacity: 0.7;
      }
      75% {
        opacity: 1;
      }
      80% {
        opacity: 0.8;
      }
      85% {
        opacity: 1;
      }
      90% {
        opacity: 0.6;
      }
      95% {
        opacity: 1;
      }
      100% {
        opacity: 0.9;
      }
    }

    @keyframes shake {
      0%, 100% {
        transform: translateX(0);
      }
      10%, 30%, 50%, 70%, 90% {
        transform: translateX(-2px);
      }
      20%, 40%, 60%, 80% {
        transform: translateX(2px);
      }
    }

    :root {
      --primary-color: #ff69b4;
      --secondary-color: #89fff1;
      --bg-color: #0a0a12;
      --bg-gradient: linear-gradient(45deg, #0a0a12 0%, #1a0b2e 50%, #0a0a12 100%);
      --panel-bg: rgba(10, 10, 18, 0.8);
      --border-color: rgba(137, 255, 241, 0.5);
      --text-color: #f0f0f0;
      --highlight-color: #ff69b4;
    }

    body {
      font-family: 'Courier New', monospace;
      background-color: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      overflow: hidden;
      position: relative;
    }

    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-gradient);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
      z-index: -2;
    }

    body::after {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15),
        rgba(0, 0, 0, 0.15) 1px,
        transparent 1px,
        transparent 2px
      );
      pointer-events: none;
      z-index: 1;
    }

    .grid-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(rgba(33, 16, 74, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(33, 16, 74, 0.1) 1px, transparent 1px);
      background-size: 20px 20px;
      z-index: -1;
      perspective: 1000px;
      transform: rotateX(60deg) scale(2.5) translateZ(-100px);
      transform-origin: center center;
      opacity: 0.5;
    }

    .scanline {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100px;
      background: linear-gradient(
        to bottom,
        transparent,
        rgba(137, 255, 241, 0.1),
        rgba(255, 105, 180, 0.1),
        transparent
      );
      z-index: 2;
      pointer-events: none;
      animation: scanline 8s linear infinite;
    }

    /* Layout */
    .container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      width: 100%;
      overflow: hidden;
      position: relative;
      z-index: 0;
    }

    @media (min-width: 768px) {
      .container {
        flex-direction: row;
      }
    }

    /* Control panel */
    .control-panel {
      background-color: var(--panel-bg);
      backdrop-filter: blur(10px);
      padding: 1rem;
      width: 100%;
      order: 2;
      flex: 0 0 auto;
      font-family: 'Courier New', monospace;
      color: var(--text-color);
      overflow-y: auto;
      border-top: 1px solid var(--highlight-color);
      box-shadow: 0 0 20px rgba(255, 105, 180, 0.3);
      z-index: 10;
    }

    @media (min-width: 768px) {
      .control-panel {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 25%;
        order: 1;
        border-top: none;
        border-right: 1px solid var(--highlight-color);
      }
    }

    .control-panel-inner {
      border: 1px solid var(--border-color);
      border-radius: 0.375rem;
      padding: 0.5rem;
      background: rgba(10, 10, 18, 0.5);
      box-shadow: 0 0 10px rgba(137, 255, 241, 0.2) inset;
    }

    @media (min-width: 768px) {
      .control-panel-inner {
        padding: 1rem;
      }
    }

    /* Preview area */
    .preview-area {
      flex: 1;
      background-color: rgba(10, 10, 18, 0.5);
      overflow: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      order: 1;
      position: relative;
    }

    @media (min-width: 768px) {
      .preview-area {
        order: 2;
        margin-left: 25%;
        width: 75%;
      }
    }

    /* Resizer */
    .resizer {
      display: none;
      position: absolute;
      width: 8px;
      background-color: rgba(137, 255, 241, 0.3);
      top: 0;
      bottom: 0;
      left: 25%;
      cursor: col-resize;
      z-index: 10;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s;
    }

    .resizer:hover {
      background-color: rgba(255, 105, 180, 0.5);
    }

    @media (min-width: 768px) {
      .resizer {
        display: flex;
      }
    }

    /* Tabs */
    .tabs {
      display: flex;
      margin-bottom: 1rem;
      border-bottom: 1px solid var(--border-color);
      overflow-x: auto;
      scrollbar-width: none;
    }

    .tabs::-webkit-scrollbar {
      display: none;
    }

    .tab {
      padding: 0.5rem 1rem;
      cursor: pointer;
      color: var(--text-color);
      opacity: 0.7;
      transition: all 0.2s;
      white-space: nowrap;
      position: relative;
    }

    .tab:hover {
      opacity: 1;
      background-color: rgba(137, 255, 241, 0.1);
    }

    .tab.active {
      opacity: 1;
      color: var(--highlight-color);
    }

    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      width: 100%;
      height: 2px;
      background-color: var(--highlight-color);
      box-shadow: 0 0 10px var(--highlight-color);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Form elements */
    .form-group {
      margin-bottom: 1rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(137, 255, 241, 0.3);
    }

    .form-group:first-of-type {
      border-top: none;
      padding-top: 0;
    }

    .form-label {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--text-color);
      font-size: 0.875rem;
      text-shadow: 0 0 5px rgba(137, 255, 241, 0.7);
    }

    .form-title {
      font-family: 'Cyberpunk', 'Courier New', monospace;
      font-size: 1.125rem;
      font-weight: bold;
      color: var(--highlight-color);
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 10px rgba(255, 105, 180, 0.7);
      animation: glitch 3s infinite alternate;
    }

    .error-message {
      color: #ff4757;
      font-size: 0.875rem;
      margin-top: 0.5rem;
      text-shadow: 0 0 5px rgba(255, 71, 87, 0.7);
    }

    /* Slider */
    .slider-container {
      position: relative;
      height: 24px;
      display: flex;
      align-items: center;
    }

    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: rgba(137, 255, 241, 0.3);
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--highlight-color);
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 105, 180, 0.7);
    }

    .slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--highlight-color);
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(255, 105, 180, 0.7);
    }

    /* Select */
    .select-container {
      position: relative;
    }

    .select {
      width: 100%;
      padding: 0.5rem;
      background-color: rgba(10, 10, 18, 0.8);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      border-radius: 0.25rem;
      font-family: inherit;
      font-size: 0.875rem;
      appearance: none;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(137, 255, 241, 0.3);
    }

    .select:focus {
      outline: none;
      border-color: var(--highlight-color);
      box-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
    }

    .select-arrow {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: var(--highlight-color);
    }

    /* Switch */
    .switch-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 36px;
      height: 20px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider-switch {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(10, 10, 18, 0.8);
      transition: .4s;
      border-radius: 20px;
      border: 1px solid var(--border-color);
    }

    .slider-switch:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 1px;
      background-color: var(--text-color);
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider-switch {
      background-color: rgba(255, 105, 180, 0.5);
    }

    input:checked + .slider-switch:before {
      transform: translateX(16px);
    }

    /* Buttons */
    .button-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
      flex-wrap: wrap;
    }

    .button {
      padding: 0.5rem 1rem;
      background-color: rgba(10, 10, 18, 0.8);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 0.25rem;
      font-family: inherit;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      min-width: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      position: relative;
      overflow: hidden;
    }

    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.2),
        transparent
      );
      transition: 0.5s;
    }

    .button:hover::before {
      left: 100%;
    }

    .button:hover:not(:disabled) {
      background-color: rgba(137, 255, 241, 0.2);
      border-color: var(--highlight-color);
      box-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
    }

    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .button-icon {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }

    .button-webcam {
      background-color: rgba(255, 105, 180, 0.3);
    }

    .button-webcam.active {
      background-color: rgba(255, 105, 180, 0.6);
      box-shadow: 0 0 15px rgba(255, 105, 180, 0.7);
    }

    .button-capture {
      background-color: rgba(137, 255, 241, 0.3);
    }

    .button-social {
      background-color: rgba(10, 10, 18, 0.8);
      flex: 0 0 auto;
      min-width: 40px;
      padding: 0.5rem;
    }

    /* ASCII output */
    .ascii-output {
      font-family: monospace;
      white-space: pre;
      line-height: 1;
      font-size: 0.4rem;
      max-width: 100%;
      overflow: auto;
      user-select: text;
      filter: drop-shadow(0 0 2px rgba(137, 255, 241, 0.7));
    }

    /* Drag and drop */
    .drop-zone {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(10, 10, 18, 0.7);
      z-index: 10;
      font-family: 'Cyberpunk', 'Courier New', monospace;
      font-size: 1.25rem;
      text-shadow: 0 0 10px rgba(137, 255, 241, 0.7);
      border: 2px dashed var(--highlight-color);
    }

    .loading-message, .error-display {
      font-family: 'Courier New', monospace;
      text-align: center;
      padding: 1rem;
      text-shadow: 0 0 10px rgba(137, 255, 241, 0.7);
    }

    .error-display {
      color: #ff4757;
      font-size: 0.875rem;
      margin-top: 0.5rem;
      text-shadow: 0 0 5px rgba(255, 71, 87, 0.7);
    }

    .error-display .subtext {
      color: var(--text-color);
      font-size: 0.875rem;
      margin-top: 0.5rem;
    }

    /* Hide canvas used for processing */
    .hidden-canvas {
      display: none;
    }

    /* Icons */
    .icon-grip {
      width: 24px;
      height: 24px;
      color: rgba(137, 255, 241, 0.5);
    }

    /* Webcam */
    .webcam-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(10, 10, 18, 0.8);
      z-index: 5;
    }

    .webcam-video {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .webcam-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      border: 2px solid var(--border-color);
      box-shadow: 0 0 0 2px rgba(255, 105, 180, 0.3);
      z-index: 6;
    }

    .webcam-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 7;
    }

    /* Color themes */
    .color-theme-option {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: transform 0.2s;
    }

    .color-theme-option:hover {
      transform: scale(1.2);
    }

    .color-theme-option.active {
      border-color: white;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
    }

    .color-theme-container {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
    }

    .theme-cyberpunk {
      background: linear-gradient(45deg, #ff69b4, #89fff1);
    }

    .theme-vaporwave {
      background: linear-gradient(45deg, #ff6ad5, #8c52ff);
    }

    .theme-matrix {
      background: linear-gradient(45deg, #00ff41, #003b00);
    }

    .theme-synthwave {
      background: linear-gradient(45deg, #fc5c7d, #6a82fb);
    }

    .theme-outrun {
      background: linear-gradient(45deg, #f7971e, #ffd200);
    }

    /* Color picker */
    .color-picker-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .color-picker-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .color-picker-label {
      flex: 1;
      font-size: 0.75rem;
    }

    .color-picker {
      -webkit-appearance: none;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      background-color: transparent;
    }

    .color-picker::-webkit-color-swatch {
      border: 2px solid var(--border-color);
      border-radius: 50%;
    }

    .color-picker::-moz-color-swatch {
      border: 2px solid var(--border-color);
      border-radius: 50%;
    }

    /* Video controls */
    .video-controls {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      align-items: center;
    }

    .video-progress {
      flex: 1;
      height: 4px;
      background-color: rgba(137, 255, 241, 0.3);
      position: relative;
      cursor: pointer;
      border-radius: 2px;
    }

    .video-progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background-color: var(--highlight-color);
      border-radius: 2px;
    }

    .video-time {
      font-size: 0.75rem;
      min-width: 60px;
      text-align: center;
    }

    /* Animation controls */
    .animation-controls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .animation-speed-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .animation-speed-label {
      font-size: 0.75rem;
      min-width: 100px;
    }

    /* Social sharing */
    .social-share-container {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
    }

    /* Tooltip */
    .tooltip {
      position: relative;
    }

    .tooltip .tooltip-text {
      visibility: hidden;
      width: 120px;
      background-color: rgba(10, 10, 18, 0.9);
      color: var(--text-color);
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.75rem;
      border: 1px solid var(--border-color);
    }

    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    /* Filters */
    .filter-preview {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .filter-option {
      width: 60px;
      height: 60px;
      border-radius: 0.25rem;
      overflow: hidden;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      position: relative;
    }

    .filter-option:hover {
      transform: scale(1.05);
    }

    .filter-option.active {
      border-color: var(--highlight-color);
      box-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
    }

    .filter-option img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .filter-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(10, 10, 18, 0.7);
      color: var(--text-color);
      font-size: 0.6rem;
      text-align: center;
      padding: 2px 0;
    }

    .filter-intensity-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .filter-intensity-label {
      font-size: 0.75rem;
      min-width: 60px;
    }

    /* Animation effects */
    .animation-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3;
    }

    .matrix-rain {
      position: absolute;
      color: #00ff41;
      font-family: monospace;
      font-size: 1.2rem;
      text-shadow: 0 0 5px #00ff41;
      animation: matrixRain 2s linear infinite;
      opacity: 0.7;
    }

    .glitch-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: transparent;
      opacity: 0;
      pointer-events: none;
      z-index: 4;
    }

    .glitch-effect.active {
      animation: flicker 0.3s infinite;
      background-color: rgba(255, 255, 255, 0.05);
    }

    .shake-effect.active {
      animation: shake 0.1s infinite;
    }

    .pulse-effect.active {
      animation: pulse 2s infinite;
    }

    /* Video container */
    .video-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(10, 10, 18, 0.8);
      z-index: 5;
    }

    .video-element {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(10, 10, 18, 0.9);
      color: var(--text-color);
      padding: 10px 20px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      box-shadow: 0 0 10px rgba(137, 255, 241, 0.3);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .toast.show {
      opacity: 1;
    }

    /* Accordion */
    .accordion {
      margin-bottom: 0.5rem;
    }

    .accordion-header {
      padding: 0.5rem;
      background-color: rgba(10, 10, 18, 0.8);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 0.25rem;
      transition: all 0.2s;
    }

    .accordion-header:hover {
      background-color: rgba(137, 255, 241, 0.1);
    }

    .accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
      background-color: rgba(10, 10, 18, 0.5);
      border-left: 1px solid var(--border-color);
      border-right: 1px solid var(--border-color);
      border-bottom: 1px solid var(--border-color);
      border-radius: 0 0 0.25rem 0.25rem;
    }

    .accordion-content-inner {
      padding: 0.5rem;
    }

    .accordion.active .accordion-content {
      max-height: 500px;
    }

    .accordion-icon {
      transition: transform 0.3s;
    }

    .accordion.active .accordion-icon {
      transform: rotate(180deg);
    }
  </style>
</head>
<body>
  <div class="grid-overlay"></div>
  <div class="scanline"></div>
  
  <div class="container" id="container">
    <!-- Preview Area -->
    <div class="preview-area" id="previewArea">
      <canvas id="outputCanvas" class="ascii-output"></canvas>
      <div id="loadingMessage" class="loading-message">Loading image...</div>
      <div id="errorDisplay" class="error-display" style="display: none;">
        <div id="errorText"></div>
        <div class="subtext">Try uploading a different image or refreshing the page.</div>
      </div>
      <div id="animationEffects" class="animation-effect"></div>
    </div>

    <!-- Resizer -->
    <div class="resizer" id="resizer">
      <svg class="icon-grip" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="1"></circle>
        <circle cx="12" cy="5" r="1"></circle>
        <circle cx="12" cy="19" r="1"></circle>
      </svg>
    </div>

    <!-- Control Panel -->
    <div class="control-panel" id="controlPanel">
      <div class="control-panel-inner">
        <div class="form-title">ASCII Studio</div>
        
        <!-- Tabs -->
        <div class="tabs" id="tabs">
          <div class="tab active" data-tab="basic">Basic</div>
          <div class="tab" data-tab="filters">Filters</div>
          <div class="tab" data-tab="animation">Animation</div>
          <div class="tab" data-tab="colors">Colors</div>
          <div class="tab" data-tab="share">Share</div>
        </div>
        
        <!-- Basic Tab -->
        <div class="tab-content active" id="basic-tab">
          <div class="form-group">
            <label class="form-label" for="resolution">Resolution: <span id="resolutionValue">0.11</span></label>
            <div class="slider-container">
              <input type="range" id="resolution" class="slider" min="0.05" max="0.3" step="0.01" value="0.11">
            </div>
          </div>

          <div class="form-group">
            <label class="form-label" for="charSet">Character Set</label>
            <div class="select-container">
              <select id="charSet" class="select">
                <option value="standard">Standard</option>
                <option value="detailed">Detailed</option>
                <option value="blocks">Block Characters</option>
                <option value="minimal">Minimal</option>
                <option value="matrix">Matrix</option>
                <option value="symbols">Cyber Symbols</option>
                <option value="braille">Braille</option>
                <option value="emoji">Emoji</option>
              </select>
              <div class="select-arrow">▼</div>
            </div>
          </div>

          <div class="form-group">
            <div class="switch-container">
              <label class="switch">
                <input type="checkbox" id="inverted">
                <span class="slider-switch"></span>
              </label>
              <span class="form-label">Invert Colors</span>
            </div>
          </div>

          <div class="form-group">
            <div class="switch-container">
              <label class="switch">
                <input type="checkbox" id="grayscale" checked>
                <span class="slider-switch"></span>
              </label>
              <span class="form-label">Grayscale Mode</span>
            </div>
          </div>

          <div class="button-group">
            <button id="copyButton" class="button" disabled>
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
              <span class="button-text">Copy</span>
            </button>
            
            <button id="downloadTextButton" class="button" disabled>
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              <span class="button-text">Text</span>
            </button>
            
            <button id="downloadImageButton" class="button" disabled>
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              <span class="button-text">Image</span>
            </button>
          </div>

          <div class="button-group">
            <button id="uploadButton" class="button">
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
              </svg>
              <span class="button-text">Image</span>
            </button>
            
            <button id="webcamButton" class="button button-webcam">
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                <circle cx="12" cy="13" r="4"></circle>
              </svg>
              <span class="button-text">Webcam</span>
            </button>
            
            <button id="videoButton" class="button">
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
              </svg>
              <span class="button-text">Video</span>
            </button>
          </div>
        </div>
        
        <!-- Filters Tab -->
        <div class="tab-content" id="filters-tab">
          <div class="form-group">
            <label class="form-label">Filter Presets</label>
            <div class="filter-preview" id="filterPreview">
              <div class="filter-option active" data-filter="none">
                <img id="filterNone" src="/placeholder.svg" alt="No Filter">
                <div class="filter-name">None</div>
              </div>
              <div class="filter-option" data-filter="noir">
                <img id="filterNoir" src="/placeholder.svg" alt="Noir">
                <div class="filter-name">Noir</div>
              </div>
              <div class="filter-option" data-filter="cyberpunk">
                <img id="filterCyberpunk" src="/placeholder.svg" alt="Cyberpunk">
                <div class="filter-name">Cyber</div>
              </div>
              <div class="filter-option" data-filter="vintage">
                <img id="filterVintage" src="/placeholder.svg" alt="Vintage">
                <div class="filter-name">Vintage</div>
              </div>
              <div class="filter-option" data-filter="blueprint">
                <img id="filterBlueprint" src="/placeholder.svg" alt="Blueprint">
                <div class="filter-name">Blueprint</div>
              </div>
              <div class="filter-option" data-filter="neon">
                <img id="filterNeon" src="/placeholder.svg" alt="Neon">
                <div class="filter-name">Neon</div>
              </div>
              <div class="filter-option" data-filter="pixel">
                <img id="filterPixel" src="/placeholder.svg" alt="Pixel">
                <div class="filter-name">Pixel</div>
              </div>
              <div class="filter-option" data-filter="glitch">
                <img id="filterGlitch" src="/placeholder.svg" alt="Glitch">
                <div class="filter-name">Glitch</div>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <div class="filter-intensity-container">
              <label class="filter-intensity-label" for="filterIntensity">Intensity: <span id="filterIntensityValue">0.5</span></label>
              <input type="range" id="filterIntensity" class="slider" min="0" max="1" step="0.1" value="0.5">
            </div>
          </div>
          
          <div class="accordion" id="advancedFilters">
            <div class="accordion-header">
              <span>Advanced Adjustments</span>
              <svg class="accordion-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </div>
            <div class="accordion-content">
              <div class="accordion-content-inner">
                <div class="form-group">
                  <div class="filter-intensity-container">
                    <label class="filter-intensity-label" for="brightness">Brightness: <span id="brightnessValue">1.0</span></label>
                    <input type="range" id="brightness" class="slider" min="0" max="2" step="0.1" value="1.0">
                  </div>
                </div>
                <div class="form-group">
                  <div class="filter-intensity-container">
                    <label class="filter-intensity-label" for="contrast">Contrast: <span id="contrastValue">1.0</span></label>
                    <input type="range" id="contrast" class="slider" min="0" max="2" step="0.1" value="1.0">
                  </div>
                </div>
                <div class="form-group">
                  <div class="filter-intensity-container">
                    <label class="filter-intensity-label" for="saturation">Saturation: <span id="saturationValue">1.0</span></label>
                    <input type="range" id="saturation" class="slider" min="0" max="2" step="0.1" value="1.0">
                  </div>
                </div>
                <div class="form-group">
                  <div class="filter-intensity-container">
                    <label class="filter-intensity-label" for="blur">Blur: <span id="blurValue">0</span></label>
                    <input type="range" id="blur" class="slider" min="0" max="10" step="0.5" value="0">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Animation Tab -->
        <div class="tab-content" id="animation-tab">
          <div class="form-group">
            <label class="form-label" for="animationType">Animation Type</label>
            <div class="select-container">
              <select id="animationType" class="select">
                <option value="none">None</option>
                <option value="matrix">Matrix Rain</option>
                <option value="glitch">Glitch Effect</option>
                <option value="pulse">Pulse</option>
                <option value="shake">Shake</option>
                <option value="scan">Scan Lines</option>
              </select>
              <div class="select-arrow">▼</div>
            </div>
          </div>
          
          <div class="form-group">
            <div class="animation-speed-container">
              <label class="animation-speed-label" for="animationSpeed">Speed: <span id="animationSpeedValue">1.0</span></label>
              <input type="range" id="animationSpeed" class="slider" min="0.1" max="3" step="0.1" value="1.0">
            </div>
          </div>
          
          <div class="form-group">
            <div class="switch-container">
              <label class="switch">
                <input type="checkbox" id="animateAscii">
                <span class="slider-switch"></span>
              </label>
              <span class="form-label">Animate ASCII Characters</span>
            </div>
          </div>
          
          <div class="form-group">
            <div class="switch-container">
              <label class="switch">
                <input type="checkbox" id="rainbowMode">
                <span class="slider-switch"></span>
              </label>
              <span class="form-label">Rainbow Color Mode</span>
            </div>
          </div>
          
          <div id="videoPlaybackControls" style="display: none;">
            <div class="form-group">
              <label class="form-label">Video Playback</label>
              <div class="video-controls">
                <button id="playPauseButton" class="button">
                  <svg class="button-icon" id="playIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                  </svg>
                  <svg class="button-icon" id="pauseIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                    <rect x="6" y="4" width="4" height="16"></rect>
                    <rect x="14" y="4" width="4" height="16"></rect>
                  </svg>
                </button>
                <div class="video-progress" id="videoProgress">
                  <div class="video-progress-bar" id="videoProgressBar"></div>
                </div>
                <div class="video-time" id="videoTime">00:00</div>
              </div>
            </div>
            
            <div class="form-group">
              <div class="switch-container">
                <label class="switch">
                  <input type="checkbox" id="loopVideo" checked>
                  <span class="slider-switch"></span>
                </label>
                <span class="form-label">Loop Video</span>
              </div>
            </div>
            
            <div class="form-group">
              <div class="animation-speed-container">
                <label class="animation-speed-label" for="videoFrameRate">Frame Rate: <span id="videoFrameRateValue">15</span> fps</label>
                <input type="range" id="videoFrameRate" class="slider" min="5" max="30" step="1" value="15">
              </div>
            </div>
          </div>
        </div>
        
        <!-- Colors Tab -->
        <div class="tab-content" id="colors-tab">
          <div class="form-group">
            <label class="form-label">Preset Themes</label>
            <div class="color-theme-container">
              <div class="color-theme-option theme-cyberpunk active" data-theme="cyberpunk" title="Cyberpunk"></div>
              <div class="color-theme-option theme-vaporwave" data-theme="vaporwave" title="Vaporwave"></div>
              <div class="color-theme-option theme-matrix" data-theme="matrix" title="Matrix"></div>
              <div class="color-theme-option theme-synthwave" data-theme="synthwave" title="Synthwave"></div>
              <div class="color-theme-option theme-outrun" data-theme="outrun" title="Outrun"></div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Custom Colors</label>
            <div class="color-picker-container">
              <div class="color-picker-row">
                <span class="color-picker-label">Primary Color:</span>
                <input type="color" id="primaryColorPicker" class="color-picker" value="#ff69b4">
              </div>
              <div class="color-picker-row">
                <span class="color-picker-label">Secondary Color:</span>
                <input type="color" id="secondaryColorPicker" class="color-picker" value="#89fff1">
              </div>
              <div class="color-picker-row">
                <span class="color-picker-label">Background Color:</span>
                <input type="color" id="bgColorPicker" class="color-picker" value="#0a0a12">
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <button id="applyCustomColors" class="button">
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="20 6 9 17 4 12"></polyline>
              </svg>
              <span class="button-text">Apply Custom Colors</span>
            </button>
          </div>
          
          <div class="form-group">
            <button id="saveColorTheme" class="button">
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
              </svg>
              <span class="button-text">Save Theme</span>
            </button>
          </div>
        </div>
        
        <!-- Share Tab -->
        <div class="tab-content" id="share-tab">
          <div class="form-group">
            <label class="form-label">Share Your ASCII Art</label>
            <div class="social-share-container">
              <button id="shareTwitter" class="button button-social tooltip">
                <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
                </svg>
                <span class="tooltip-text">Twitter</span>
              </button>
              <button id="shareFacebook" class="button button-social tooltip">
                <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>
                </svg>
                <span class="tooltip-text">Facebook</span>
              </button>
              <button id="shareReddit" class="button button-social tooltip">
                <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10"></circle>
                  <path d="M16.5 7.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"></path>
                  <path d="M8.5 12a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"></path>
                  <path d="M15.5 12a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"></path>
                  <path d="M8.5 16.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"></path>
                  <path d="M15.5 16.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"></path>
                  <path d="M12 16.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"></path>
                </svg>
                <span class="tooltip-text">Reddit</span>
              </button>
              <button id="sharePinterest" class="button button-social tooltip">
                <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M8 12a4 4 0 1 0 8 0 4 4 0 0 0-8 0z"></path>
                  <path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20z"></path>
                  <path d="M12 16v4"></path>
                  <path d="M12 8V4"></path>
                </svg>
                <span class="tooltip-text">Pinterest</span>
              </button>
              <button id="shareEmail" class="button button-social tooltip">
                <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                  <polyline points="22,6 12,13 2,6"></polyline>
                </svg>
                <span class="tooltip-text">Email</span>
              </button>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="shareLink">Direct Link</label>
            <div class="button-group">
              <input type="text" id="shareLink" class="select" readonly value="Generate ASCII art to create a shareable link">
              <button id="copyLinkButton" class="button" style="flex: 0 0 auto;">
                <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
              </button>
            </div>
          </div>
          
          <div class="form-group">
            <button id="generateQRCode" class="button">
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="7" height="7"></rect>
                <rect x="14" y="3" width="7" height="7"></rect>
                <rect x="14" y="14" width="7" height="7"></rect>
                <rect x="3" y="14" width="7" height="7"></rect>
              </svg>
              <span class="button-text">Generate QR Code</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Hidden elements -->
    <canvas id="hiddenCanvas" class="hidden-canvas"></canvas>
    <input type="file" id="fileInput" accept="image/*" style="display: none;">
    <input type="file" id="videoInput" accept="video/*" style="display: none;">
    <div id="toast" class="toast"></div>
  </div>

  <script>
    // State variables
    let resolution = 0.11;
    let inverted = false;
    let grayscale = true;
    let charSet = 'standard';
    let loading = true;
    let imageLoaded = false;
    let asciiArt = '';
    let coloredAsciiArt = [];
    let leftPanelWidth = 25; // percentage
    let isDragging = false;
    let isDraggingFile = false;
    let error = null;
    let isDesktop = window.innerWidth >= 768;
    let sidebarNarrow = false;
    let currentImage = null;
    let webcamActive = false;
    let webcamStream = null;
    let videoElement = null;
    let currentTheme = 'cyberpunk';
    let currentFilter = 'none';
    let filterIntensity = 0.5;
    let animationType = 'none';
    let animationSpeed = 1.0;
    let animateAscii = false;
    let rainbowMode = false;
    let videoPlaying = false;
    let videoSource = null;
    let videoFrameRate = 15;
    let videoLooping = true;
    let animationFrameId = null;
    let matrixRainDrops = [];
    let customColors = {
      primary: '#ff69b4',
      secondary: '#89fff1',
      background: '#0a0a12'
    };
    let imageFilters = {
      brightness: 1.0,
      contrast: 1.0,
      saturation: 1.0,
      blur: 0
    };

    // Character sets
    const charSets = {
      standard: " .:-=+*#%@",
      detailed: " .,:;i1tfLCG08@",
      blocks: " ░▒▓█",
      minimal: " .:█",
      matrix: " .ƒ1@#$%&",
      symbols: " .:;+=>|?*#%@",
      braille: " ⠀⠁⠂⠃⠄⠅⠆⠇⠈⠉⠊⠋⠌⠍⠎⠏",
      emoji: " 😶😐😑😯😮😲😱"
    };

    // Color themes
    const colorThemes = {
      cyberpunk: {
        primary: '#ff69b4',
        secondary: '#89fff1',
        background: 'linear-gradient(45deg, #0a0a12 0%, #1a0b2e 50%, #0a0a12 100%)'
      },
      vaporwave: {
        primary: '#ff6ad5',
        secondary: '#8c52ff',
        background: 'linear-gradient(45deg, #0b0014 0%, #1b0040 50%, #0b0014 100%)'
      },
      matrix: {
        primary: '#00ff41',
        secondary: '#003b00',
        background: 'linear-gradient(45deg, #000500 0%, #001800 50%, #000500 100%)'
      },
      synthwave: {
        primary: '#fc5c7d',
        secondary: '#6a82fb',
        background: 'linear-gradient(45deg, #0f0720 0%, #1f0f40 50%, #0f0720 100%)'
      },
      outrun: {
        primary: '#f7971e',
        secondary: '#ffd200',
        background: 'linear-gradient(45deg, #16001e 0%, #200030 50%, #16001e 100%)'
      }
    };

    // Image filters
    const imageFilterPresets = {
      none: {
        brightness: 1.0,
        contrast: 1.0,
        saturation: 1.0,
        blur: 0
      },
      noir: {
        brightness: 1.1,
        contrast: 1.5,
        saturation: 0,
        blur: 0
      },
      cyberpunk: {
        brightness: 1.1,
        contrast: 1.3,
        saturation: 1.5,
        blur: 0
      },
      vintage: {
        brightness: 0.9,
        contrast: 0.9,
        saturation: 0.8,
        blur: 1
      },
      blueprint: {
        brightness: 0.8,
        contrast: 1.2,
        saturation: 0.1,
        blur: 0.5
      },
      neon: {
        brightness: 1.2,
        contrast: 1.4,
        saturation: 1.7,
        blur: 1
      },
      pixel: {
        brightness: 1.0,
        contrast: 1.2,
        saturation: 1.1,
        blur: 0
      },
      glitch: {
        brightness: 1.1,
        contrast: 1.5,
        saturation: 1.2,
        blur: 0
      }
    };

    // DOM Elements
    const container = document.getElementById('container');
    const previewArea = document.getElementById('previewArea');
    const controlPanel = document.getElementById('controlPanel');
    const resizer = document.getElementById('resizer');
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const outputCanvas = document.getElementById('outputCanvas');
    const fileInput = document.getElementById('fileInput');
    const videoInput = document.getElementById('videoInput');
    const loadingMessage = document.getElementById('loadingMessage');
    const errorDisplay = document.getElementById('errorDisplay');
    const errorText = document.getElementById('errorText');
    const resolutionSlider = document.getElementById('resolution');
    const resolutionValue = document.getElementById('resolutionValue');
    const charSetSelect = document.getElementById('charSet');
    const invertedCheckbox = document.getElementById('inverted');
    const grayscaleCheckbox = document.getElementById('grayscale');
    const copyButton = document.getElementById('copyButton');
    const downloadTextButton = document.getElementById('downloadTextButton');
    const downloadImageButton = document.getElementById('downloadImageButton');
    const uploadButton = document.getElementById('uploadButton');
    const webcamButton = document.getElementById('webcamButton');
    const videoButton = document.getElementById('videoButton');
    const colorThemeOptions = document.querySelectorAll('.color-theme-option');
    const primaryColorPicker = document.getElementById('primaryColorPicker');
    const secondaryColorPicker = document.getElementById('secondaryColorPicker');
    const bgColorPicker = document.getElementById('bgColorPicker');
    const applyCustomColorsButton = document.getElementById('applyCustomColors');
    const saveColorThemeButton = document.getElementById('saveColorTheme');
    const filterOptions = document.querySelectorAll('.filter-option');
    const filterIntensitySlider = document.getElementById('filterIntensity');
    const filterIntensityValue = document.getElementById('filterIntensityValue');
    const brightnessSlider = document.getElementById('brightness');
    const brightnessValue = document.getElementById('brightnessValue');
    const contrastSlider = document.getElementById('contrast');
    const contrastValue = document.getElementById('contrastValue');
    const saturationSlider = document.getElementById('saturation');
    const saturationValue = document.getElementById('saturationValue');
    const blurSlider = document.getElementById('blur');
    const blurValue = document.getElementById('blurValue');
    const animationTypeSelect = document.getElementById('animationType');
    const animationSpeedSlider = document.getElementById('animationSpeed');
    const animationSpeedValue = document.getElementById('animationSpeedValue');
    const animateAsciiCheckbox = document.getElementById('animateAscii');
    const rainbowModeCheckbox = document.getElementById('rainbowMode');
    const videoPlaybackControls = document.getElementById('videoPlaybackControls');
    const playPauseButton = document.getElementById('playPauseButton');
    const playIcon = document.getElementById('playIcon');
    const pauseIcon = document.getElementById('pauseIcon');
    const videoProgress = document.getElementById('videoProgress');
    const videoProgressBar = document.getElementById('videoProgressBar');
    const videoTime = document.getElementById('videoTime');
    const loopVideoCheckbox = document.getElementById('loopVideo');
    const videoFrameRateSlider = document.getElementById('videoFrameRate');
    const videoFrameRateValue = document.getElementById('videoFrameRateValue');
    const shareTwitterButton = document.getElementById('shareTwitter');
    const shareFacebookButton = document.getElementById('shareFacebook');
    const shareRedditButton = document.getElementById('shareReddit');
    const sharePinterestButton = document.getElementById('sharePinterest');
    const shareEmailButton = document.getElementById('shareEmail');
    const shareLinkInput = document.getElementById('shareLink');
    const copyLinkButton = document.getElementById('copyLinkButton');
    const generateQRCodeButton = document.getElementById('generateQRCode');
    const animationEffects = document.getElementById('animationEffects');
    const toast = document.getElementById('toast');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const advancedFiltersAccordion = document.getElementById('advancedFilters');

    // Initialize
    function init() {
      // Set up event listeners
      window.addEventListener('resize', handleResize);
      resizer.addEventListener('mousedown', startDragging);
      resolutionSlider.addEventListener('input', handleResolutionChange);
      charSetSelect.addEventListener('change', handleCharSetChange);
      invertedCheckbox.addEventListener('change', handleInvertedChange);
      grayscaleCheckbox.addEventListener('change', handleGrayscaleChange);
      copyButton.addEventListener('click', copyAsciiArt);
      downloadTextButton.addEventListener('click', downloadAsciiArt);
      downloadImageButton.addEventListener('click', downloadAsImage);
      uploadButton.addEventListener('click', triggerFileUpload);
      fileInput.addEventListener('change', handleFileInputChange);
      webcamButton.addEventListener('click', toggleWebcam);
      videoButton.addEventListener('click', triggerVideoUpload);
      videoInput.addEventListener('change', handleVideoInputChange);
      
      // Color theme options
      colorThemeOptions.forEach(option => {
        option.addEventListener('click', () => {
          const theme = option.getAttribute('data-theme');
          setColorTheme(theme);
          
          // Update active state
          colorThemeOptions.forEach(opt => opt.classList.remove('active'));
          option.classList.add('active');
        });
      });
      
      // Filter options
      filterOptions.forEach(option => {
        option.addEventListener('click', () => {
          const filter = option.getAttribute('data-filter');
          setImageFilter(filter);
          
          // Update active state
          filterOptions.forEach(opt => opt.classList.remove('active'));
          option.classList.add('active');
        });
      });
      
      // Filter sliders
      filterIntensitySlider.addEventListener('input', handleFilterIntensityChange);
      brightnessSlider.addEventListener('input', handleBrightnessChange);
      contrastSlider.addEventListener('input', handleContrastChange);
      saturationSlider.addEventListener('input', handleSaturationChange);
      blurSlider.addEventListener('input', handleBlurChange);
      
      // Animation controls
      animationTypeSelect.addEventListener('change', handleAnimationTypeChange);
      animationSpeedSlider.addEventListener('input', handleAnimationSpeedChange);
      animateAsciiCheckbox.addEventListener('change', handleAnimateAsciiChange);
      rainbowModeCheckbox.addEventListener('change', handleRainbowModeChange);
      
      // Video controls
      playPauseButton.addEventListener('click', toggleVideoPlayback);
      videoProgress.addEventListener('click', seekVideo);
      loopVideoCheckbox.addEventListener('change', handleLoopVideoChange);
      videoFrameRateSlider.addEventListener('input', handleVideoFrameRateChange);
      
      // Custom colors
      applyCustomColorsButton.addEventListener('click', applyCustomColors);
      saveColorThemeButton.addEventListener('click', saveCustomTheme);
      
      // Share buttons
      shareTwitterButton.addEventListener('click', shareToTwitter);
      shareFacebookButton.addEventListener('click', shareToFacebook);
      shareRedditButton.addEventListener('click', shareToReddit);
      sharePinterestButton.addEventListener('click', shareToPinterest);
      shareEmailButton.addEventListener('click', shareViaEmail);
      copyLinkButton.addEventListener('click', copyShareLink);
      generateQRCodeButton.addEventListener('click', generateQRCode);
      
      // Tabs
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabId = tab.getAttribute('data-tab');
          setActiveTab(tabId);
        });
      });
      
      // Accordion
      advancedFiltersAccordion.addEventListener('click', toggleAccordion);
      
      // Drag and drop
      previewArea.addEventListener('dragover', handleDragOver);
      previewArea.addEventListener('dragleave', handleDragLeave);
      previewArea.addEventListener('drop', handleDrop);

      // Check sidebar width
      checkSidebarWidth();
      
      // Initialize filter previews
      initFilterPreviews();
      
      // Load default image
      loadDefaultImage();
    }

    // Event handlers
    function handleResize() {
      const newIsDesktop = window.innerWidth >= 768;
      
      // Reset panel width if switching between mobile and desktop
      if (newIsDesktop !== isDesktop) {
        isDesktop = newIsDesktop;
        leftPanelWidth = 25; // Reset to default
        updateLayout();
      }
      
      checkSidebarWidth();
    }

    function checkSidebarWidth() {
      if (!isDesktop) return;
      
      const containerWidth = container.clientWidth;
      const sidebarWidth = (leftPanelWidth / 100) * containerWidth;
      sidebarNarrow = sidebarWidth < 350;
      
      // Update button text based on sidebar width
      if (sidebarNarrow) {
        document.querySelectorAll('.button-text').forEach(el => {
          el.style.display = 'none';
        });
        copyButton.textContent = 'Copy';
      } else {
        document.querySelectorAll('.button-text').forEach(el => {
          el.style.display = 'inline';
        });
        copyButton.textContent = 'Copy ASCII';
      }
    }

    function startDragging(e) {
      isDragging = true;
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', stopDragging);
      e.preventDefault();
    }

    function handleMouseMove(e) {
      if (!isDragging) return;
      
      const containerRect = container.getBoundingClientRect();
      const newLeftWidth = ((e.clientX - containerRect.left) / containerRect.width) * 100;
      
      // Limit the minimum width of each panel to 20%
      if (newLeftWidth >= 20 && newLeftWidth <= 80) {
        leftPanelWidth = newLeftWidth;
        updateLayout();
        checkSidebarWidth();
      }
    }

    function stopDragging() {
      isDragging = false;
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', stopDragging);
    }

    function updateLayout() {
      if (!isDesktop) return;
      
      controlPanel.style.width = `${leftPanelWidth}%`;
      previewArea.style.marginLeft = `${leftPanelWidth}%`;
      previewArea.style.width = `${100 - leftPanelWidth}%`;
      resizer.style.left = `${leftPanelWidth}%`;
    }

    function handleResolutionChange() {
      resolution = parseFloat(resolutionSlider.value);
      resolutionValue.textContent = resolution.toFixed(2);
      if (imageLoaded) {
        convertToAscii();
      }
    }

    function handleCharSetChange() {
      charSet = charSetSelect.value;
      if (imageLoaded) {
        convertToAscii();
      }
    }

    function handleInvertedChange() {
      inverted = invertedCheckbox.checked;
      if (imageLoaded) {
        convertToAscii();
      }
    }

    function handleGrayscaleChange() {
      grayscale = grayscaleCheckbox.checked;
      if (imageLoaded) {
        convertToAscii();
      }
    }

    function handleFilterIntensityChange() {
      filterIntensity = parseFloat(filterIntensitySlider.value);
      filterIntensityValue.textContent = filterIntensity.toFixed(1);
      if (imageLoaded) {
        applyImageFilters();
        convertToAscii();
      }
    }

    function handleBrightnessChange() {
      imageFilters.brightness = parseFloat(brightnessSlider.value);
      brightnessValue.textContent = imageFilters.brightness.toFixed(1);
      if (imageLoaded) {
        applyImageFilters();
        convertToAscii();
      }
    }

    function handleContrastChange() {
      imageFilters.contrast = parseFloat(contrastSlider.value);
      contrastValue.textContent = imageFilters.contrast.toFixed(1);
      if (imageLoaded) {
        applyImageFilters();
        convertToAscii();
      }
    }

    function handleSaturationChange() {
      imageFilters.saturation = parseFloat(saturationSlider.value);
      saturationValue.textContent = imageFilters.saturation.toFixed(1);
      if (imageLoaded) {
        applyImageFilters();
        convertToAscii();
      }
    }

    function handleBlurChange() {
      imageFilters.blur = parseFloat(blurSlider.value);
      blurValue.textContent = imageFilters.blur.toFixed(1);
      if (imageLoaded) {
        applyImageFilters();
        convertToAscii();
      }
    }

    function handleAnimationTypeChange() {
      animationType = animationTypeSelect.value;
      updateAnimationEffects();
    }

    function handleAnimationSpeedChange() {
      animationSpeed = parseFloat(animationSpeedSlider.value);
      animationSpeedValue.textContent = animationSpeed.toFixed(1);
      updateAnimationEffects();
    }

    function handleAnimateAsciiChange() {
      animateAscii = animateAsciiCheckbox.checked;
      if (animateAscii) {
        startAsciiAnimation();
      } else {
        stopAsciiAnimation();
      }
    }

    function handleRainbowModeChange() {
      rainbowMode = rainbowModeCheckbox.checked;
      if (imageLoaded) {
        convertToAscii();
      }
    }

    function handleVideoFrameRateChange() {
      videoFrameRate = parseInt(videoFrameRateSlider.value);
      videoFrameRateValue.textContent = videoFrameRate;
    }

    function handleLoopVideoChange() {
      videoLooping = loopVideoCheckbox.checked;
      if (videoElement) {
        videoElement.loop = videoLooping;
      }
    }

    function handleDragOver(e) {
      e.preventDefault();
      isDraggingFile = true;
      showDropZone();
    }

    function handleDragLeave() {
      isDraggingFile = false;
      hideDropZone();
    }

    function handleDrop(e) {
      e.preventDefault();
      isDraggingFile = false;
      hideDropZone();
      
      if (e.dataTransfer.files && e.dataTransfer.files[0]) {
        const file = e.dataTransfer.files[0];
        if (file.type.startsWith('image/')) {
          handleFileUpload(file);
        } else if (file.type.startsWith('video/')) {
          handleVideoUpload(file);
        } else {
          showError('Please upload an image or video file');
        }
      }
    }

    function showDropZone() {
      // Create drop zone if it doesn't exist
      if (!document.getElementById('dropZone')) {
        const dropZone = document.createElement('div');
        dropZone.id = 'dropZone';
        dropZone.className = 'drop-zone';
        dropZone.textContent = 'DROP IMAGE OR VIDEO HERE';
        previewArea.appendChild(dropZone);
      }
    }

    function hideDropZone() {
      const dropZone = document.getElementById('dropZone');
      if (dropZone) {
        dropZone.remove();
      }
    }

    function triggerFileUpload() {
      fileInput.click();
    }

    function triggerVideoUpload() {
      videoInput.click();
    }

    function handleFileInputChange(e) {
      if (e.target.files && e.target.files[0]) {
        handleFileUpload(e.target.files[0]);
      }
    }

    function handleVideoInputChange(e) {
      if (e.target.files && e.target.files[0]) {
        handleVideoUpload(e.target.files[0]);
      }
    }

    function handleFileUpload(file) {
      if (!file.type.startsWith('image/')) {
        showError('Please upload an image file');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        if (e.target?.result) {
          loadImage(e.target.result);
        }
      };
      reader.onerror = () => {
        showError('Failed to read file');
      };
      reader.readAsDataURL(file);
    }

    function handleVideoUpload(file) {
      if (!file.type.startsWith('video/')) {
        showError('Please upload a video file');
        return;
      }
      
      const url = URL.createObjectURL(file);
      setupVideoProcessing(url);
    }

    // Image loading and processing
    function loadDefaultImage() {
      showLoading();
      hideError();
      
      // Default image URL
      const defaultImageUrl = 'https://hebbkx1anhila5yf.public.blob.vercel-storage.com/CleanShot%202025-04-21%20at%2007.18.50%402x-dZYTCjkP7AhQCvCtNcNHt4amOQSwtX.png';
      loadImage(defaultImageUrl);
    }

    function loadImage(src) {
      showLoading();
      hideError();
      imageLoaded = false;
      
      // Stop any video playback
      stopVideoProcessing();
      
      const img = new Image();
      img.crossOrigin = 'anonymous';
      
      img.onload = () => {
        if (img.width === 0 || img.height === 0) {
          showError('Invalid image dimensions');
          hideLoading();
          return;
        }
        
        currentImage = img;
        imageLoaded = true;
        hideLoading();
        
        // Initialize filter previews if this is the first image
        updateFilterPreviews();
        
        // Apply filters and convert to ASCII
        applyImageFilters();
        convertToAscii();
        enableButtons();
        
        // Update share link
        updateShareLink();
      };
      
      img.onerror = () => {
        showError('Failed to load image');
        hideLoading();
      };
      
      img.src = src;
    }

    // UI state functions
    function showLoading() {
      loading = true;
      loadingMessage.style.display = 'block';
      outputCanvas.style.display = 'none';
    }

    function hideLoading() {
      loading = false;
      loadingMessage.style.display = 'none';
      outputCanvas.style.display = 'block';
    }

    function showError(message) {
      error = message;
      errorText.textContent = message;
      errorDisplay.style.display = 'block';
      outputCanvas.style.display = 'none';
    }

    function hideError() {
      error = null;
      errorDisplay.style.display = 'none';
    }

    function enableButtons() {
      copyButton.disabled = false;
      downloadTextButton.disabled = false;
      downloadImageButton.disabled = false;
    }

    function disableButtons() {
      copyButton.disabled = true;
      downloadTextButton.disabled = true;
      downloadImageButton.disabled = true;
    }

    function showToast(message, duration = 3000) {
      toast.textContent = message;
      toast.classList.add('show');
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, duration);
    }

    // Tab functions
    function setActiveTab(tabId) {
      // Update tab buttons
      tabs.forEach(tab => {
        if (tab.getAttribute('data-tab') === tabId) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });
      
      // Update tab content
      tabContents.forEach(content => {
        if (content.id === `${tabId}-tab`) {
          content.classList.add('active');
        } else {
          content.classList.remove('active');
        }
      });
    }

    // Accordion functions
    function toggleAccordion() {
      advancedFiltersAccordion.classList.toggle('active');
    }

    // Filter functions
    function initFilterPreviews() {
      // We'll update these when an image is loaded
      document.querySelectorAll('.filter-option img').forEach(img => {
        img.src = 'data:image/svg+xml;charset=utf-8,%3Csvg xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 viewBox%3D%220 0 1 1%22%3E%3C%2Fsvg%3E';
      });
    }

    function updateFilterPreviews() {
      if (!currentImage) return;
      
      // Create a small version of the image for previews
      const previewCanvas = document.createElement('canvas');
      const previewCtx = previewCanvas.getContext('2d');
      const previewSize = 60;
      
      // Calculate aspect ratio
      const aspectRatio = currentImage.width / currentImage.height;
      let previewWidth, previewHeight;
      
      if (aspectRatio > 1) {
        previewWidth = previewSize;
        previewHeight = previewSize / aspectRatio;
      } else {
        previewHeight = previewSize;
        previewWidth = previewSize * aspectRatio;
      }
      
      previewCanvas.width = previewWidth;
      previewCanvas.height = previewHeight;
      
      // Draw the image
      previewCtx.drawImage(currentImage, 0, 0, previewWidth, previewHeight);
      
      // Create filter previews
      Object.keys(imageFilterPresets).forEach(filterName => {
        const filterImg = document.getElementById(`filter${filterName.charAt(0).toUpperCase() + filterName.slice(1)}`);
        if (!filterImg) return;
        
        const filterCanvas = document.createElement('canvas');
        filterCanvas.width = previewWidth;
        filterCanvas.height = previewHeight;
        const filterCtx = filterCanvas.getContext('2d');
        
        // Apply filter
        filterCtx.drawImage(previewCanvas, 0, 0);
        const imageData = filterCtx.getImageData(0, 0, previewWidth, previewHeight);
        const filterSettings = imageFilterPresets[filterName];
        
        applyFiltersToImageData(imageData, filterSettings, 1.0);
        
        filterCtx.putImageData(imageData, 0, 0);
        filterImg.src = filterCanvas.toDataURL();
      });
    }

    function setImageFilter(filter) {
      currentFilter = filter;
      
      // Update filter sliders
      const filterSettings = imageFilterPresets[filter];
      if (filterSettings) {
        brightnessSlider.value = filterSettings.brightness;
        brightnessValue.textContent = filterSettings.brightness.toFixed(1);
        
        contrastSlider.value = filterSettings.contrast;
        contrastValue.textContent = filterSettings.contrast.toFixed(1);
        
        saturationSlider.value = filterSettings.saturation;
        saturationValue.textContent = filterSettings.saturation.toFixed(1);
        
        blurSlider.value = filterSettings.blur;
        blurValue.textContent = filterSettings.blur.toFixed(1);
        
        // Update image filters object
        imageFilters = { ...filterSettings };
      }
      
      if (imageLoaded) {
        applyImageFilters();
        convertToAscii();
      }
    }

    function applyImageFilters() {
      if (!currentImage) return;
      
      const canvas = hiddenCanvas;
      const ctx = canvas.getContext('2d');
      
      // Set canvas dimensions to match the image
      canvas.width = currentImage.width;
      canvas.height = currentImage.height;
      
      // Draw the original image
      ctx.drawImage(currentImage, 0, 0);
      
      // Get image data
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // Apply filters
      applyFiltersToImageData(imageData, imageFilters, filterIntensity);
      
      // Put the modified image data back
      ctx.putImageData(imageData, 0, 0);
    }

    function applyFiltersToImageData(imageData, filters, intensity) {
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        // Get RGB values
        let r = data[i];
        let g = data[i + 1];
        let b = data[i + 2];
        
        // Convert to HSL for easier manipulation
        const hsl = rgbToHsl(r, g, b);
        let h = hsl[0];
        let s = hsl[1];
        let l = hsl[2];
        
        // Apply brightness
        l *= filters.brightness * intensity + (1 - intensity);
        
        // Apply contrast
        if (filters.contrast !== 1) {
          const contrastFactor = (filters.contrast - 1) * intensity + 1;
          l = (l - 0.5) * contrastFactor + 0.5;
        }
        
        // Apply saturation
        if (filters.saturation !== 1) {
          const saturationFactor = (filters.saturation - 1) * intensity + 1;
          s *= saturationFactor;
        }
        
        // Convert back to RGB
        const rgb = hslToRgb(h, Math.max(0, Math.min(1, s)), Math.max(0, Math.min(1, l)));
        
        // Apply blur in a separate pass if needed
        
        // Update pixel data
        data[i] = rgb[0];
        data[i + 1] = rgb[1];
        data[i + 2] = rgb[2];
      }
      
      // Apply blur if needed (simplified version)
      if (filters.blur > 0) {
        // This is a very simple blur implementation
        // A real implementation would use a proper convolution kernel
        const blurAmount = filters.blur * intensity;
        if (blurAmount > 0) {
          const tempData = new Uint8ClampedArray(data);
          const width = imageData.width;
          const height = imageData.height;
          
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              const pixelIndex = (y * width + x) * 4;
              
              // Simple 3x3 box blur
              for (let c = 0; c < 3; c++) {
                let sum = 0;
                for (let dy = -1; dy <= 1; dy++) {
                  for (let dx = -1; dx <= 1; dx++) {
                    const neighborIndex = ((y + dy) * width + (x + dx)) * 4 + c;
                    sum += tempData[neighborIndex];
                  }
                }
                data[pixelIndex + c] = Math.round(sum / 9);
              }
            }
          }
        }
      }
    }

    // Color conversion utilities
    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      
      if (max === min) {
        h = s = 0; // achromatic
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        
        h /= 6;
      }
      
      return [h, s, l];
    }

    function hslToRgb(h, s, l) {
      let r, g, b;
      
      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // ASCII conversion
    function convertToAscii() {
      try {
        if (!hiddenCanvas) {
          throw new Error('Canvas not available');
        }
        
        const canvas = hiddenCanvas;
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
          throw new Error('Could not get canvas context');
        }
        
        // Get image data
        let imageData;
        try {
          imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        } catch (e) {
          throw new Error('Failed to get image data. This might be a CORS issue.');
        }
        
        const data = imageData.data;
        
        // Choose character set
        const chars = charSets[charSet];
        
        // Calculate dimensions based on resolution
        const width = Math.floor(canvas.width * resolution);
        const height = Math.floor(canvas.height * resolution);
        
        // Calculate aspect ratio correction for monospace font
        const fontAspect = 0.5; // Width/height ratio of monospace font characters
        const widthStep = Math.ceil(canvas.width / width);
        const heightStep = Math.ceil(canvas.height / height / fontAspect);
        
        let result = '';
        const coloredResult = [];
        
        // Process the image
        for (let y = 0; y < canvas.height; y += heightStep) {
          const coloredRow = [];
          
          for (let x = 0; x < canvas.width; x += widthStep) {
            const pos = (y * canvas.width + x) * 4;
            
            const r = data[pos];
            const g = data[pos + 1];
            const b = data[pos + 2];
            
            // Calculate brightness based on grayscale setting
            let brightness;
            if (grayscale) {
              // Standard grayscale calculation
              brightness = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
            } else {
              // Color-aware brightness (perceived luminance)
              brightness = Math.sqrt(
                0.299 * (r / 255) * (r / 255) + 
                0.587 * (g / 255) * (g / 255) + 
                0.114 * (b / 255) * (b / 255)
              );
            }
            
            // Invert if needed
            if (inverted) brightness = 1 - brightness;
            
            // Map brightness to character
            const charIndex = Math.floor(brightness * (chars.length - 1));
            const char = chars[charIndex];
            
            result += char;
            
            // For colored mode, store the character and its color
            if (!grayscale) {
              // Adjust color brightness based on the character density
              const brightnessFactor = (charIndex / (chars.length - 1)) * 1.5 + 0.5;
              const color = adjustColorBrightness(r, g, b, brightnessFactor);
              coloredRow.push({ char, color });
            } else {
              // For grayscale mode with rainbow effect
              let color;
              if (rainbowMode) {
                // Generate rainbow color based on position
                const hue = (x / canvas.width + y / canvas.height) * 360;
                color = `hsl(${hue}, 100%, ${50 + brightness * 30}%)`;
              } else {
                // Use theme colors for grayscale mode
                const theme = colorThemes[currentTheme];
                color = getGradientColor(theme.primary, theme.secondary, brightness);
              }
              coloredRow.push({ char, color });
            }
          }
          
          result += '\n';
          coloredResult.push(coloredRow);
        }
        
        asciiArt = result;
        coloredAsciiArt = coloredResult;
        hideError();
        renderToCanvas();
      } catch (err) {
        console.error('Error converting to ASCII:', err);
        showError(err instanceof Error ? err.message : 'Unknown error occurred');
        asciiArt = '';
        coloredAsciiArt = [];
        disableButtons();
      }
    }

    // Helper function to adjust color brightness
    function adjustColorBrightness(r, g, b, factor) {
      // Ensure the colors are visible against black background
      const minBrightness = 40; // Minimum brightness to ensure visibility
      r = Math.max(Math.min(Math.round(r * factor), 255), minBrightness);
      g = Math.max(Math.min(Math.round(g * factor), 255), minBrightness);
      b = Math.max(Math.min(Math.round(b * factor), 255), minBrightness);
      return `rgb(${r}, ${g}, ${b})`;
    }

    // Helper function to get gradient color
    function getGradientColor(color1, color2, ratio) {
      // Convert hex to RGB
      const parseColor = (hexStr) => {
        if (hexStr.startsWith('#')) {
          const r = parseInt(hexStr.slice(1, 3), 16);
          const g = parseInt(hexStr.slice(3, 5), 16);
          const b = parseInt(hexStr.slice(5, 7), 16);
          return [r, g, b];
        }
        return [255, 255, 255]; // Default to white
      };
      
      const c1 = parseColor(color1);
      const c2 = parseColor(color2);
      
      const r = Math.round(c1[0] * (1 - ratio) + c2[0] * ratio);
      const g = Math.round(c1[1] * (1 - ratio) + c2[1] * ratio);
      const b = Math.round(c1[2] * (1 - ratio) + c2[2] * ratio);
      
      return `rgb(${r}, ${g}, ${b})`;
    }

    // Render ASCII art to canvas
    function renderToCanvas() {
      if (!outputCanvas || !asciiArt || coloredAsciiArt.length === 0) return;
      
      const ctx = outputCanvas.getContext('2d');
      if (!ctx) return;
      
      // Clear the canvas
      ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
      
      // Set font properties to match the DOM rendering
      const fontSize = 8; // Base font size in pixels
      ctx.font = `${fontSize}px monospace`;
      ctx.textBaseline = 'top';
      
      // Calculate dimensions
      const lineHeight = fontSize;
      const charWidth = fontSize * 0.6; // Approximate width of monospace character
      
      // Resize canvas to fit the ASCII art
      const lines = asciiArt.split('\n');
      const maxLineLength = Math.max(...lines.map(line => line.length));
      outputCanvas.width = maxLineLength * charWidth;
      outputCanvas.height = lines.length * lineHeight;
      
      // Re-apply font after canvas resize
      ctx.font = `${fontSize}px monospace`;
      ctx.textBaseline = 'top';
      
      // Add a background
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
      
      // Render the ASCII art
      coloredAsciiArt.forEach((row, rowIndex) => {
        row.forEach((col, colIndex) => {
          ctx.fillStyle = col.color;
          
          // Add glow effect
          ctx.shadowColor = col.color;
          ctx.shadowBlur = 2;
          
          ctx.fillText(col.char, colIndex * charWidth, rowIndex * lineHeight);
          
          // Reset shadow
          ctx.shadowBlur = 0;
        });
      });
    }

    // Animation effects
    function updateAnimationEffects() {
      // Clear existing animation effects
      animationEffects.innerHTML = '';
      
      // Remove all effect classes
      animationEffects.classList.remove('glitch-effect', 'shake-effect', 'pulse-effect');
      
      // Apply the selected animation effect
      switch (animationType) {
        case 'matrix':
          createMatrixRainEffect();
          break;
        case 'glitch':
          animationEffects.classList.add('glitch-effect', 'active');
          break;
        case 'pulse':
          animationEffects.classList.add('pulse-effect', 'active');
          break;
        case 'shake':
          animationEffects.classList.add('shake-effect', 'active');
          break;
        case 'scan':
          createScanLineEffect();
          break;
        case 'none':
        default:
          // No effect
          break;
      }
    }

    function createMatrixRainEffect() {
      // Clear existing drops
      matrixRainDrops = [];
      animationEffects.innerHTML = '';
      
      // Create matrix rain drops
      const numDrops = 50;
      const containerWidth = previewArea.clientWidth;
      const containerHeight = previewArea.clientHeight;
      
      for (let i = 0; i < numDrops; i++) {
        const drop = document.createElement('div');
        drop.className = 'matrix-rain';
        drop.textContent = getRandomMatrixChar();
        drop.style.left = `${Math.random() * containerWidth}px`;
        drop.style.top = `${Math.random() * containerHeight}px`;
        drop.style.animationDuration = `${(Math.random() * 2 + 1) / animationSpeed}s`;
        drop.style.opacity = `${Math.random() * 0.5 + 0.3}`;
        animationEffects.appendChild(drop);
        
        matrixRainDrops.push(drop);
      }
      
      // Start animation loop to continuously update characters
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      const updateMatrixChars = () => {
        matrixRainDrops.forEach(drop => {
          if (Math.random() > 0.9) {
            drop.textContent = getRandomMatrixChar();
          }
        });
        
        animationFrameId = requestAnimationFrame(updateMatrixChars);
      };
      
      updateMatrixChars();
    }

    function getRandomMatrixChar() {
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$+-*/=%\"'#&_(),.;:?!\\|{}<>[]^~";
      return chars.charAt(Math.floor(Math.random() * chars.length));
    }

    function createScanLineEffect() {
      const scanLine = document.createElement('div');
      scanLine.style.position = 'absolute';
      scanLine.style.left = '0';
      scanLine.style.width = '100%';
      scanLine.style.height = '2px';
      scanLine.style.background = 'rgba(137, 255, 241, 0.5)';
      scanLine.style.boxShadow = '0 0 10px rgba(137, 255, 241, 0.7)';
      scanLine.style.zIndex = '5';
      scanLine.style.pointerEvents = 'none';
      
      animationEffects.appendChild(scanLine);
      
      // Start animation loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      let position = 0;
      const speed = 2 * animationSpeed;
      const height = previewArea.clientHeight;
      
      const updateScanLine = () => {
        position = (position + speed) % (height * 2);
        const y = position < height ? position : height * 2 - position;
        scanLine.style.top = `${y}px`;
        
        animationFrameId = requestAnimationFrame(updateScanLine);
      };
      
      updateScanLine();
    }

    function startAsciiAnimation() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      let frame = 0;
      const animateAscii = () => {
        frame++;
        
        // Modify ASCII characters slightly each frame
        if (coloredAsciiArt.length > 0) {
          const ctx = outputCanvas.getContext('2d');
          if (ctx) {
            // Redraw with slight modifications
            coloredAsciiArt.forEach((row, rowIndex) => {
              row.forEach((col, colIndex) => {
                if (Math.random() > 0.99) {
                  // Randomly change some characters
                  const chars = charSets[charSet];
                  const randomChar = chars.charAt(Math.floor(Math.random() * chars.length));
                  coloredAsciiArt[rowIndex][colIndex].char = randomChar;
                }
                
                if (rainbowMode) {
                  // Animate colors in rainbow mode
                  const hue = (colIndex / row.length + rowIndex / coloredAsciiArt.length + frame * 0.01) * 360 % 360;
                  coloredAsciiArt[rowIndex][colIndex].color = `hsl(${hue}, 100%, 70%)`;
                }
              });
            });
            
            renderToCanvas();
          }
        }
        
        animationFrameId = requestAnimationFrame(animateAscii);
      };
      
      animateAscii();
    }

    function stopAsciiAnimation() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Restore original ASCII art
      if (imageLoaded) {
        convertToAscii();
      }
    }

    // Video processing
    function setupVideoProcessing(videoUrl) {
      // Stop any existing video
      stopVideoProcessing();
      
      // Create video element
      const video = document.createElement('video');
      video.src = videoUrl;
      video.crossOrigin = 'anonymous';
      video.muted = true;
      video.loop = videoLooping;
      
      // Create video container
      const videoContainer = document.createElement('div');
      videoContainer.className = 'video-container';
      videoContainer.id = 'videoContainer';
      
      // Add video to container
      videoContainer.appendChild(video);
      
      // Add to preview area
      previewArea.appendChild(videoContainer);
      
      // Set up video events
      video.addEventListener('loadedmetadata', () => {
        videoElement = video;
        videoSource = videoUrl;
        
        // Show video controls
        videoPlaybackControls.style.display = 'block';
        
        // Update video time display
        updateVideoTimeDisplay();
        
        // Start video processing
        startVideoProcessing();
      });
      
      video.addEventListener('error', () => {
        showError('Failed to load video');
        stopVideoProcessing();
      });
      
      // Load the video
      video.load();
    }

    function startVideoProcessing() {
      if (!videoElement) return;
      
      // Play the video
      videoElement.play()
        .then(() => {
          videoPlaying = true;
          updatePlayPauseButton();
          
          // Start processing frames
          processVideoFrames();
        })
        .catch(error => {
          console.error('Error playing video:', error);
          showError('Failed to play video. Check autoplay permissions.');
        });
    }

    function stopVideoProcessing() {
      if (videoElement) {
        videoElement.pause();
        videoElement.src = '';
        videoElement = null;
      }
      
      const videoContainer = document.getElementById('videoContainer');
      if (videoContainer) {
        videoContainer.remove();
      }
      
      videoPlaying = false;
      videoSource = null;
      videoPlaybackControls.style.display = 'none';
      updatePlayPauseButton();
      
      // Cancel any pending animation frames
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    function processVideoFrames() {
      if (!videoElement || !videoPlaying) return;
      
      // Process current frame
      const canvas = hiddenCanvas;
      const ctx = canvas.getContext('2d');
      
      if (ctx) {
        // Set canvas dimensions to match the video
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        
        // Draw the current video frame
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        
        // Apply filters
        applyImageFilters();
        
        // Convert to ASCII
        convertToAscii();
        
        // Update video progress
        updateVideoProgress();
      }
      
      // Schedule next frame
      setTimeout(() => {
        if (videoPlaying) {
          animationFrameId = requestAnimationFrame(processVideoFrames);
        }
      }, 1000 / videoFrameRate);
    }

    function toggleVideoPlayback() {
      if (!videoElement) return;
      
      if (videoPlaying) {
        videoElement.pause();
        videoPlaying = false;
      } else {
        videoElement.play();
        videoPlaying = true;
        processVideoFrames();
      }
      
      updatePlayPauseButton();
    }

    function updatePlayPauseButton() {
      if (videoPlaying) {
        playIcon.style.display = 'none';
        pauseIcon.style.display = 'block';
      } else {
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
      }
    }

    function updateVideoProgress() {
      if (!videoElement) return;
      
      const progress = videoElement.currentTime / videoElement.duration;
      videoProgressBar.style.width = `${progress * 100}%`;
      
      updateVideoTimeDisplay();
    }

    function updateVideoTimeDisplay() {
      if (!videoElement) return;
      
      const currentTime = formatTime(videoElement.currentTime);
      const duration = formatTime(videoElement.duration);
      videoTime.textContent = `${currentTime}/${duration}`;
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function seekVideo(e) {
      if (!videoElement) return;
      
      const rect = videoProgress.getBoundingClientRect();
      const pos = (e.clientX - rect.left) / rect.width;
      
      videoElement.currentTime = pos * videoElement.duration;
      updateVideoProgress();
    }

    // Button actions
    function copyAsciiArt() {
      if (!asciiArt) {
        showError('No ASCII art to copy');
        return;
      }
      
      // Create a temporary textarea element to copy the text
      const el = document.createElement('textarea');
      el.value = asciiArt;
      document.body.appendChild(el);
      el.select();
      document.execCommand('copy');
      document.body.removeChild(el);
      
      showToast('ASCII art copied to clipboard!');
    }

    function downloadAsciiArt() {
      if (!asciiArt) {
        showError('No ASCII art to download');
        return;
      }
      
      const element = document.createElement('a');
      const file = new Blob([asciiArt], { type: 'text/plain' });
      element.href = URL.createObjectURL(file);
      element.download = 'ascii-art.txt';
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }

    function downloadAsImage() {
      if (!outputCanvas) {
        showError('No ASCII art to download');
        return;
      }
      
      // Create a new canvas with padding and background
      const padding = 20;
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = outputCanvas.width + padding * 2;
      exportCanvas.height = outputCanvas.height + padding * 2;
      
      const ctx = exportCanvas.getContext('2d');
      if (!ctx) return;
      
      // Draw background
      const theme = colorThemes[currentTheme];
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
      
      // Draw grid lines
      ctx.strokeStyle = 'rgba(137, 255, 241, 0.1)';
      ctx.lineWidth = 0.5;
      
      const gridSize = 10;
      for (let x = 0; x <= exportCanvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, exportCanvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y <= exportCanvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(exportCanvas.width, y);
        ctx.stroke();
      }
      
      // Draw the ASCII art canvas
      ctx.drawImage(outputCanvas, padding, padding);
      
      // Add a subtle border glow
      ctx.strokeStyle = theme.primary;
      ctx.lineWidth = 2;
      ctx.shadowColor = theme.primary;
      ctx.shadowBlur = 10;
      ctx.strokeRect(padding - 5, padding - 5, outputCanvas.width + 10, outputCanvas.height + 10);
      
      // Add a small watermark
      ctx.font = '10px monospace';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.fillText('ASCII Studio', exportCanvas.width - 80, exportCanvas.height - 10);
      
      // Convert to image and download
      const dataUrl = exportCanvas.toDataURL('image/png');
      const element = document.createElement('a');
      element.href = dataUrl;
      element.download = 'ascii-art.png';
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }

    // Webcam functions
    function toggleWebcam() {
      if (webcamActive) {
        stopWebcam();
      } else {
        startWebcam();
      }
    }

    function startWebcam() {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({ video: true })
          .then(stream => {
            webcamStream = stream;
            webcamActive = true;
            
            // Create webcam container
            const webcamContainer = document.createElement('div');
            webcamContainer.className = 'webcam-container';
            webcamContainer.id = 'webcamContainer';
            
            // Create video element
            videoElement = document.createElement('video');
            videoElement.className = 'webcam-video';
            videoElement.autoplay = true;
            videoElement.srcObject = stream;
            webcamContainer.appendChild(videoElement);
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'webcam-overlay';
            webcamContainer.appendChild(overlay);
            
            // Create controls
            const controls = document.createElement('div');
            controls.className = 'webcam-controls';
            
            const captureButton = document.createElement('button');
            captureButton.className = 'button button-capture';
            captureButton.innerHTML = `
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="3"></circle>
              </svg>
              <span>Capture</span>
            `;
            captureButton.addEventListener('click', captureWebcam);
            controls.appendChild(captureButton);
            
            const closeButton = document.createElement('button');
            closeButton.className = 'button';
            closeButton.innerHTML = `
              <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
              <span>Close</span>
            `;
            closeButton.addEventListener('click', stopWebcam);
            controls.appendChild(closeButton);
            
            webcamContainer.appendChild(controls);
            
            // Add to preview area
            previewArea.appendChild(webcamContainer);
            
            // Update button state
            webcamButton.classList.add('active');
          })
          .catch(error => {
            console.error('Error accessing webcam:', error);
            showError('Could not access webcam. Please check permissions.');
            webcamActive = false;
          });
      } else {
        showError('Your browser does not support webcam access');
      }
    }

    function stopWebcam() {
      if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
        webcamStream = null;
      }
      
      if (videoElement) {
        videoElement.srcObject = null;
        videoElement = null;
      }
      
      const webcamContainer = document.getElementById('webcamContainer');
      if (webcamContainer) {
        webcamContainer.remove();
      }
      
      webcamActive = false;
      webcamButton.classList.remove('active');
    }

    function captureWebcam() {
      if (!videoElement || !webcamActive) return;
      
      // Create a temporary canvas to capture the frame
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = videoElement.videoWidth;
      tempCanvas.height = videoElement.videoHeight;
      
      const ctx = tempCanvas.getContext('2d');
      if (!ctx) return;
      
      // Draw the current video frame
      ctx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);
      
      // Convert to image and process
      try {
        const imageDataUrl = tempCanvas.toDataURL('image/png');
        loadImage(imageDataUrl);
        stopWebcam();
      } catch (error) {
        console.error('Error capturing webcam:', error);
        showError('Failed to capture image from webcam');
      }
    }

    // Theme functions
    function setColorTheme(theme) {
      if (!colorThemes[theme]) return;
      
      currentTheme = theme;
      const themeColors = colorThemes[theme];
      
      // Update custom color pickers
      primaryColorPicker.value = themeColors.primary;
      secondaryColorPicker.value = themeColors.secondary;
      bgColorPicker.value = customColors.background; // Keep current background
      
      // Update custom colors object
      customColors.primary = themeColors.primary;
      customColors.secondary = themeColors.secondary;
      
      // Update CSS variables
      document.documentElement.style.setProperty('--primary-color', customColors.primary);
      document.documentElement.style.setProperty('--secondary-color', customColors.secondary);
      document.documentElement.style.setProperty('--highlight-color', customColors.primary);
      document.documentElement.style.setProperty('--border-color', `rgba(${hexToRgb(customColors.secondary)}, 0.5)`);
      document.documentElement.style.setProperty('--bg-color', customColors.background);
      
      // Create custom background gradient
      const bgGradient = `linear-gradient(45deg, ${customColors.background} 0%, ${adjustColorBrightness(hexToRgb(customColors.background).split(', ')[0], hexToRgb(customColors.background).split(', ')[1], hexToRgb(customColors.background).split(', ')[2], 1.5)} 50%, ${customColors.background} 100%)`;
      document.documentElement.style.setProperty('--bg-gradient', bgGradient);
      
      // Update before pseudo-element
      const styleSheet = document.styleSheets[0];
      for (let i = 0; i < styleSheet.cssRules.length; i++) {
        const rule = styleSheet.cssRules[i];
        if (rule.selectorText === 'body::before') {
          rule.style.background = bgGradient;
          break;
        }
      }
      
      // Re-render ASCII art with new colors if available
      if (imageLoaded && !loading) {
        convertToAscii();
      }
      
      showToast('Custom colors applied');
    }

    function saveCustomTheme() {
      // Create a new theme option
      const customThemeName = 'custom' + Math.floor(Math.random() * 1000);
      
      // Add to color themes object
      colorThemes[customThemeName] = {
        primary: customColors.primary,
        secondary: customColors.secondary,
        background: `linear-gradient(45deg, ${customColors.background} 0%, ${adjustColorBrightness(hexToRgb(customColors.background).split(', ')[0], hexToRgb(customColors.background).split(', ')[1], hexToRgb(customColors.background).split(', ')[2], 1.5)} 50%, ${customColors.background} 100%)`
      };
      
      // Create a new theme option element
      const themeContainer = document.querySelector('.color-theme-container');
      const newThemeOption = document.createElement('div');
      newThemeOption.className = 'color-theme-option';
      newThemeOption.setAttribute('data-theme', customThemeName);
      newThemeOption.title = 'Custom Theme';
      newThemeOption.style.background = `linear-gradient(45deg, ${customColors.primary}, ${customColors.secondary})`;
      
      // Add event listener
      newThemeOption.addEventListener('click', () => {
        setColorTheme(customThemeName);
        
        // Update active state
        colorThemeOptions.forEach(opt => opt.classList.remove('active'));
        newThemeOption.classList.add('active');
      });
      
      // Add to container
      themeContainer.appendChild(newThemeOption);
      
      showToast('Custom theme saved');
    }

    // Social sharing functions
    function shareToTwitter() {
      if (!imageLoaded) {
        showToast('Generate ASCII art first');
        return;
      }
      
      const text = 'Check out this ASCII art I created!';
      const url = window.location.href;
      const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
      
      window.open(twitterUrl, '_blank');
    }

    function shareToFacebook() {
      if (!imageLoaded) {
        showToast('Generate ASCII art first');
        return;
      }
      
      const url = window.location.href;
      const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`;
      
      window.open(facebookUrl, '_blank');
    }

    function shareToReddit() {
      if (!imageLoaded) {
        showToast('Generate ASCII art first');
        return;
      }
      
      const title = 'ASCII Art Creation';
      const url = window.location.href;
      const redditUrl = `https://www.reddit.com/submit?title=${encodeURIComponent(title)}&url=${encodeURIComponent(url)}`;
      
      window.open(redditUrl, '_blank');
    }

    function shareToPinterest() {
      if (!imageLoaded) {
        showToast('Generate ASCII art first');
        return;
      }
      
      // For Pinterest, we need an image URL
      // We'll use the canvas to create a data URL
      const imageUrl = outputCanvas.toDataURL('image/png');
      const description = 'ASCII Art Creation';
      const url = window.location.href;
      const pinterestUrl = `https://pinterest.com/pin/create/button/?url=${encodeURIComponent(url)}&media=${encodeURIComponent(imageUrl)}&description=${encodeURIComponent(description)}`;
      
      window.open(pinterestUrl, '_blank');
    }

    function shareViaEmail() {
      if (!imageLoaded) {
        showToast('Generate ASCII art first');
        return;
      }
      
      const subject = 'Check out this ASCII art';
      const body = `I created this ASCII art using the ASCII Studio tool.\n\nCheck it out at: ${window.location.href}`;
      const mailtoUrl = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      
      window.location.href = mailtoUrl;
    }

    function updateShareLink() {
      if (!imageLoaded) {
        shareLinkInput.value = 'Generate ASCII art to create a shareable link';
        return;
      }
      
      // Create a simple share link with current settings
      const params = new URLSearchParams();
      params.set('resolution', resolution);
      params.set('charSet', charSet);
      params.set('inverted', inverted);
      params.set('grayscale', grayscale);
      params.set('theme', currentTheme);
      
      const shareUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
      shareLinkInput.value = shareUrl;
    }

    function copyShareLink() {
      if (!imageLoaded) {
        showToast('Generate ASCII art first');
        return;
      }
      
      shareLinkInput.select();
      document.execCommand('copy');
      
      showToast('Share link copied to clipboard');
    }

    function generateQRCode() {
      if (!imageLoaded) {
        showToast('Generate ASCII art first');
        return;
      }
      
      // Simple QR code generation using an external service
      const shareUrl = shareLinkInput.value;
      const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(shareUrl)}`;
      
      // Open QR code in new window
      window.open(qrCodeUrl, '_blank');
    }

    // Initialize the application
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>