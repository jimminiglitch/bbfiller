<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SonicWave Music Player</title>
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    /* Base Styles */
    body {
      background: #000;
      color: #0ff;
      font-family: "VT323", monospace;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      min-height: 100vh;
    }

    /* CRT Effects */
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.3) 50%);
      background-size: 100% 4px;
      opacity: 0.15;
      pointer-events: none;
      z-index: 999;
    }

    .crt-effect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      box-shadow: inset 0 0 100px rgba(0, 255, 255, 0.2);
      pointer-events: none;
      z-index: 1000;
    }

    /* Layout */
    .music-content {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding: 1rem;
      box-sizing: border-box;
      max-width: 1200px;
      margin: 0 auto;
    }

    .player-header {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .player-title {
      font-family: "Press Start 2P", monospace;
      font-size: 1.8rem;
      color: #0ff;
      margin: 0;
    }

    .player-title span {
      color: #f0f;
    }

    .player-container {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      flex: 1;
    }

    @media (min-width: 992px) {
      .player-container {
        flex-direction: row;
      }

      .visualizer-section {
        flex: 2;
      }

      .playlist-section {
        flex: 1;
        max-width: 350px;
      }
    }

    /* Visualizer */
    #visualizer-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: #000;
      border: 2px solid #0ff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    #visualizer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Track Info */
    .track-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 1rem;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .track-info-icon {
      width: 2.5rem;
      height: 2.5rem;
      background: #f0f;
      color: #000;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      font-weight: bold;
    }

    .track-info-text {
      flex: 1;
    }

    #now-playing {
      font-family: "Press Start 2P", monospace;
      color: #fff;
      font-size: 1rem;
      margin-bottom: 0.25rem;
    }

    #track-artist {
      color: #0ff;
      font-size: 0.9rem;
    }

    /* Progress Bar */
    .track-time {
      display: flex;
      justify-content: space-between;
      color: #0ff;
      font-size: 0.9rem;
      margin: 0.5rem 0;
    }

    .progress-container {
      position: relative;
      width: 100%;
      height: 8px;
      background: #111;
      border: 1px solid #0ff;
      border-radius: 4px;
      margin-bottom: 1rem;
      cursor: pointer;
      overflow: hidden;
    }

    .progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: linear-gradient(to right, #0ff, #f0f);
      width: 0;
      border-radius: 4px;
      transition: width 0.1s ease;
    }

    /* Controls */
    .controls-row {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    @media (min-width: 768px) {
      .controls-row {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
    }

    .music-controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .control-button {
      font-family: "Press Start 2P", monospace;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #0ff;
      color: #0ff;
      border-radius: 4px;
      padding: 0.4rem 0.8rem;
      text-shadow: 0 0 3px #0ff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.7rem;
    }

    .control-button:hover {
      background: #0ff;
      color: #000;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
    }

    .control-button-play {
      font-size: 0.8rem;
      padding: 0.5rem 1rem;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #f0f;
      color: #f0f;
      text-shadow: 0 0 3px #f0f;
      box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
    }

    .control-button-play:hover {
      background: #f0f;
      color: #000;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
    }

    .volume-control {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    #volume-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100px;
      height: 8px;
      background: #111;
      border: 1px solid #0ff;
      border-radius: 4px;
      outline: none;
    }

    #volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #0ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
    }

    #volume-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #0ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
      border: none;
    }

    /* Visualizer Modes */
    #visualizer-modes {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .mode-button {
      font-family: "Press Start 2P", monospace;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #0ff;
      color: #0ff;
      border-radius: 4px;
      padding: 0.3rem 0.6rem;
      font-size: 0.6rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mode-button:hover {
      background: rgba(0, 255, 255, 0.2);
    }

    .mode-button.active {
      background: linear-gradient(to right, #0ff, #f0f);
      color: #000;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
    }

    /* Playlist */
    .playlist-section {
      border: 2px solid #0ff;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .playlist-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem;
      border-bottom: 1px solid #0ff;
      background: rgba(0, 0, 0, 0.8);
    }

    .playlist-header h2 {
      font-family: "Press Start 2P", monospace;
      color: #0ff;
      font-size: 1rem;
      margin: 0;
    }

    #track-count {
      color: #0ff;
      font-size: 0.8rem;
    }

    #playlist {
      list-style: none;
      padding: 0;
      margin: 0;
      overflow-y: auto;
      flex-grow: 1;
      max-height: 400px;
    }

    #playlist li {
      padding: 0.75rem;
      border-bottom: 1px solid #333;
      transition: background 0.2s, color 0.2s;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    #playlist li:hover {
      background: rgba(0, 255, 255, 0.1);
    }

    #playlist li.playing {
      background: linear-gradient(to right, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.2));
      border-left: 4px solid #f0f;
    }

    .track-number {
      width: 24px;
      height: 24px;
      background: #0ff;
      color: #000;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: bold;
    }

    .playing .track-number {
      background: #f0f;
    }

    .track-details {
      flex: 1;
    }

    .track-title {
      color: #fff;
      font-size: 1rem;
      margin-bottom: 0.25rem;
    }

    .track-artist-name {
      color: #0ff;
      font-size: 0.8rem;
    }

    /* Responsive Adjustments */
    .mobile-only {
      display: none;
    }

    @media (max-width: 991px) {
      .mobile-only {
        display: block;
      }

      .playlist-section {
        display: none;
      }

      .playlist-section.active {
        display: flex;
      }
    }

    @media (max-width: 768px) {
      .player-title {
        font-size: 1.5rem;
      }

      .control-button {
        padding: 0.3rem 0.6rem;
        font-size: 0.6rem;
      }

      .control-button-play {
        padding: 0.4rem 0.8rem;
        font-size: 0.7rem;
      }

      .mode-button {
        padding: 0.25rem 0.5rem;
        font-size: 0.5rem;
      }

      #now-playing {
        font-size: 0.8rem;
      }

      .track-info-icon {
        width: 2rem;
        height: 2rem;
        font-size: 1rem;
      }
    }

    @media (max-width: 480px) {
      .music-content {
        padding: 0.5rem;
      }

      .player-title {
        font-size: 1.2rem;
      }

      #visualizer-modes {
        gap: 0.25rem;
      }

      .mode-button {
        padding: 0.2rem 0.4rem;
        font-size: 0.45rem;
      }
    }
  </style>
</head>
<body>
  <div class="scanlines"></div>
  <div class="crt-effect"></div>

  <div class="music-content">
    <header class="player-header">
      <h1 class="player-title">SONIC<span>WAVE</span></h1>
    </header>

    <div class="player-container">
      <div class="visualizer-section">
        <div id="visualizer-container">
          <canvas id="visualizer"></canvas>
          
          <div class="track-info">
            <div class="track-info-icon">▶</div>
            <div class="track-info-text">
              <div id="now-playing">Select a track</div>
              <div id="track-artist"></div>
            </div>
          </div>
        </div>

        <div class="track-time">
          <span id="current-time">0:00</span>
          <span id="total-time">0:00</span>
        </div>

        <div class="progress-container" id="progress-container">
          <div class="progress-bar" id="progress-bar"></div>
        </div>

        <div class="controls-row">
          <div class="music-controls">
            <button id="prevTrack" class="control-button">◀ PREV</button>
            <button id="togglePlay" class="control-button control-button-play">▶ PLAY</button>
            <button id="nextTrack" class="control-button">NEXT ▶</button>
            <button id="togglePlaylist" class="control-button mobile-only">PLAYLIST</button>
          </div>

          <div class="volume-control">
            <button id="toggleMute" class="control-button">🔊</button>
            <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.7">
          </div>
        </div>

        <div id="visualizer-modes">
          <button class="mode-button active" data-mode="bars">BARS</button>
          <button class="mode-button" data-mode="wave">WAVE</button>
          <button class="mode-button" data-mode="circle">CIRCLE</button>
        </div>
      </div>

      <div class="playlist-section" id="playlist-section">
        <div class="playlist-header">
          <h2>PLAYLIST</h2>
          <span id="track-count">0 tracks</span>
        </div>
        <ul id="playlist"></ul>
      </div>
    </div>

    <!-- crossOrigin needed for Web Audio API -->
    <audio id="music-player" preload="auto" crossOrigin="anonymous"></audio>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      console.log("🎵 SonicWave Music Player initializing...");

      // Define tracks with artist information
      const tracks = [
        {
          title: "Paper Doll (LIVE)",
          artist: "Dead Beast",
          src: "https://cdn.glitch.global/09e9ba26-fd4e-41f2-88c1-651c3d32a01a/Paper%20Doll%20(LIVE).mp3?v=1746751595622",
        },
        {
          title: "Hard Thing",
          artist: "Dead Beast",
          src: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/Dead%20Beast%20-%20Hard%20Thing.mp3?v=1746889492826",
        },
        {
          title: "Monsters",
          artist: "Dead Beast",
          src: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/Dead%20Beast%20-%20Monsters%20in%20the%20CiA.mp3?v=1746889496155",
        },
        {
          title: "F*ck",
          artist: "Dead Beast",
          src: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/Dead%20Beast%20-%20Fuck.mp3?v=1746889506198",
        },
        {
          title: "Manameisdrnk",
          artist: "Dead Beast",
          src: "https://cdn.glitch.me/09e9ba26-fd4e-41f2-88c1-651c3d32a01a/mynameisdrunk.wav?v=1746751634863",
        },
        {
          title: "L1k32D13",
          artist: "Dread Wingz",
          src: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/Dread%20Wingz%20-%20Like2Die.mp3?v=1746889500203",
        },
        {
          title: "M@k1n B@k1n",
          artist: "Dread Wingz",
          src: "https://cdn.glitch.global/25331b85-e206-4347-93a8-666983818ff8/Dread%20Wingz%20-%20Makin%20Bacon.mp3?v=1746889503112",
        },
      ];

      // Safely get DOM elements with error handling
      function getElement(id) {
        const element = document.getElementById(id);
        if (!element) {
          console.error(`Element with id "${id}" not found`);
          return null;
        }
        return element;
      }

      // DOM refs - with safety checks
      const audio = getElement("music-player");
      const canvas = getElement("visualizer");
      const playlist = getElement("playlist");
      const nowTxt = getElement("now-playing");
      const artistTxt = getElement("track-artist");
      const curT = getElement("current-time");
      const totT = getElement("total-time");
      const progBar = getElement("progress-bar");
      const progCon = getElement("progress-container");
      const prevBtn = getElement("prevTrack");
      const nxtBtn = getElement("nextTrack");
      const playBtn = getElement("togglePlay");
      const modeBtns = document.querySelectorAll(".mode-button");
      const volumeSlider = getElement("volume-slider");
      const muteBtn = getElement("toggleMute");
      const togglePlaylistBtn = getElement("togglePlaylist");
      const playlistSection = getElement("playlist-section");
      const trackCount = getElement("track-count");

      // Initialize canvas context if canvas exists
      let ctx = null;
      if (canvas) {
        try {
          ctx = canvas.getContext("2d");
        } catch (e) {
          console.error("Error getting canvas context:", e);
        }
      }

      // State variables
      let currentTrackIndex = 0;
      let isPlaying = false;
      let visualizerMode = "bars";
      let audioContext = null;
      let analyser = null;
      let sourceNode = null;
      let dataArray = null;
      let timeData = null;
      let audioInitialized = false;
      let previousVolume = 0.7;
      let isMuted = false;
      let animationId = null;

      // Prevent screen from sleeping
      let wakeLock = null;

      async function requestWakeLock() {
        try {
          if ("wakeLock" in navigator) {
            wakeLock = await navigator.wakeLock.request("screen");
            console.log("Wake Lock is active");

            // Re-request wake lock if page becomes visible again
            document.addEventListener("visibilitychange", handleVisibilityChange);
          } else {
            console.log("Wake Lock API not supported");
          }
        } catch (err) {
          console.error(`Error requesting wake lock: ${err.name}, ${err.message}`);
        }
      }

      async function handleVisibilityChange() {
        if (document.visibilityState === "visible" && wakeLock === null) {
          await requestWakeLock();
        }
      }

      // Request wake lock when user interacts with the page
      document.addEventListener("click", () => {
        if (!wakeLock) {
          requestWakeLock();
        }
      });

      // Initialize Web Audio API
      function initAudio() {
        if (audioInitialized || !audio) return false;

        try {
          // Create audio context
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) {
            console.error("Web Audio API not supported in this browser");
            return false;
          }

          audioContext = new AudioContext();
          
          // Create audio nodes
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          
          // Connect nodes
          sourceNode = audioContext.createMediaElementSource(audio);
          sourceNode.connect(analyser);
          analyser.connect(audioContext.destination);
          
          // Create data arrays
          dataArray = new Uint8Array(analyser.frequencyBinCount);
          timeData = new Uint8Array(analyser.frequencyBinCount);
          
          audioInitialized = true;
          console.log("Audio system initialized successfully");
          return true;
        } catch (e) {
          console.error("Error initializing audio system:", e);
          return false;
        }
      }

      // Resize canvas to match container
      function resizeCanvas() {
        if (!canvas || !ctx) return;
        
        try {
          const container = canvas.parentElement;
          if (container) {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
          }
        } catch (e) {
          console.error("Error resizing canvas:", e);
        }
      }

      // Call resize on load and window resize
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Build playlist
      function buildPlaylist() {
        if (!playlist) return;
        
        try {
          // Clear existing playlist
          playlist.innerHTML = "";
          
          // Add tracks
          tracks.forEach((track, index) => {
            const li = document.createElement("li");
            li.innerHTML = `
              <div class="track-number">${index + 1}</div>
              <div class="track-details">
                <div class="track-title">${track.title}</div>
                <div class="track-artist-name">${track.artist}</div>
              </div>
            `;
            li.onclick = () => loadTrack(index);
            playlist.appendChild(li);
          });
          
          // Update track count
          if (trackCount) {
            trackCount.textContent = `${tracks.length} tracks`;
          }
          
          console.log("Playlist built with", tracks.length, "tracks");
        } catch (e) {
          console.error("Error building playlist:", e);
        }
      }

      buildPlaylist();

      // Load & play track
      function loadTrack(index) {
        if (!audio || !tracks[index]) return;
        
        try {
          currentTrackIndex = index;
          audio.src = tracks[index].src;
          
          if (nowTxt) nowTxt.textContent = tracks[index].title;
          if (artistTxt) artistTxt.textContent = tracks[index].artist;
          
          updateUI();
          
          if (isPlaying) {
            playAudio();
          }
        } catch (e) {
          console.error("Error loading track:", e);
        }
      }

      // Update UI elements
      function updateUI() {
        try {
          // Update playlist highlighting
          if (playlist) {
            const items = playlist.querySelectorAll("li");
            items.forEach((item, i) => {
              item.classList.toggle("playing", i === currentTrackIndex);
            });
          }
          
          // Update play button
          if (playBtn) {
            playBtn.textContent = isPlaying ? "⏸ PAUSE" : "▶ PLAY";
            playBtn.classList.toggle("playing", isPlaying);
          }
          
          // Update track info icon
          const trackInfoIcon = document.querySelector(".track-info-icon");
          if (trackInfoIcon) {
            trackInfoIcon.textContent = isPlaying ? "▶" : "❚❚";
          }
        } catch (e) {
          console.error("Error updating UI:", e);
        }
      }

      // Play audio with error handling
      function playAudio() {
        if (!audio) return;
        
        try {
          // Initialize audio if needed
          if (!audioInitialized) {
            if (!initAudio()) {
              console.error("Failed to initialize audio");
              return;
            }
          }
          
          // Resume audio context if suspended
          if (audioContext && audioContext.state !== "running") {
            audioContext.resume().catch(e => console.error("Error resuming audio context:", e));
          }
          
          // Play audio
          audio.play()
            .then(() => {
              isPlaying = true;
              updateUI();
              console.log("Audio playback started");
              
              // Request wake lock when playback starts
              requestWakeLock();
            })
            .catch(e => {
              console.error("Error playing audio:", e);
              isPlaying = false;
              updateUI();
            });
        } catch (e) {
          console.error("Error in playAudio:", e);
        }
      }

      // Toggle play/pause
      function togglePlay() {
        if (!audio) return;
        
        try {
          if (audio.paused) {
            playAudio();
          } else {
            audio.pause();
            isPlaying = false;
            updateUI();
          }
        } catch (e) {
          console.error("Error toggling play:", e);
        }
      }

      // Format time as mm:ss
      function formatTime(seconds) {
        if (isNaN(seconds) || !isFinite(seconds)) return "0:00";
        
        try {
          const minutes = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60).toString().padStart(2, "0");
          return `${minutes}:${secs}`;
        } catch (e) {
          console.error("Error formatting time:", e);
          return "0:00";
        }
      }

      // Update time display
      if (audio) {
        audio.addEventListener("timeupdate", () => {
          try {
            if (audio.duration) {
              const percent = (audio.currentTime / audio.duration) * 100;
              if (progBar) progBar.style.width = `${percent}%`;
              if (curT) curT.textContent = formatTime(audio.currentTime);
              if (totT) totT.textContent = formatTime(audio.duration);
            }
          } catch (e) {
            console.error("Error updating time:", e);
          }
        });
      }

      // Handle track end
      if (audio) {
        audio.addEventListener("ended", () => {
          try {
            currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
            loadTrack(currentTrackIndex);
            playAudio();
          } catch (e) {
            console.error("Error handling track end:", e);
          }
        });
      }

      // Set up controls
      if (playBtn) playBtn.addEventListener("click", togglePlay);
      
      if (prevBtn) {
        prevBtn.addEventListener("click", () => {
          try {
            currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length;
            loadTrack(currentTrackIndex);
          } catch (e) {
            console.error("Error on prev track:", e);
          }
        });
      }
      
      if (nxtBtn) {
        nxtBtn.addEventListener("click", () => {
          try {
            currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
            loadTrack(currentTrackIndex);
          } catch (e) {
            console.error("Error on next track:", e);
          }
        });
      }
      
      if (progCon) {
        progCon.addEventListener("click", (e) => {
          try {
            if (!audio || !audio.duration) return;
            
            const rect = progCon.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            audio.currentTime = percent * audio.duration;
          } catch (e) {
            console.error("Error seeking:", e);
          }
        });
      }

      // Set up visualizer mode buttons
      modeBtns.forEach(button => {
        button.addEventListener("click", () => {
          try {
            visualizerMode = button.dataset.mode;
            modeBtns.forEach(btn => btn.classList.toggle("active", btn === button));
          } catch (e) {
            console.error("Error changing visualizer mode:", e);
          }
        });
      });

      // Volume control
      if (volumeSlider) {
        volumeSlider.addEventListener("input", () => {
          try {
            if (!audio) return;
            
            const volume = parseFloat(volumeSlider.value);
            audio.volume = volume;
            
            // Update mute button
            updateMuteButton(volume);
            
            // Store volume for unmute
            if (volume > 0) {
              previousVolume = volume;
              isMuted = false;
            } else {
              isMuted = true;
            }
          } catch (e) {
            console.error("Error adjusting volume:", e);
          }
        });
      }

      // Mute button
      if (muteBtn) {
        muteBtn.addEventListener("click", () => {
          try {
            if (!audio) return;
            
            if (isMuted) {
              // Unmute
              audio.volume = previousVolume;
              if (volumeSlider) volumeSlider.value = previousVolume;
              isMuted = false;
            } else {
              // Mute
              previousVolume = audio.volume;
              audio.volume = 0;
              if (volumeSlider) volumeSlider.value = 0;
              isMuted = true;
            }
            
            updateMuteButton(audio.volume);
          } catch (e) {
            console.error("Error toggling mute:", e);
          }
        });
      }

      // Update mute button icon
      function updateMuteButton(volume) {
        if (!muteBtn) return;
        
        if (volume === 0) {
          muteBtn.textContent = "🔇";
        } else if (volume < 0.3) {
          muteBtn.textContent = "🔈";
        } else if (volume < 0.7) {
          muteBtn.textContent = "🔉";
        } else {
          muteBtn.textContent = "🔊";
        }
      }

      // Toggle playlist on mobile
      if (togglePlaylistBtn && playlistSection) {
        togglePlaylistBtn.addEventListener("click", () => {
          playlistSection.classList.toggle("active");
        });
      }

      // Draw bars visualizer
      function drawBars() {
        if (!ctx || !analyser || !dataArray) return;
        
        try {
          const width = canvas.width;
          const height = canvas.height;
          
          // Get frequency data
          analyser.getByteFrequencyData(dataArray);
          
          // Clear canvas
          ctx.clearRect(0, 0, width, height);
          
          const barCount = dataArray.length / 4; // Use a quarter of the data for better visibility
          const barWidth = width / barCount;
          const barSpacing = 1;
          
          // Draw bars
          for (let i = 0; i < barCount; i++) {
            const value = dataArray[i] / 255;
            const barHeight = value * height * 0.8;
            
            // Calculate color based on frequency and time
            const hue = ((i / barCount) * 360 + Date.now() * 0.05) % 360;
            
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(
              i * barWidth + barSpacing / 2,
              height - barHeight,
              barWidth - barSpacing,
              barHeight
            );
            
            // Add glow for high amplitudes
            if (value > 0.6) {
              ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
              ctx.shadowBlur = 15 * value;
              ctx.fillRect(
                i * barWidth + barSpacing / 2,
                height - barHeight,
                barWidth - barSpacing,
                barHeight
              );
              ctx.shadowBlur = 0;
            }
          }
        } catch (e) {
          console.error("Error drawing bars:", e);
        }
      }

      // Draw wave visualizer
      function drawWave() {
        if (!ctx || !analyser || !dataArray || !timeData) return;
        
        try {
          const width = canvas.width;
          const height = canvas.height;
          
          // Get time domain data
          analyser.getByteTimeDomainData(timeData);
          analyser.getByteFrequencyData(dataArray);
          
          // Calculate average frequency for color
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
          }
          const avgFreq = sum / dataArray.length / 255;
          
          // Clear canvas
          ctx.clearRect(0, 0, width, height);
          
          // Draw wave
          ctx.beginPath();
          ctx.lineWidth = 3;
          
          // Create gradient for line
          const gradient = ctx.createLinearGradient(0, 0, width, 0);
          gradient.addColorStop(0, `hsl(${(Date.now() * 0.05) % 360}, 100%, 50%)`);
          gradient.addColorStop(0.5, `hsl(${(Date.now() * 0.05 + 120) % 360}, 100%, 50%)`);
          gradient.addColorStop(1, `hsl(${(Date.now() * 0.05 + 240) % 360}, 100%, 50%)`);
          
          ctx.strokeStyle = gradient;
          
          // Draw waveform
          for (let i = 0; i < timeData.length; i++) {
            const x = (i / timeData.length) * width;
            const y = ((timeData[i] / 128) - 1) * height / 2 + height / 2;
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          // Add glow effect
          ctx.shadowColor = `hsl(${(Date.now() * 0.05) % 360}, 100%, 50%)`;
          ctx.shadowBlur = 10 + avgFreq * 20;
          ctx.stroke();
        } catch (e) {
          console.error("Error drawing wave:", e);
        }
      }

      // Draw circle visualizer
      function drawCircle() {
        if (!ctx || !analyser || !dataArray) return;
        
        try {
          const width = canvas.width;
          const height = canvas.height;
          const centerX = width / 2;
          const centerY = height / 2;
          
          // Get frequency data
          analyser.getByteFrequencyData(dataArray);
          
          // Clear canvas
          ctx.clearRect(0, 0, width, height);
          
          // Calculate base radius and rotation
          const baseRadius = Math.min(width, height) / 4;
          const rotation = Date.now() * 0.001;
          
          // Calculate average frequency for effects
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
          }
          const avgFreq = sum / dataArray.length / 255;
          
          // Draw frequency bins in a circle
          for (let i = 0; i < dataArray.length; i += 4) {
            const angle = (i / dataArray.length) * Math.PI * 2 + rotation;
            const value = dataArray[i] / 255;
            const amplitude = value * baseRadius;
            
            // Calculate positions
            const innerX = centerX + Math.cos(angle) * baseRadius;
            const innerY = centerY + Math.sin(angle) * baseRadius;
            const outerX = centerX + Math.cos(angle) * (baseRadius + amplitude);
            const outerY = centerY + Math.sin(angle) * (baseRadius + amplitude);
            
            // Calculate color
            const hue = ((angle * 180) / Math.PI + Date.now() * 0.05) % 360;
            
            // Draw line from inner to outer point
            ctx.beginPath();
            ctx.moveTo(innerX, innerY);
            ctx.lineTo(outerX, outerY);
            ctx.lineWidth = 2 + value * 3;
            ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.stroke();
            
            // Draw point at the end
            ctx.beginPath();
            ctx.arc(outerX, outerY, 2 + value * 5, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;
            ctx.fill();
          }
          
          // Draw center circle
          ctx.beginPath();
          const pulseSize = baseRadius * 0.2 * (0.8 + avgFreq * 0.5);
          ctx.arc(centerX, centerY, pulseSize, 0, Math.PI * 2);
          ctx.fillStyle = `hsl(${(Date.now() * 0.05) % 360}, 100%, 70%)`;
          ctx.fill();
        } catch (e) {
          console.error("Error drawing circle:", e);
        }
      }

      // Draw placeholder when not playing
      function drawPlaceholder() {
        if (!ctx) return;
        
        try {
          const width = canvas.width;
          const height = canvas.height;
          const centerX = width / 2;
          const centerY = height / 2;
          
          // Clear canvas
          ctx.clearRect(0, 0, width, height);
          
          // Draw pulsing circle
          const time = Date.now() * 0.001;
          const radius = (Math.min(width, height) / 4) * (0.8 + Math.sin(time) * 0.2);
          
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.strokeStyle = `hsl(${(time * 30) % 360}, 100%, 50%)`;
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Draw text
          ctx.font = "16px 'Press Start 2P', monospace";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#0ff";
          ctx.fillText("Press Play", centerX, centerY);
        } catch (e) {
          console.error("Error drawing placeholder:", e);
        }
      }

      // Main visualization loop
      function draw() {
        try {
          // Cancel any existing animation frame
          if (animationId) {
            cancelAnimationFrame(animationId);
          }
          
          // If audio isn't initialized or playing, show placeholder
          if (!audioInitialized || !isPlaying) {
            drawPlaceholder();
            animationId = requestAnimationFrame(draw);
            return;
          }
          
          // Draw selected visualization
          switch (visualizerMode) {
            case "bars":
              drawBars();
              break;
            case "wave":
              drawWave();
              break;
            case "circle":
              drawCircle();
              break;
            default:
              drawBars();
          }
          
          // Continue animation loop
          animationId = requestAnimationFrame(draw);
        } catch (e) {
          console.error("Error in draw loop:", e);
          // Try to continue the animation even if there was an error
          animationId = requestAnimationFrame(draw);
        }
      }

      // Start visualization loop
      draw();

      // Load first track
      loadTrack(0);

      console.log("🎵 SonicWave Music Player initialization complete");
    });
  </script>
</body>
</html>
