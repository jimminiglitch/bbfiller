/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/accesibility.js":
/*!*****************************!*\
  !*** ./src/accesibility.js ***!
  \*****************************/
/***/ (() => {

eval("/**\r\n * ♿ Enhanced Accessibility Module\r\n * Comprehensive accessibility improvements for desktop-like web interfaces\r\n * - Improved keyboard navigation and focus management\r\n * - ARIA attributes and screen reader announcements\r\n * - Focus trapping for modal dialogs\r\n * - High contrast mode support\r\n */\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n  console.log(\"♿ Initializing Enhanced Accessibility Module...\");\r\n\r\n  // ── Configuration ──────────────────────────────────────────────────────────────\r\n  const config = {\r\n    roles: {\r\n      window: \"dialog\",\r\n      desktop: \"application\",\r\n      taskbar: \"toolbar\",\r\n      startMenu: \"menu\",\r\n      startButton: \"button\",\r\n      desktopIcon: \"button\",\r\n      windowContent: \"region\"\r\n    },\r\n    shortcuts: [\r\n      { keys: [\"Escape\"], ctrl: false, alt: false, shift: false, action: closeActiveWindow, description: \"Close active window\" },\r\n      { keys: [\"Tab\"], ctrl: false, alt: true, shift: false, action: () => switchWindow(1), description: \"Switch to next window\" },\r\n      { keys: [\"Tab\"], ctrl: false, alt: true, shift: true, action: () => switchWindow(-1), description: \"Switch to previous window\" },\r\n      { keys: [\"m\"], ctrl: false, alt: true, shift: false, action: minimizeActiveWindow, description: \"Minimize active window\" },\r\n      { keys: [\"m\"], ctrl: false, alt: true, shift: true, action: toggleMaximizeActiveWindow, description: \"Maximize/restore active window\" },\r\n      { keys: [\"F1\"], ctrl: false, alt: false, shift: false, action: showKeyboardShortcutsHelp, description: \"Show keyboard shortcuts help\" },\r\n      { keys: [\"h\"], ctrl: false, alt: true, shift: false, action: toggleHighContrastMode, description: \"Toggle high contrast mode\" }\r\n    ],\r\n    selectors: {\r\n      desktop: \".container\",\r\n      taskbar: \"#start-bar\",\r\n      startButton: \"#start-button\",\r\n      startMenu: \"#start-menu\",\r\n      desktopIcons: \".desktop-icon\",\r\n      windows: \".popup-window\",\r\n      activeWindow: \".window-active\",\r\n      windowTitle: \".window-title\",\r\n      windowContent: \".window-content\",\r\n      windowHeader: \".window-header\",\r\n      closeButton: \".close-btn\"\r\n    },\r\n    announcements: {\r\n      delay: 50, // ms delay before announcing to ensure DOM updates complete\r\n      windowOpened: (title) => `${title} window opened`,\r\n      windowClosed: (title) => `${title} window closed`,\r\n      windowMinimized: (title) => `${title} window minimized`,\r\n      windowMaximized: (title) => `${title} window maximized`,\r\n      windowRestored: (title) => `${title} window restored`,\r\n      startMenuOpened: \"Start menu opened\",\r\n      startMenuClosed: \"Start menu closed\"\r\n    }\r\n  };\r\n\r\n  // ── State Management ────────────────────────────────────────────────────────────\r\n  const state = {\r\n    lastFocusedElement: null,\r\n    isHighContrastMode: false,\r\n    activeModalId: null,\r\n    shortcutsHelpVisible: false\r\n  };\r\n\r\n  // Mock functions for window management (replace with actual implementations)\r\n  function minimizeWindow(windowId) {\r\n    console.log(`Minimize window: ${windowId}`);\r\n  }\r\n\r\n  function toggleMaximize(windowId) {\r\n    console.log(`Toggle maximize window: ${windowId}`);\r\n  }\r\n\r\n  function focusWindow(windowId) {\r\n    console.log(`Focus window: ${windowId}`);\r\n  }\r\n\r\n  // ── Initialization ───────────────────────────────────────────────────────────\r\n  function initialize() {\r\n    try {\r\n      addSkipLinks();\r\n      setupScreenReaderAnnouncer();\r\n      applyAriaAttributes();\r\n      enableKeyboardShortcuts();\r\n      makeWindowsAccessible();\r\n      setupFocusManagement();\r\n      setupEventListeners();\r\n      createKeyboardShortcutsHelp();\r\n      console.log(\"♿ Enhanced Accessibility Module initialized successfully\");\r\n    } catch (error) {\r\n      console.error(\"♿ Error initializing accessibility enhancements:\", error);\r\n    }\r\n  }\r\n\r\n  // Delay initialization to ensure DOM is fully loaded\r\n  setTimeout(initialize, 500);\r\n\r\n  // ── Helpers ───────────────────────────────────────────────────────────────────\r\n  function $(selector, parent = document) {\r\n    return parent.querySelector(selector);\r\n  }\r\n\r\n  function $$(selector, parent = document) {\r\n    return Array.from(parent.querySelectorAll(selector));\r\n  }\r\n\r\n  function setAttr(el, attrs = {}) {\r\n    if (!el) return;\r\n    Object.entries(attrs).forEach(([k, v]) => v != null && el.setAttribute(k, v));\r\n  }\r\n\r\n  function onKeyMatch(e, { keys, ctrl, alt, shift }) {\r\n    return keys.includes(e.key) &&\r\n      !!e.ctrlKey === ctrl &&\r\n      !!e.altKey === alt &&\r\n      !!e.shiftKey === shift;\r\n  }\r\n\r\n  function getWindowTitle(win) {\r\n    if (!win) return \"Window\";\r\n    const titleEl = $(config.selectors.windowTitle, win);\r\n    return titleEl?.textContent?.trim() || win.id || \"Window\";\r\n  }\r\n\r\n  function getFocusableElements(container) {\r\n    if (!container) return [];\r\n    return $$(\r\n      'a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex=\"0\"]',\r\n      container\r\n    ).filter(el => {\r\n      // Check if element is visible and not hidden by CSS\r\n      const style = window.getComputedStyle(el);\r\n      return style.display !== 'none' && style.visibility !== 'hidden' && el.offsetParent !== null;\r\n    });\r\n  }\r\n\r\n  // ── Screen Reader Announcer ────────────────────────────────────────────────────\r\n  function setupScreenReaderAnnouncer() {\r\n    const announcer = document.createElement(\"div\");\r\n    announcer.id = \"sr-announcer\";\r\n    announcer.setAttribute(\"aria-live\", \"polite\");\r\n    announcer.setAttribute(\"aria-atomic\", \"true\");\r\n    announcer.className = \"sr-only\";\r\n    Object.assign(announcer.style, {\r\n      position: \"absolute\",\r\n      width: \"1px\",\r\n      height: \"1px\",\r\n      padding: \"0\",\r\n      overflow: \"hidden\",\r\n      clip: \"rect(0, 0, 0, 0)\",\r\n      whiteSpace: \"nowrap\",\r\n      border: \"0\"\r\n    });\r\n    document.body.appendChild(announcer);\r\n  }\r\n\r\n  function announce(message, priority = \"polite\") {\r\n    const announcer = $(\"#sr-announcer\");\r\n    if (!announcer) return;\r\n    \r\n    // Set the appropriate aria-live value\r\n    announcer.setAttribute(\"aria-live\", priority);\r\n    \r\n    // Clear the announcer first, then add the new message after a short delay\r\n    announcer.textContent = \"\";\r\n    \r\n    setTimeout(() => {\r\n      announcer.textContent = message;\r\n    }, config.announcements.delay);\r\n  }\r\n\r\n  // ── Skip Links ────────────────────────────────────────────────────────────────\r\n  function addSkipLinks() {\r\n    const skipLinks = [\r\n      { target: \"#desktop-icons\", text: \"Skip to desktop icons\" },\r\n      { target: config.selectors.taskbar, text: \"Skip to taskbar\" }\r\n    ];\r\n\r\n    const skipLinksContainer = document.createElement(\"div\");\r\n    skipLinksContainer.className = \"skip-links\";\r\n    Object.assign(skipLinksContainer.style, {\r\n      position: \"absolute\",\r\n      top: \"0\",\r\n      left: \"0\",\r\n      zIndex: \"10000\"\r\n    });\r\n\r\n    skipLinks.forEach(({ target, text }) => {\r\n      const link = document.createElement(\"a\");\r\n      link.href = target;\r\n      link.textContent = text;\r\n      link.className = \"skip-link\";\r\n      Object.assign(link.style, {\r\n        position: \"absolute\",\r\n        top: \"-40px\",\r\n        left: \"0\",\r\n        padding: \"8px\",\r\n        background: \"#000\",\r\n        color: \"#0ff\",\r\n        zIndex: \"10000\",\r\n        transition: \"top 0.2s ease\",\r\n        textDecoration: \"none\",\r\n        fontWeight: \"bold\",\r\n        border: \"2px solid #0ff\"\r\n      });\r\n      link.addEventListener(\"focus\", () => link.style.top = \"0\");\r\n      link.addEventListener(\"blur\", () => link.style.top = \"-40px\");\r\n      link.addEventListener(\"click\", (e) => {\r\n        e.preventDefault();\r\n        const targetEl = $(target);\r\n        if (targetEl) {\r\n          targetEl.focus();\r\n          targetEl.scrollIntoView({ behavior: \"smooth\" });\r\n        }\r\n      });\r\n      skipLinksContainer.appendChild(link);\r\n    });\r\n\r\n    document.body.prepend(skipLinksContainer);\r\n  }\r\n\r\n  // ── ARIA Setup ────────────────────────────────────────────────────────────────\r\n  function applyAriaAttributes() {\r\n    // Desktop container\r\n    const desktop = $(config.selectors.desktop);\r\n    desktop && setAttr(desktop, {\r\n      role: config.roles.desktop,\r\n      \"aria-label\": \"Desktop\",\r\n      tabindex: \"-1\"\r\n    });\r\n\r\n    // Taskbar\r\n    const taskbar = $(config.selectors.taskbar);\r\n    taskbar && setAttr(taskbar, {\r\n      role: config.roles.taskbar,\r\n      \"aria-label\": \"Taskbar\",\r\n      tabindex: \"0\"\r\n    });\r\n\r\n    // Start button + menu\r\n    setupStartMenu();\r\n\r\n    // Desktop icons\r\n    setupDesktopIcons();\r\n  }\r\n\r\n  function setupStartMenu() {\r\n    const startButton = $(config.selectors.startButton);\r\n    const startMenu = $(config.selectors.startMenu);\r\n\r\n    if (startButton) {\r\n      setAttr(startButton, {\r\n        role: config.roles.startButton,\r\n        \"aria-label\": \"Start Menu\",\r\n        \"aria-haspopup\": \"true\",\r\n        \"aria-expanded\": \"false\",\r\n        tabindex: \"0\"\r\n      });\r\n\r\n      startButton.addEventListener(\"click\", () => {\r\n        const expanded = startMenu?.style.display === \"block\";\r\n        startButton.setAttribute(\"aria-expanded\", String(expanded));\r\n        \r\n        if (expanded) {\r\n          announce(config.announcements.startMenuOpened);\r\n          \r\n          // Make menu items focusable and focus the first one\r\n          const menuItems = startMenu ? $$(config.selectors.startMenu + \" a, \" + config.selectors.startMenu + \" button\") : [];\r\n          menuItems.forEach(item => {\r\n            setAttr(item, { role: \"menuitem\", tabindex: \"0\" });\r\n          });\r\n          \r\n          if (menuItems.length > 0) {\r\n            menuItems[0].focus();\r\n          }\r\n        } else {\r\n          announce(config.announcements.startMenuClosed);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (startMenu) {\r\n      setAttr(startMenu, {\r\n        role: config.roles.startMenu,\r\n        \"aria-label\": \"Start Menu\"\r\n      });\r\n\r\n      // Add keyboard navigation for start menu\r\n      startMenu.addEventListener(\"keydown\", (e) => {\r\n        const menuItems = $$(config.selectors.startMenu + \" a, \" + config.selectors.startMenu + \" button\");\r\n        const currentIndex = menuItems.findIndex(item => item === document.activeElement);\r\n        \r\n        switch (e.key) {\r\n          case \"ArrowDown\":\r\n            e.preventDefault();\r\n            if (currentIndex < menuItems.length - 1) {\r\n              menuItems[currentIndex + 1].focus();\r\n            } else {\r\n              menuItems[0].focus();\r\n            }\r\n            break;\r\n          case \"ArrowUp\":\r\n            e.preventDefault();\r\n            if (currentIndex > 0) {\r\n              menuItems[currentIndex - 1].focus();\r\n            } else {\r\n              menuItems[menuItems.length - 1].focus();\r\n            }\r\n            break;\r\n          case \"Escape\":\r\n            e.preventDefault();\r\n            startButton.click(); // Close the menu\r\n            startButton.focus(); // Return focus to start button\r\n            break;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  function setupDesktopIcons() {\r\n    $$(config.selectors.desktopIcons).forEach(icon => {\r\n      const label = icon.querySelector(\"span\")?.textContent || icon.id.replace(/^icon-/, \"\");\r\n      setAttr(icon, {\r\n        role: config.roles.desktopIcon,\r\n        tabindex: \"0\",\r\n        \"aria-label\": `Open ${label}`\r\n      });\r\n\r\n      // Add keyboard support\r\n      icon.addEventListener(\"keydown\", e => {\r\n        if (e.key === \"Enter\" || e.key === \" \") {\r\n          e.preventDefault();\r\n          icon.click();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  // ── Keyboard Shortcuts ────────────────────────────────────────────────────────\r\n  function enableKeyboardShortcuts() {\r\n    document.addEventListener(\"keydown\", e => {\r\n      // Skip if user is typing in an input field\r\n      if ([\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(document.activeElement.tagName)) {\r\n        return;\r\n      }\r\n\r\n      for (const sc of config.shortcuts) {\r\n        if (onKeyMatch(e, sc)) {\r\n          e.preventDefault();\r\n          sc.action();\r\n          break;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // Shortcut Actions\r\n  function closeActiveWindow() {\r\n    const win = $(config.selectors.activeWindow);\r\n    if (!win) return;\r\n    \r\n    const title = getWindowTitle(win);\r\n    const closeBtn = $(config.selectors.closeButton, win);\r\n    \r\n    if (closeBtn) {\r\n      closeBtn.click();\r\n      announce(config.announcements.windowClosed(title));\r\n    }\r\n  }\r\n\r\n  function minimizeActiveWindow() {\r\n    const win = $(config.selectors.activeWindow);\r\n    if (!win) return;\r\n    \r\n    const title = getWindowTitle(win);\r\n    \r\n    if (typeof minimizeWindow === \"function\") {\r\n      minimizeWindow(win.id);\r\n      announce(config.announcements.windowMinimized(title));\r\n    }\r\n  }\r\n\r\n  function toggleMaximizeActiveWindow() {\r\n    const win = $(config.selectors.activeWindow);\r\n    if (!win) return;\r\n    \r\n    const title = getWindowTitle(win);\r\n    const isMaximized = win.classList.contains(\"maximized\");\r\n    \r\n    if (typeof toggleMaximize === \"function\") {\r\n      toggleMaximize(win.id);\r\n      \r\n      // Announce the new state after a short delay to ensure the DOM has updated\r\n      setTimeout(() => {\r\n        const newIsMaximized = win.classList.contains(\"maximized\");\r\n        if (newIsMaximized && !isMaximized) {\r\n          announce(config.announcements.windowMaximized(title));\r\n        } else if (!newIsMaximized && isMaximized) {\r\n          announce(config.announcements.windowRestored(title));\r\n        }\r\n      }, 100);\r\n    }\r\n  }\r\n\r\n  function switchWindow(direction) {\r\n    const wins = $$(config.selectors.windows).filter(w => w.style.display !== \"none\");\r\n    if (!wins.length) return;\r\n\r\n    const active = $(config.selectors.activeWindow);\r\n    let idx = active ? wins.indexOf(active) : -1;\r\n    idx = (idx + direction + wins.length) % wins.length;\r\n    const target = wins[idx];\r\n    \r\n    if (typeof focusWindow === \"function\") {\r\n      focusWindow(target.id);\r\n      announce(getWindowTitle(target) + \" window activated\");\r\n    }\r\n  }\r\n\r\n  function toggleHighContrastMode() {\r\n    state.isHighContrastMode = !state.isHighContrastMode;\r\n    \r\n    if (state.isHighContrastMode) {\r\n      document.body.classList.add(\"high-contrast-mode\");\r\n      announce(\"High contrast mode enabled\");\r\n    } else {\r\n      document.body.classList.remove(\"high-contrast-mode\");\r\n      announce(\"High contrast mode disabled\");\r\n    }\r\n    \r\n    // Add high contrast styles if they don't exist\r\n    if (state.isHighContrastMode && !$(\"#high-contrast-styles\")) {\r\n      const style = document.createElement(\"style\");\r\n      style.id = \"high-contrast-styles\";\r\n      style.textContent = `\r\n        .high-contrast-mode {\r\n          filter: invert(100%);\r\n        }\r\n        .high-contrast-mode img,\r\n        .high-contrast-mode video {\r\n          filter: invert(100%);\r\n        }\r\n        .high-contrast-mode * {\r\n          background-color: white !important;\r\n          color: black !important;\r\n          border-color: black !important;\r\n        }\r\n        .high-contrast-mode .window-active {\r\n          outline: 3px solid yellow !important;\r\n        }\r\n      `;\r\n      document.head.appendChild(style);\r\n    }\r\n  }\r\n\r\n  // ── Window Accessibility ────────────────────────────────────────────────────\r\n  function makeWindowsAccessible() {\r\n    $$(config.selectors.windows).forEach(win => {\r\n      const titleEl = $(config.selectors.windowTitle, win);\r\n      const titleText = getWindowTitle(win);\r\n      \r\n      // Set window role and label\r\n      if (titleEl) {\r\n        titleEl.id ||= `title-${win.id || Math.random().toString(36).substring(2, 9)}`;\r\n        setAttr(win, {\r\n          role: config.roles.window,\r\n          \"aria-labelledby\": titleEl.id,\r\n          tabindex: \"-1\"\r\n        });\r\n      } else {\r\n        setAttr(win, {\r\n          role: config.roles.window,\r\n          \"aria-label\": titleText,\r\n          tabindex: \"-1\"\r\n        });\r\n      }\r\n\r\n      // Set content region\r\n      const content = $(config.selectors.windowContent, win);\r\n      content && setAttr(content, {\r\n        role: config.roles.windowContent,\r\n        \"aria-label\": `${titleText} content`\r\n      });\r\n\r\n      // Set close button\r\n      const closeBtn = $(config.selectors.closeButton, win);\r\n      closeBtn && setAttr(closeBtn, {\r\n        \"aria-label\": `Close ${titleText}`,\r\n        tabindex: \"0\"\r\n      });\r\n\r\n      // Set window header\r\n      const header = $(config.selectors.windowHeader, win);\r\n      if (header) {\r\n        setAttr(header, {\r\n          role: \"heading\",\r\n          tabindex: \"0\",\r\n          \"aria-level\": \"1\",\r\n          \"aria-label\": `${titleText} - double-click to maximize`\r\n        });\r\n      }\r\n\r\n      // Add keyboard support for window controls\r\n      setupWindowKeyboardControls(win);\r\n    });\r\n\r\n    // Watch for new windows being added to the DOM\r\n    setupWindowObserver();\r\n  }\r\n\r\n  function setupWindowKeyboardControls(win) {\r\n    if (!win) return;\r\n    \r\n    // Add keyboard support for window header (maximize on Enter)\r\n    const header = $(config.selectors.windowHeader, win);\r\n    if (header) {\r\n      header.addEventListener(\"keydown\", e => {\r\n        if (e.key === \"Enter\") {\r\n          e.preventDefault();\r\n          if (typeof toggleMaximize === \"function\") {\r\n            toggleMaximize(win.id);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Make sure all interactive elements are keyboard accessible\r\n    const interactiveElements = $$('button, a, [role=\"button\"]', win);\r\n    interactiveElements.forEach(el => {\r\n      if (!el.hasAttribute(\"tabindex\")) {\r\n        el.setAttribute(\"tabindex\", \"0\");\r\n      }\r\n    });\r\n  }\r\n\r\n  // ── Focus Management ────────────────────────────────────────────────────────\r\n  function setupFocusManagement() {\r\n    // Track the last focused element before a modal opens\r\n    document.addEventListener(\"focusin\", e => {\r\n      if (!state.activeModalId) {\r\n        state.lastFocusedElement = e.target;\r\n      }\r\n    });\r\n\r\n    // Set up focus trapping for windows\r\n    $$(config.selectors.windows).forEach(win => {\r\n      setupFocusTrap(win);\r\n    });\r\n  }\r\n\r\n  function setupFocusTrap(container) {\r\n    if (!container) return;\r\n    \r\n    container.addEventListener(\"keydown\", e => {\r\n      // Only trap focus if this window is active and modal\r\n      if (!container.classList.contains(\"window-active\") || \r\n          !container.classList.contains(\"modal\")) {\r\n        return;\r\n      }\r\n      \r\n      if (e.key === \"Tab\") {\r\n        const focusableElements = getFocusableElements(container);\r\n        if (focusableElements.length === 0) return;\r\n        \r\n        const firstElement = focusableElements[0];\r\n        const lastElement = focusableElements[focusableElements.length - 1];\r\n        \r\n        if (e.shiftKey && document.activeElement === firstElement) {\r\n          e.preventDefault();\r\n          lastElement.focus();\r\n        } else if (!e.shiftKey && document.activeElement === lastElement) {\r\n          e.preventDefault();\r\n          firstElement.focus();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // ── Event Listeners ────────────────────────────────────────────────────────\r\n  function setupEventListeners() {\r\n    // Listen for window open events\r\n    document.addEventListener(\"windowOpened\", e => {\r\n      const winId = e.detail?.windowId;\r\n      if (!winId) return;\r\n      \r\n      const win = $(`#${winId}`);\r\n      if (!win) return;\r\n      \r\n      // Make window accessible\r\n      makeWindowsAccessible();\r\n      \r\n      // Set up focus trap\r\n      setupFocusTrap(win);\r\n      \r\n      // Focus the window\r\n      win.focus();\r\n      \r\n      // Announce window opened\r\n      const title = getWindowTitle(win);\r\n      announce(config.announcements.windowOpened(title));\r\n      \r\n      // If modal, store active modal ID and last focused element\r\n      if (win.classList.contains(\"modal\")) {\r\n        state.activeModalId = winId;\r\n      }\r\n    });\r\n\r\n    // Listen for window close events\r\n    document.addEventListener(\"windowClosed\", e => {\r\n      const winId = e.detail?.windowId;\r\n      if (!winId) return;\r\n      \r\n      // If this was the active modal, restore focus\r\n      if (state.activeModalId === winId) {\r\n        state.activeModalId = null;\r\n        if (state.lastFocusedElement) {\r\n          state.lastFocusedElement.focus();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // ── Window Observer ────────────────────────────────────────────────────────\r\n  function setupWindowObserver() {\r\n    // Watch for new windows being added to the DOM\r\n    const observer = new MutationObserver(mutations => {\r\n      let newWindowAdded = false;\r\n      \r\n      mutations.forEach(mutation => {\r\n        if (mutation.type === 'childList') {\r\n          mutation.addedNodes.forEach(node => {\r\n            if (node.nodeType === 1 && node.matches(config.selectors.windows)) {\r\n              newWindowAdded = true;\r\n              makeWindowsAccessible();\r\n              setupFocusTrap(node);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      \r\n      if (newWindowAdded) {\r\n        console.log(\"♿ New window detected, accessibility attributes applied\");\r\n      }\r\n    });\r\n    \r\n    observer.observe(document.body, { childList: true, subtree: true });\r\n  }\r\n\r\n  // ── Keyboard Shortcuts Help ────────────────────────────────────────────────\r\n  function createKeyboardShortcutsHelp() {\r\n    const helpWindow = document.createElement(\"div\");\r\n    helpWindow.id = \"keyboard-shortcuts-help\";\r\n    helpWindow.className = \"popup-window\";\r\n    helpWindow.style.display = \"none\";\r\n    helpWindow.style.zIndex = \"10000\";\r\n    helpWindow.style.width = \"400px\";\r\n    helpWindow.style.height = \"auto\";\r\n    helpWindow.style.maxHeight = \"80vh\";\r\n    helpWindow.style.overflow = \"auto\";\r\n    \r\n    helpWindow.innerHTML = `\r\n      <div class=\"window-header\">\r\n        <div class=\"window-title\">Keyboard Shortcuts</div>\r\n        <div class=\"window-controls\">\r\n          <button class=\"close-btn\" aria-label=\"Close keyboard shortcuts help\">×</button>\r\n        </div>\r\n      </div>\r\n      <div class=\"window-content\">\r\n        <table style=\"width: 100%; border-collapse: collapse;\">\r\n          <thead>\r\n            <tr>\r\n              <th style=\"text-align: left; padding: 8px; border-bottom: 1px solid #ccc;\">Shortcut</th>\r\n              <th style=\"text-align: left; padding: 8px; border-bottom: 1px solid #ccc;\">Description</th>\r\n            </tr>\r\n          </thead>\r\n          <tbody>\r\n            ${config.shortcuts.map(sc => `\r\n              <tr>\r\n                <td style=\"padding: 8px; border-bottom: 1px solid #ccc;\">\r\n                  ${sc.ctrl ? 'Ctrl+' : ''}${sc.alt ? 'Alt+' : ''}${sc.shift ? 'Shift+' : ''}${sc.keys[0]}\r\n                </td>\r\n                <td style=\"padding: 8px; border-bottom: 1px solid #ccc;\">${sc.description}</td>\r\n              </tr>\r\n            `).join('')}\r\n          </tbody>\r\n        </table>\r\n      </div>\r\n    `;\r\n    \r\n    document.body.appendChild(helpWindow);\r\n    \r\n    // Add close button functionality\r\n    const closeBtn = helpWindow.querySelector(\".close-btn\");\r\n    if (closeBtn) {\r\n      closeBtn.addEventListener(\"click\", () => {\r\n        helpWindow.style.display = \"none\";\r\n        state.shortcutsHelpVisible = false;\r\n        if (state.lastFocusedElement) {\r\n          state.lastFocusedElement.focus();\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Make the help window accessible\r\n    setAttr(helpWindow, {\r\n      role: config.roles.window,\r\n      \"aria-label\": \"Keyboard Shortcuts Help\",\r\n      tabindex: \"-1\"\r\n    });\r\n    \r\n    setupFocusTrap(helpWindow);\r\n  }\r\n\r\n  function showKeyboardShortcutsHelp() {\r\n    const helpWindow = $(\"#keyboard-shortcuts-help\");\r\n    if (!helpWindow) return;\r\n    \r\n    state.lastFocusedElement = document.activeElement;\r\n    helpWindow.style.display = \"block\";\r\n    state.shortcutsHelpVisible = true;\r\n    \r\n    // Position the window in the center\r\n    helpWindow.style.left = \"50%\";\r\n    helpWindow.style.top = \"50%\";\r\n    helpWindow.style.transform = \"translate(-50%, -50%)\";\r\n    \r\n    // Focus the window\r\n    helpWindow.focus();\r\n    \r\n    // Announce\r\n    announce(\"Keyboard shortcuts help opened\");\r\n  }\r\n});\r\n\r\n// Add high contrast mode styles\r\nconst highContrastStyles = document.createElement(\"style\");\r\nhighContrastStyles.textContent = `\r\n  .high-contrast-mode {\r\n    filter: invert(100%);\r\n  }\r\n  .high-contrast-mode img,\r\n  .high-contrast-mode video {\r\n    filter: invert(100%);\r\n  }\r\n  .sr-only {\r\n    position: absolute;\r\n    width: 1px;\r\n    height: 1px;\r\n    padding: 0;\r\n    margin: -1px;\r\n    overflow: hidden;\r\n    clip: rect(0, 0, 0, 0);\r\n    white-space: nowrap;\r\n    border: 0;\r\n  }\r\n`;\r\ndocument.head.appendChild(highContrastStyles);\r\n\r\nconsole.log(\"Accessibility Enhancements script loaded\");style.backgroundColor = \"#000\";\r\n    skipLink.style.color = \"#00ffff\";\r\n    skipLink.style.zIndex = \"10000\";\r\n    skipLink.style.transition = \"top 0.2s ease\";\r\n    \r\n    // Show on focus\r\n    skipLink.addEventListener(\"focus\", () => {\r\n      skipLink.style.top = \"0\";\r\n    });\r\n    \r\n    // Hide on blur\r\n    skipLink.addEventListener(\"blur\", () => {\r\n      skipLink.style.top = \"-40px\";\r\n    });\r\n    \r\n    // Add to document\r\n    document.body.insertBefore(skipLink, document.body.firstChild);\r\n  \r\n  \r\n  // Make windows accessible\r\n  function makeWindowsAccessible() {\r\n    const windows = document.querySelectorAll(\".popup-window\");\r\n    \r\n    windows.forEach(win => {\r\n      // Add dialog role\r\n      win.setAttribute(\"role\", config.roles.window);\r\n      \r\n      // Get window title\r\n      const titleElement = win.querySelector(\".window-title\");\r\n      const title = titleElement ? titleElement.textContent : win.id;\r\n      \r\n      // Set aria-labelledby if title element exists\r\n      if (titleElement) {\r\n        titleElement.id = titleElement.id || `title-${win.id}`;\r\n        win.setAttribute(\"aria-labelledby\", titleElement.id);\r\n      } else {\r\n        // Otherwise set aria-label\r\n        win.setAttribute(\"aria-label\", title);\r\n      }\r\n      \r\n      // Make window content accessible\r\n      const content = win.querySelector(\".window-content\");\r\n      if (content) {\r\n        content.setAttribute(\"role\", \"region\");\r\n        content.setAttribute(\"aria-label\", `${title} content`);\r\n      }\r\n      \r\n      // Make close button accessible\r\n      const closeBtn = win.querySelector(\".close-btn\");\r\n      if (closeBtn) {\r\n        closeBtn.setAttribute(\"aria-label\", `Close ${title}`);\r\n      }\r\n      \r\n      // Add keyboard support for window header (for dragging)\r\n      const header = win.querySelector(\".window-header\");\r\n      if (header) {\r\n        header.setAttribute(\"role\", \"heading\");\r\n        header.setAttribute(\"aria-level\", \"1\");\r\n        header.setAttribute(\"tabindex\", \"0\");\r\n        header.setAttribute(\"aria-label\", `${title} - Double click to maximize`);\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Initialize after a short delay\r\n  setTimeout(initAccessibility, 1000);\r\n;\n\n//# sourceURL=webpack://bbfiller/./src/accesibility.js?");

/***/ }),

/***/ "./src/consolidated.js":
/*!*****************************!*\
  !*** ./src/consolidated.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// consolidated.js - Complete solution\r\ndocument.getElementById(\"icon-file-explorer\").addEventListener(\"click\", () => {\r\n  Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./file-explorer.js */ \"./src/file-explorer.js\", 23));\r\n});\r\n\r\n// ===== UTILITY FUNCTIONS =====\r\nfunction debounce(func, wait) {\r\n  let timeout;\r\n  return function() {\r\n    const args = arguments;\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(() => func.apply(this, args), wait);\r\n  };\r\n}\r\n\r\n// Audio elements - IMPORTANT: Define this ONCE at the global scope\r\n// This prevents multiple instances from being created\r\nif (!window.toadHoverAudio) {\r\n  window.toadHoverAudio = new Audio('https://cdn.glitch.global/09e9ba26-fd4e-41f2-88c1-651c3d32a01a/hover.mp3?v=1746577634973');\r\n  window.toadHoverAudio.volume = 0.5;\r\n  \r\n  // Add debug to track when this plays\r\n  window.toadHoverAudio.addEventListener('play', () => {\r\n    console.log('🔊 Toad hover sound playing!');\r\n    console.trace('Sound triggered from:');\r\n  });\r\n}\r\n\r\n// ===== INITIALIZATION =====\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n  // Initialize all windows once\r\n  initWindowControls();\r\n\r\n  // Start boot sequence is handled by boot-sequence.js\r\n  // We'll just initialize our components after a delay\r\n  setTimeout(() => {\r\n    initDesktopIcons();\r\n    initStarfield();\r\n    initGlitchEffects();\r\n    initStartMenu();\r\n    initIframeHandling();\r\n  }, 1000); // Wait for boot sequence to complete\r\n});\r\n\r\n// ===== WINDOW MANAGEMENT =====\r\nfunction initWindowControls() {\r\n  const windows = document.querySelectorAll(\".popup-window\");\r\n\r\n  windows.forEach((win) => {\r\n    const id = win.id;\r\n    const header = win.querySelector(\".window-header\");\r\n    if (!header) return; // Skip if no header found\r\n    \r\n    const btnMin = header.querySelector(\".minimize\");\r\n    const btnMax = header.querySelector(\".maximize\");\r\n    const btnCls = header.querySelector(\".close\");\r\n\r\n    if (btnMin) btnMin.addEventListener(\"click\", () => minimizeWindow(id));\r\n    if (btnMax) btnMax.addEventListener(\"click\", e => {\r\n      const winEl = e.currentTarget.closest(\".popup-window\");\r\n      toggleMaximize(winEl);\r\n    });\r\n    if (btnCls) btnCls.addEventListener(\"click\", () => closeWindow(id));\r\n\r\n    // Dragging logic\r\n    let isDragging = false,\r\n      offsetX = 0,\r\n      offsetY = 0;\r\n    header.addEventListener(\"mousedown\", (e) => {\r\n      if (e.target.tagName === \"BUTTON\") return; // Don't drag if clicking buttons\r\n      isDragging = true;\r\n      offsetX = e.clientX - win.offsetLeft;\r\n      offsetY = e.clientY - win.offsetTop;\r\n      win.style.zIndex = getNextZIndex();\r\n\r\n      // Add active class to show it's being dragged\r\n      win.classList.add(\"dragging\");\r\n    });\r\n\r\n    // Use passive event listeners for better performance\r\n    document.addEventListener(\r\n      \"mousemove\",\r\n      (e) => {\r\n        if (isDragging) {\r\n          // Don't drag if maximized\r\n          if (win.classList.contains(\"maximized\")) return;\r\n\r\n          win.style.left = `${e.clientX - offsetX}px`;\r\n          win.style.top = `${e.clientY - offsetY}px`;\r\n        }\r\n      },\r\n      { passive: true }\r\n    );\r\n\r\n    document.addEventListener(\r\n      \"mouseup\",\r\n      () => {\r\n        isDragging = false;\r\n        win.classList.remove(\"dragging\");\r\n      },\r\n      { passive: true }\r\n    );\r\n\r\n    // Double-click to maximize\r\n    header.addEventListener(\"dblclick\", (e) => {\r\n      if (e.target.tagName !== \"BUTTON\") {\r\n        toggleMaximizeWindow(id);\r\n      }\r\n    });\r\n\r\n    // Resizing logic\r\n    const directions = [\"top\", \"right\", \"bottom\", \"left\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"];\r\n\r\n    directions.forEach((dir) => {\r\n      const resizer = document.createElement(\"div\");\r\n      resizer.classList.add(\"resizer\", `resizer-${dir}`);\r\n      win.appendChild(resizer);\r\n\r\n      let isResizing = false;\r\n\r\n      resizer.addEventListener(\"mousedown\", (e) => {\r\n        if (win.classList.contains(\"maximized\")) return;\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        isResizing = true;\r\n        win.classList.add(\"resizing\");\r\n        win.style.zIndex = getNextZIndex(); // Ensure window is on top when resizing\r\n        const startX = e.clientX;\r\n        const startY = e.clientY;\r\n        const startWidth = Number.parseInt(getComputedStyle(win).width, 10);\r\n        const startHeight = Number.parseInt(getComputedStyle(win).height, 10);\r\n        const startTop = win.offsetTop;\r\n        const startLeft = win.offsetLeft;\r\n\r\n        function doDrag(e) {\r\n          if (!isResizing) return;\r\n          let newWidth = startWidth;\r\n          let newHeight = startHeight;\r\n          let newTop = startTop;\r\n          let newLeft = startLeft;\r\n\r\n          if (dir.includes(\"right\")) {\r\n            newWidth = Math.max(300, startWidth + e.clientX - startX);\r\n          }\r\n          if (dir.includes(\"bottom\")) {\r\n            newHeight = Math.max(200, startHeight + e.clientY - startY);\r\n          }\r\n          if (dir.includes(\"left\")) {\r\n            const dx = e.clientX - startX;\r\n            newWidth = Math.max(300, startWidth - dx);\r\n            newLeft = startLeft + dx;\r\n          }\r\n          if (dir.includes(\"top\")) {\r\n            const dy = e.clientY - startY;\r\n            newHeight = Math.max(200, startHeight - dy);\r\n            newTop = startTop + dy;\r\n          }\r\n\r\n          win.style.width = `${newWidth}px`;\r\n          win.style.height = `${newHeight}px`;\r\n          win.style.top = `${newTop}px`;\r\n          win.style.left = `${newLeft}px`;\r\n        }\r\n\r\n        function stopDrag() {\r\n          isResizing = false;\r\n          win.classList.remove(\"resizing\");\r\n          window.removeEventListener(\"mousemove\", doDrag);\r\n          window.removeEventListener(\"mouseup\", stopDrag);\r\n        }\r\n\r\n        window.addEventListener(\"mousemove\", doDrag, { passive: true });\r\n        window.addEventListener(\"mouseup\", stopDrag, { passive: true });\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\n// ===== WINDOW OPERATIONS =====\r\nlet currentZIndex = 10;\r\nconst windowStates = {};\r\n\r\nfunction getNextZIndex() {\r\n  return ++currentZIndex;\r\n}\r\n\r\n// FIXED: This is the key function that was causing the issue\r\nfunction openWindow(id) {\r\n  const win = document.getElementById(id);\r\n  if (!win) return;\r\n\r\n  // 1) Hide start menu & deactivate other windows\r\n  const startMenu = document.getElementById(\"start-menu\");\r\n  if (startMenu) startMenu.style.display = \"none\";\r\n  document.querySelectorAll(\".popup-window\").forEach((w) => w.classList.remove(\"active\"));\r\n\r\n  // 2) Lazy-load <iframe data-src>\r\n  win.querySelectorAll(\"iframe[data-src]\").forEach((iframe) => {\r\n    if (!iframe.src) {\r\n      iframe.src = iframe.dataset.src;\r\n    }\r\n  });\r\n\r\n  // 3) Lazy-load <video data-src>\r\n  win.querySelectorAll(\"video[data-src]\").forEach((v) => {\r\n    if (!v.src) {\r\n      v.src = v.dataset.src;\r\n      v.load();\r\n      if (!isMobile()) {\r\n        v.play().catch(() => {});\r\n      }\r\n    }\r\n  });\r\n\r\n  // 4) Show & focus\r\n  win.classList.remove(\"hidden\");\r\n  win.classList.add(\"active\");\r\n  win.style.display = \"flex\";\r\n  win.style.zIndex = getNextZIndex();\r\n  win.classList.add(\"window-opening\");\r\n  setTimeout(() => {\r\n    win.classList.remove(\"window-opening\");\r\n  }, 500);\r\n\r\n  // 5) Special window handling - FIXED: Only play sound for toader window\r\n  if (id === \"toader\" && window.toadHoverAudio) {\r\n    console.log(\"Opening toader window, playing sound\");\r\n    window.toadHoverAudio.currentTime = 0;\r\n    window.toadHoverAudio.play().catch((e) => console.log(\"Audio error:\", e));\r\n  }\r\n\r\n  function openWindow(id) {\r\n  const win = document.getElementById(id);\r\n  win.style.display = 'block';       // or removeClass('minimized') etc.\r\n\r\n  // — reload every video inside that window —\r\n  win.querySelectorAll('video').forEach(video => {\r\n    video.load();                    // re‐initializes the media\r\n    // video.play();                 // if you also want it to autoplay\r\n  });\r\n\r\n  // — reload every iframe (YouTube/Vimeo) inside that window —\r\n  win.querySelectorAll('iframe').forEach(iframe => {\r\n    const src = iframe.getAttribute('data-src') || iframe.src;\r\n    iframe.src = '';                 // clear it out\r\n    iframe.src = src;                // re‐assign to force a reload\r\n  });\r\n}\r\n\r\n  // Special handling for snake game\r\n  if (id === \"snake\") {\r\n    const snakeIframe = document.getElementById(\"snake-iframe\");\r\n    if (snakeIframe) {\r\n      // Force reload the iframe to restart the game properly\r\n      const currentSrc = snakeIframe.src;\r\n      snakeIframe.src = '';\r\n      setTimeout(() => {\r\n        snakeIframe.src = currentSrc;\r\n      }, 100);\r\n    }\r\n  }\r\n\r\n  // 6) Restore previous bounds or clamp to viewport\r\n  const isMobileView = isMobile();\r\n  if (isMobileView) {\r\n    Object.assign(win.style, {\r\n      top: \"0\",\r\n      left: \"0\",\r\n      width: \"100vw\",\r\n      height: \"calc(100vh - 36px)\",\r\n      transform: \"none\",\r\n    });\r\n  } else {\r\n    const stored = windowStates[id];\r\n    if (stored) Object.assign(win.style, stored);\r\n\r\n    const rect = win.getBoundingClientRect();\r\n    const margin = 20;\r\n    const vw = window.innerWidth;\r\n    const vh = window.innerHeight;\r\n    let newW = rect.width,\r\n        newH = rect.height,\r\n        newLeft = rect.left,\r\n        newTop = rect.top;\r\n\r\n    if (rect.width > vw - margin * 2) newW = vw - margin * 2;\r\n    if (rect.height > vh - margin * 2) newH = vh - margin * 2;\r\n    if (rect.left < margin) newLeft = margin;\r\n    if (rect.top < margin) newTop = margin;\r\n    if (rect.right > vw - margin) newLeft = vw - margin - newW;\r\n    if (rect.bottom > vh - margin) newTop = vh - margin - newH;\r\n\r\n    Object.assign(win.style, {\r\n      width:  `${newW}px`,\r\n      height: `${newH}px`,\r\n      left:   `${newLeft}px`,\r\n      top:    `${newTop}px`,\r\n    });\r\n  }\r\n}\r\n\r\n// Helper function to detect mobile devices\r\nfunction isMobile() {\r\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n}\r\n\r\nfunction createTaskbarIcon(id) {\r\n  if (document.getElementById(`taskbar-icon-${id}`)) return;\r\n\r\n  const win = document.getElementById(id);\r\n  if (!win) return; // Skip if window doesn't exist\r\n\r\n  const titleEl = win.querySelector(\".window-header span\");\r\n  const title = titleEl ? titleEl.textContent.replace(\".EXE\", \"\") : id.toUpperCase();\r\n\r\n  const btn = document.createElement(\"button\");\r\n  btn.id = `taskbar-icon-${id}`;\r\n  btn.className = \"taskbar-icon\";\r\n\r\n  const iconText = document.createElement(\"span\");\r\n  iconText.textContent = title;\r\n  btn.appendChild(iconText);\r\n\r\n  btn.addEventListener(\"click\", () => {\r\n    openWindow(id);\r\n    btn.remove();\r\n  });\r\n\r\n  const taskbarIcons = document.getElementById(\"taskbar-icons\");\r\n  if (taskbarIcons) taskbarIcons.appendChild(btn);\r\n}\r\n\r\nfunction minimizeWindow(id) {\r\n  const win = document.getElementById(id);\r\n  if (!win) return;\r\n\r\n  // Add minimizing animation\r\n  win.classList.add(\"window-minimizing\");\r\n\r\n  setTimeout(() => {\r\n    win.classList.remove(\"window-minimizing\");\r\n    win.classList.add(\"hidden\");\r\n    win.style.display = \"none\";\r\n\r\n    // Create taskbar icon\r\n    createTaskbarIcon(id);\r\n\r\n    // Special handling for snake game - pause but don't unload\r\n    if (id === \"snake\") {\r\n      const snakeIframe = document.getElementById(\"snake-iframe\");\r\n      if (snakeIframe) {\r\n        try {\r\n          // Try to send a pause message to the iframe\r\n          snakeIframe.contentWindow.postMessage('pause', '*');\r\n        } catch (e) {\r\n          console.error(\"Could not pause snake game:\", e);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Stop toad hover SFX if it's the toader window\r\n    if (id === \"toader\" && window.toadHoverAudio) {\r\n      window.toadHoverAudio.pause();\r\n      window.toadHoverAudio.currentTime = 0;\r\n    }\r\n  }, 300);\r\n}\r\n\r\nfunction closeWindow(id) {\r\n  const win = document.getElementById(id);\r\n  if (win) {\r\n    // Add closing animation\r\n    win.classList.add(\"window-closing\");\r\n\r\n    setTimeout(() => {\r\n      // Pause/reset any video inside\r\n      const vid = win.querySelector(\"video\");\r\n      if (vid) {\r\n        vid.pause();\r\n        vid.currentTime = 0;\r\n      }\r\n      \r\n  // — STOP MUSIC PLAYER —\r\n  if (id === \"music\") {\r\n    const iframe = win.querySelector(\"iframe\");\r\n    if (iframe && iframe.contentWindow) {\r\n      const audio = iframe.contentWindow.document.getElementById(\"music-player\");\r\n      if (audio) {\r\n        audio.pause();\r\n        audio.currentTime = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n    // Special handling for snake game\r\nif (id === \"snake\") {\r\n  const snakeIframe = document.getElementById(\"snake-iframe\");\r\n  if (snakeIframe) {\r\n    const currentSrc = snakeIframe.src;\r\n    snakeIframe.src = '';\r\n    setTimeout(() => {\r\n      snakeIframe.src = currentSrc;\r\n    }, 50); // delay ensures proper unload before reload\r\n  }\r\n}\r\n\r\n      // Hide window\r\n      win.classList.remove(\"window-closing\");\r\n      win.classList.add(\"hidden\");\r\n      win.style.display = \"none\";\r\n\r\n      // Stop toad hover SFX if it's the toader window\r\n      if (id === \"toader\" && window.toadHoverAudio) {\r\n        window.toadHoverAudio.pause();\r\n        window.toadHoverAudio.currentTime = 0;\r\n      }\r\n    }, 300);\r\n  }\r\n\r\n  // Remove taskbar icon\r\n  const icon = document.getElementById(`taskbar-icon-${id}`);\r\n  if (icon) icon.remove();\r\n}\r\n\r\nfunction toggleMaximize(win) {\r\n  if (win.classList.contains('maximized')) {\r\n    // restore\r\n    win.classList.remove('maximized');\r\n    win.style.top    = win.dataset.prevTop;\r\n    win.style.left   = win.dataset.prevLeft;\r\n    win.style.width  = win.dataset.prevWidth;\r\n    win.style.height = win.dataset.prevHeight;\r\n  } else {\r\n    // stash current geometry\r\n    win.dataset.prevTop    = win.style.top;\r\n    win.dataset.prevLeft   = win.style.left;\r\n    win.dataset.prevWidth  = win.style.width;\r\n    win.dataset.prevHeight = win.style.height;\r\n    // maximize\r\n    win.style.top    = '0';\r\n    win.style.left   = '0';\r\n    win.style.width  = '100vw';\r\n    win.style.height = '100vh';\r\n    win.classList.add('maximized');\r\n  }\r\n}\r\n\r\n\r\nfunction toggleMaximizeWindow(id) {\r\n  const win = document.getElementById(id);\r\n  if (!win) return;\r\n\r\n  const isMax = !win.classList.contains(\"maximized\");\r\n\r\n  if (isMax) {\r\n    // save old bounds\r\n    windowStates[id] = {\r\n      parent: win.parentNode,\r\n      next: win.nextSibling,\r\n      position: win.style.position,\r\n      top: win.style.top,\r\n      left: win.style.left,\r\n      right: win.style.right,\r\n      bottom: win.style.bottom,\r\n      width: win.style.width,\r\n      height: win.style.height,\r\n      transform: win.style.transform,\r\n    };\r\n\r\n    win.classList.add(\"window-maximizing\");\r\n    setTimeout(() => {\r\n      document.body.appendChild(win);\r\n      win.classList.add(\"maximized\");\r\n      win.classList.remove(\"window-maximizing\");\r\n      Object.assign(win.style, {\r\n        position: \"fixed\",\r\n        top: \"0\",\r\n        left: \"0\",\r\n        right: \"0\",\r\n        bottom: \"36px\",\r\n        width: \"auto\",\r\n        height: \"auto\",\r\n        transform: \"none\",\r\n        zIndex: getNextZIndex(),\r\n      });\r\n    }, 300);\r\n  } else {\r\n    win.classList.add(\"window-restoring\");\r\n    win.classList.remove(\"maximized\");\r\n    setTimeout(() => {\r\n      const prev = windowStates[id] || {};\r\n      Object.assign(win.style, {\r\n        position: prev.position || \"absolute\",\r\n        top: prev.top || \"\",\r\n        left: prev.left || \"\",\r\n        right: prev.right || \"\",\r\n        bottom: prev.bottom || \"\",\r\n        width: prev.width || \"\",\r\n        height: prev.height || \"\",\r\n        transform: prev.transform || \"\",\r\n        zIndex: getNextZIndex(),\r\n      });\r\n      if (prev.parent) prev.parent.insertBefore(win, prev.next);\r\n      win.classList.remove(\"window-restoring\");\r\n    }, 300);\r\n  }\r\n}\r\n\r\n// ===== CLOCK & START MENU =====\r\nfunction updateClock() {\r\n  const clk = document.getElementById(\"clock\");\r\n  if (clk) {\r\n    const now = new Date();\r\n    const hours = now.getHours().toString().padStart(2, \"0\");\r\n    const minutes = now.getMinutes().toString().padStart(2, \"0\");\r\n    const seconds = now.getSeconds().toString().padStart(2, \"0\");\r\n    clk.textContent = `${hours}:${minutes}:${seconds}`;\r\n    clk.classList.add(\"clock-pulse\");\r\n    setTimeout(() => {\r\n      clk.classList.remove(\"clock-pulse\");\r\n    }, 500);\r\n  }\r\n}\r\nsetInterval(updateClock, 1000);\r\nupdateClock();\r\n\r\nfunction initStartMenu() {\r\n  const startButton = document.getElementById(\"start-button\");\r\n  if (startButton) {\r\n    startButton.addEventListener(\"click\", () => {\r\n      const m = document.getElementById(\"start-menu\");\r\n      if (!m) return;\r\n      \r\n      const isVisible = m.style.display === \"flex\";\r\n      if (isVisible) {\r\n        m.classList.add(\"menu-hiding\");\r\n        setTimeout(() => {\r\n          m.style.display = \"none\";\r\n          m.classList.remove(\"menu-hiding\");\r\n        }, 300);\r\n      } else {\r\n        m.style.display = \"flex\";\r\n        m.classList.add(\"menu-showing\");\r\n        setTimeout(() => {\r\n          m.classList.remove(\"menu-showing\");\r\n        }, 300);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// ===== DESKTOP ICONS =====\r\nfunction initDesktopIcons() {\r\n  document.querySelectorAll(\".desktop-icon\").forEach((icon) => {\r\n    // IMPORTANT: Remove any existing event listeners to prevent s\r\n    const newIcon = icon.cloneNode(true);\r\n    if (icon.parentNode) {\r\n      icon.parentNode.replaceChild(newIcon, icon);\r\n    }\r\n    icon = newIcon;\r\n\r\n    // open on double-click\r\n    icon.addEventListener(\"dblclick\", () => {\r\n      if (icon.dataset.window) {\r\n        openWindow(icon.dataset.window);\r\n      }\r\n    });\r\n\r\n    // hover effect - FIXED: No sound on hover\r\n    icon.addEventListener(\"mouseenter\", () => {\r\n      icon.classList.add(\"icon-hover\");\r\n    });\r\n    \r\n    icon.addEventListener(\"mouseleave\", () => {\r\n      icon.classList.remove(\"icon-hover\");\r\n    });\r\n\r\n    // drag-group start\r\n    icon.addEventListener(\"mousedown\", (e) => {\r\n      e.preventDefault();\r\n      const parentRect = icon.parentElement.getBoundingClientRect();\r\n      const clickRect = icon.getBoundingClientRect();\r\n      let group;\r\n      if (icon.classList.contains(\"selected\")) {\r\n        group = Array.from(document.querySelectorAll(\".desktop-icon.selected\"));\r\n      } else {\r\n        document.querySelectorAll(\".desktop-icon.selected\").forEach((ic) => ic.classList.remove(\"selected\"));\r\n        icon.classList.add(\"selected\");\r\n        group = [icon];\r\n      }\r\n      const shiftX = e.clientX - clickRect.left;\r\n      const shiftY = e.clientY - clickRect.top;\r\n      const groupData = group.map((ic) => {\r\n        const r = ic.getBoundingClientRect();\r\n        const startLeft = r.left - parentRect.left;\r\n        const startTop = r.top - parentRect.top;\r\n        ic.style.left = `${startLeft}px`;\r\n        ic.style.top = `${startTop}px`;\r\n        ic.style.zIndex = getNextZIndex();\r\n        return { icon: ic, startLeft, startTop };\r\n      });\r\n      function onMouseMove(e) {\r\n        const dx = e.clientX - shiftX - parentRect.left - groupData[0].startLeft;\r\n        const dy = e.clientY - shiftY - parentRect.top - groupData[0].startTop;\r\n        groupData.forEach(({ icon, startLeft, startTop }) => {\r\n          icon.style.left = `${startLeft + dx}px`;\r\n          icon.style.top = `${startTop + dy}px`;\r\n        });\r\n      }\r\n      document.addEventListener(\"mousemove\", onMouseMove, { passive: true });\r\n      document.addEventListener(\r\n        \"mouseup\",\r\n        () => {\r\n          document.removeEventListener(\"mousemove\", onMouseMove);\r\n        },\r\n        { once: true, passive: true }\r\n      );\r\n    });\r\n    icon.ondragstart = () => false;\r\n  });\r\n}\r\n\r\n// ===== MULTI-SELECT =====\r\nlet selStartX, selStartY, selDiv;\r\nfunction onSelectStart(e) {\r\n  if (e.target.closest(\".desktop-icon, .popup-window, #start-bar, #start-menu\")) return;\r\n  selStartX = e.clientX;\r\n  selStartY = e.clientY;\r\n  selDiv = document.createElement(\"div\");\r\n  selDiv.id = \"selection-rect\";\r\n  selDiv.style.left = `${selStartX}px`;\r\n  selDiv.style.top = `${selStartY}px`;\r\n  selDiv.style.width = \"0px\";\r\n  selDiv.style.height = \"0px\";\r\n  document.body.appendChild(selDiv);\r\n  document.addEventListener(\"mousemove\", onSelectMove, { passive: true });\r\n  document.addEventListener(\"mouseup\", onSelectEnd, { once: true, passive: true });\r\n  e.preventDefault();\r\n}\r\n\r\nfunction onSelectMove(e) {\r\n  if (!selDiv) return;\r\n  const x = Math.min(e.clientX, selStartX),\r\n    y = Math.min(e.clientY, selStartY),\r\n    w = Math.abs(e.clientX - selStartX),\r\n    h = Math.abs(e.clientY - selStartY);\r\n  selDiv.style.left = `${x}px`;\r\n  selDiv.style.top = `${y}px`;\r\n  selDiv.style.width = `${w}px`;\r\n  selDiv.style.height = `${h}px`;\r\n  const box = selDiv.getBoundingClientRect();\r\n  document.querySelectorAll(\".desktop-icon\").forEach((icon) => {\r\n    const r = icon.getBoundingClientRect();\r\n    const inside = r.left >= box.left && r.right <= box.right && r.top >= box.top && r.bottom <= box.bottom;\r\n    icon.classList.toggle(\"selected\", inside);\r\n  });\r\n}\r\n\r\nfunction onSelectEnd() {\r\n  if (selDiv) selDiv.remove();\r\n  selDiv = null;\r\n}\r\n\r\n\r\n// ===== STARFIELD BACKGROUND =====\r\nfunction initStarfield() {\r\n  const canvas = document.getElementById(\"background-canvas\");\r\n  if (!canvas) return;\r\n\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return;\r\n\r\n  let stars = [];\r\n  const STAR_COUNT = 500;\r\n  function initStars() {\r\n    stars = Array.from({ length: STAR_COUNT }, () => ({\r\n      x: Math.random() * canvas.width,\r\n      y: Math.random() * canvas.height,\r\n      z: Math.random() * canvas.width,\r\n      o: Math.random()\r\n    }));\r\n  }\r\n\r\n  function drawStars() {\r\n    // full‐opacity background to create motion-blur effect\r\n    ctx.fillStyle = 'rgba(0,0,0,1)';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    for (let s of stars) {\r\n      // twinkle\r\n      s.o += (Math.random() - 0.5) * 0.02;\r\n      s.o = Math.max(0.1, Math.min(1, s.o));\r\n\r\n      // move forward\r\n      s.z -= 2;\r\n      if (s.z <= 0) {\r\n        s.z = canvas.width;\r\n        s.x = Math.random() * canvas.width;\r\n        s.y = Math.random() * canvas.height;\r\n        s.o = Math.random();\r\n      }\r\n\r\n      const k  = 128.0 / s.z;\r\n      const px = (s.x - canvas.width / 2) * k + canvas.width  / 2;\r\n      const py = (s.y - canvas.height / 2) * k + canvas.height / 2;\r\n      const sz = Math.max(0.5, (1 - s.z / canvas.width) * 2);  // half as big\r\n\r\n      ctx.globalAlpha = s.o;\r\n      ctx.fillStyle   = '#fff';\r\n      ctx.beginPath();\r\n      ctx.arc(px, py, sz, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    }\r\n\r\n    ctx.globalAlpha = 1;\r\n  }\r\n\r\n  // on resize, recalc canvas + reinit stars\r\n  window.addEventListener('resize', debounce(() => {\r\n    canvas.width  = window.innerWidth;\r\n    canvas.height = window.innerHeight;\r\n    initStars();\r\n  }, 250));\r\n\r\n  // initial sizing & stars\r\n  canvas.width  = window.innerWidth;\r\n  canvas.height = window.innerHeight;\r\n  initStars();\r\n\r\n  // loop\r\n  function animate() {\r\n    drawStars();\r\n    requestAnimationFrame(animate);\r\n  }\r\n  requestAnimationFrame(animate);\r\n}\r\n\r\n// ===== GLITCH EFFECTS =====\r\nfunction initGlitchEffects() {\r\n  setInterval(() => {\r\n    document.querySelectorAll(\".glitch-me\").forEach((el) => {\r\n      if (Math.random() > 0.95) {\r\n        el.classList.add(\"glitching\");\r\n        setTimeout(() => el.classList.remove(\"glitching\"), 200 + Math.random() * 400);\r\n      }\r\n    });\r\n  }, 2000);\r\n\r\n  setInterval(() => {\r\n    if (Math.random() > 0.98) {\r\n      const glitch = document.createElement(\"div\");\r\n      glitch.className = \"screen-glitch\";\r\n      document.body.appendChild(glitch);\r\n      setTimeout(() => glitch.remove(), 150 + Math.random() * 250);\r\n    }\r\n  }, 10000);\r\n}\r\n\r\n// ===== IFRAME HANDLING =====\r\nfunction initIframeHandling() {\r\n  console.log(\"🖼️ Initializing iframe handling with display-only reload logic\");\r\n  \r\n  document.querySelectorAll('iframe').forEach(iframe => {\r\n    const originalSrc = iframe.src;\r\n    const parent = iframe.closest('.popup-window');\r\n    if (!parent) return;\r\n\r\n    // Track if the window was previously hidden\r\n    let wasHidden = parent.style.display === 'none';\r\n    \r\n    const observer = new MutationObserver(mutations => {\r\n      mutations.forEach(m => {\r\n        if (m.attributeName === 'style') {\r\n          const isHiddenNow = parent.style.display === 'none';\r\n          \r\n          // Only reload if window was hidden and is now visible\r\n          if (wasHidden && !isHiddenNow && iframe.src !== originalSrc) {\r\n            console.log(`🔄 Window became visible, restoring iframe src: ${iframe.id || 'unnamed'}`);\r\n            iframe.src = originalSrc;\r\n          }\r\n          \r\n          // Update hidden state for next time\r\n          wasHidden = isHiddenNow;\r\n        }\r\n      });\r\n    });\r\n\r\n    observer.observe(parent, { attributes: true, attributeFilter: ['style'] });\r\n    console.log(`🔍 Observer attached to iframe: ${iframe.id || 'unnamed'}`);\r\n  });\r\n}\r\n\r\n// ===== INITIALIZATION =====\r\n// Add event listener for window selection\r\nwindow.addEventListener(\"mousedown\", onSelectStart);\r\n\r\n// Override the openWindow function in the global scope\r\n// This ensures our version is used by the start menu links\r\nwindow.openWindow = openWindow;\n\n//# sourceURL=webpack://bbfiller/./src/consolidated.js?");

/***/ }),

/***/ "./src/desktop.js":
/*!************************!*\
  !*** ./src/desktop.js ***!
  \************************/
/***/ (() => {

eval("\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n  console.log(\"🚀 Vaporwave cursor initializing...\");\r\n\r\n  const cursor = document.createElement('div');\r\n  cursor.className = 'custom-cursor';\r\n  const dot = document.createElement('div');\r\n  dot.className = 'cursor-dot';\r\n  cursor.appendChild(dot);\r\n  document.body.appendChild(cursor);\r\n\r\n  document.addEventListener('mousemove', e => {\r\n    cursor.style.left = `${e.clientX}px`;\r\n    cursor.style.top = `${e.clientY}px`;\r\n    cursor.style.transform = 'translate(-50%, -50%)';\r\n  });\r\n\r\n  document.addEventListener('click', () => {\r\n    dot.classList.add('cursor-click');\r\n    setTimeout(() => dot.classList.remove('cursor-click'), 300);\r\n  });\r\n\r\n  console.log(\"✨ Vaporwave cursor ready!\");\r\n});\r\n\n\n//# sourceURL=webpack://bbfiller/./src/desktop.js?");

/***/ }),

/***/ "./src/file-explorer.js":
/*!******************************!*\
  !*** ./src/file-explorer.js ***!
  \******************************/
/***/ (() => {

eval("// File Explorer System\r\n// A retro-styled file explorer simulation for F1LL3R'S R4D W385173\r\n\r\n// File Explorer Namespace\r\n// File Explorer System - Simplified version\r\n;(() => {\r\n  // Wait for DOM to be fully loaded\r\n  window.addEventListener(\"load\", () => {\r\n    // Check if we should initialize the file explorer\r\n    if (document.getElementById(\"file-explorer\")) {\r\n      initFileExplorer()\r\n    }\r\n  })\r\n\r\n  // File system structure\r\n  var fileSystem = {\r\n    \"C:\": {\r\n      type: \"drive\",\r\n      children: {\r\n        Documents: {\r\n          type: \"folder\",\r\n          children: {\r\n            \"README.txt\": {\r\n              type: \"file\",\r\n              content:\r\n                \"Welcome to F1LL3R's R4D W385173!\\n\\nThis is a cyberpunk-themed desktop simulation with various interactive elements.\",\r\n              icon: \"file\",\r\n            },\r\n            \"Projects.txt\": {\r\n              type: \"file\",\r\n              content: \"Current Projects:\\n- Experimental Documentary\\n- Narrative Design\\n- Game Worlds & Story Maps\",\r\n              icon: \"file\",\r\n            },\r\n          },\r\n        },\r\n        Media: {\r\n          type: \"folder\",\r\n          children: {\r\n            Images: {\r\n              type: \"folder\",\r\n              children: {\r\n                \"profile.png\": {\r\n                  type: \"file\",\r\n                  content: \"https://cdn.glitch.global/09e9ba26-fd4e-41f2-88c1-651c3d32a01a/Benny.png?v=1746392528967\",\r\n                  icon: \"image\",\r\n                },\r\n              },\r\n            },\r\n            Videos: {\r\n              type: \"folder\",\r\n              children: {},\r\n            },\r\n            Music: {\r\n              type: \"folder\",\r\n              children: {},\r\n            },\r\n          },\r\n        },\r\n        Games: {\r\n          type: \"folder\",\r\n          children: {\r\n            \"Spaceworm.txt\": {\r\n              type: \"file\",\r\n              content: \"Spaceworm is a trippy version of the classic Snake game with psychedelic visuals and effects.\",\r\n              icon: \"file\",\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n  }\r\n\r\n  // Current path and selected items\r\n  var currentPath = [\"C:\"]\r\n  var selectedItems = []\r\n\r\n  // Initialize the file explorer\r\n  function initFileExplorer() {\r\n    // Add file explorer CSS\r\n    var link = document.createElement(\"link\")\r\n    link.rel = \"stylesheet\"\r\n    link.href = \"css/file-explorer.css\"\r\n    document.head.appendChild(link)\r\n\r\n    // Get the file explorer element\r\n    var explorerElement = document.querySelector(\"#file-explorer .window-content\")\r\n\r\n    if (!explorerElement) {\r\n      console.error(\"File explorer window content element not found\")\r\n      return\r\n    }\r\n\r\n    // Create the file explorer UI\r\n    explorerElement.innerHTML = `\r\n      <div class=\"file-explorer-toolbar\">\r\n        <button id=\"back-button\">◀ Back</button>\r\n        <button id=\"up-button\">▲ Up</button>\r\n        <button id=\"new-folder-button\">New Folder</button>\r\n        <button id=\"new-file-button\">New File</button>\r\n        <input type=\"text\" class=\"file-explorer-path\" id=\"path-input\" readonly>\r\n      </div>\r\n      <div class=\"file-explorer-container\">\r\n        <div class=\"file-explorer-sidebar\">\r\n          <div class=\"file-explorer-sidebar-item\" data-path=\"C:\">\r\n            <div class=\"file-explorer-sidebar-item-icon\">💾</div>\r\n            <div>C: Drive</div>\r\n          </div>\r\n          <div class=\"file-explorer-sidebar-item\" data-path=\"C:/Documents\">\r\n            <div class=\"file-explorer-sidebar-item-icon\">📁</div>\r\n            <div>Documents</div>\r\n          </div>\r\n          <div class=\"file-explorer-sidebar-item\" data-path=\"C:/Media\">\r\n            <div class=\"file-explorer-sidebar-item-icon\">📁</div>\r\n            <div>Media</div>\r\n          </div>\r\n          <div class=\"file-explorer-sidebar-item\" data-path=\"C:/Games\">\r\n            <div class=\"file-explorer-sidebar-item-icon\">📁</div>\r\n            <div>Games</div>\r\n          </div>\r\n        </div>\r\n        <div class=\"file-explorer-main\">\r\n          <div class=\"file-explorer-items\" id=\"items-container\"></div>\r\n        </div>\r\n      </div>\r\n      <div class=\"file-explorer-status\">0 items</div>\r\n    `\r\n\r\n    // Add event listeners\r\n    document.getElementById(\"back-button\").addEventListener(\"click\", () => {\r\n      alert(\"Back functionality not implemented yet\")\r\n    })\r\n\r\n    document.getElementById(\"up-button\").addEventListener(\"click\", () => {\r\n      if (currentPath.length > 1) {\r\n        currentPath.pop()\r\n        navigateTo(currentPath)\r\n      }\r\n    })\r\n\r\n    document.getElementById(\"new-folder-button\").addEventListener(\"click\", createNewFolder)\r\n    document.getElementById(\"new-file-button\").addEventListener(\"click\", createNewFile)\r\n\r\n    // Add event listeners for sidebar items\r\n    var sidebarItems = document.querySelectorAll(\".file-explorer-sidebar-item\")\r\n    sidebarItems.forEach((item) => {\r\n      item.addEventListener(\"click\", function () {\r\n        var path = this.getAttribute(\"data-path\").split(\"/\")\r\n        navigateTo(path)\r\n      })\r\n    })\r\n\r\n    // Load the initial path\r\n    navigateTo(currentPath)\r\n\r\n    // Load from localStorage if available\r\n    loadFileSystem()\r\n  }\r\n\r\n  // Navigate to a path\r\n  function navigateTo(path) {\r\n    currentPath = path\r\n\r\n    // Update path input\r\n    var pathInput = document.getElementById(\"path-input\")\r\n    pathInput.value = path.join(\"/\")\r\n\r\n    // Get current folder\r\n    var currentFolder = getItemAtPath(path)\r\n\r\n    // If not a folder, navigate to parent\r\n    if (!currentFolder || (currentFolder.type !== \"folder\" && currentFolder.type !== \"drive\")) {\r\n      currentPath.pop()\r\n      currentFolder = getItemAtPath(currentPath)\r\n    }\r\n\r\n    // Clear selection\r\n    selectedItems = []\r\n\r\n    // Update items container\r\n    var itemsContainer = document.getElementById(\"items-container\")\r\n    itemsContainer.innerHTML = \"\"\r\n\r\n    // Add items\r\n    if (currentFolder && (currentFolder.type === \"folder\" || currentFolder.type === \"drive\")) {\r\n      var children = currentFolder.children\r\n\r\n      // Sort items (folders first, then files)\r\n      var sortedItems = Object.keys(children).sort((a, b) => {\r\n        var itemA = children[a]\r\n        var itemB = children[b]\r\n\r\n        if (itemA.type === \"folder\" && itemB.type !== \"folder\") {\r\n          return -1\r\n        } else if (itemA.type !== \"folder\" && itemB.type === \"folder\") {\r\n          return 1\r\n        } else {\r\n          return a.localeCompare(b)\r\n        }\r\n      })\r\n\r\n      // Add items to container\r\n      sortedItems.forEach((itemName) => {\r\n        var item = children[itemName]\r\n\r\n        var iconClass = \"file-icon\"\r\n        var iconSymbol = \"📄\"\r\n\r\n        if (item.type === \"folder\") {\r\n          iconClass = \"folder-icon\"\r\n          iconSymbol = \"📁\"\r\n        } else if (item.icon === \"image\") {\r\n          iconClass = \"image-icon\"\r\n          iconSymbol = \"🖼️\"\r\n        } else if (item.icon === \"audio\") {\r\n          iconClass = \"audio-icon\"\r\n          iconSymbol = \"🎵\"\r\n        } else if (item.icon === \"video\") {\r\n          iconClass = \"video-icon\"\r\n          iconSymbol = \"🎬\"\r\n        }\r\n\r\n        var itemElement = document.createElement(\"div\")\r\n        itemElement.className = \"file-explorer-item\"\r\n        itemElement.setAttribute(\"data-name\", itemName)\r\n        itemElement.setAttribute(\"data-type\", item.type)\r\n        itemElement.innerHTML = `\r\n          <div class=\"file-explorer-item-icon ${iconClass}\">${iconSymbol}</div>\r\n          <div class=\"file-explorer-item-name\">${itemName}</div>\r\n        `\r\n\r\n        // Add event listeners\r\n        itemElement.addEventListener(\"click\", function (e) {\r\n          // If Ctrl key is pressed, toggle selection\r\n          if (e.ctrlKey) {\r\n            toggleItemSelection(this)\r\n          } else {\r\n            // Otherwise, clear selection and select this item\r\n            clearSelection()\r\n            selectItem(this)\r\n          }\r\n        })\r\n\r\n        itemElement.addEventListener(\"dblclick\", () => {\r\n          openItem(itemName)\r\n        })\r\n\r\n        itemsContainer.appendChild(itemElement)\r\n      })\r\n    }\r\n\r\n    // Update status\r\n    updateStatus()\r\n\r\n    // Highlight active sidebar item\r\n    var sidebarItems = document.querySelectorAll(\".file-explorer-sidebar-item\")\r\n    sidebarItems.forEach((item) => {\r\n      var itemPath = item.getAttribute(\"data-path\")\r\n      if (itemPath === currentPath.join(\"/\")) {\r\n        item.classList.add(\"active\")\r\n      } else {\r\n        item.classList.remove(\"active\")\r\n      }\r\n    })\r\n\r\n    // Save file system\r\n    saveFileSystem()\r\n  }\r\n\r\n  // Open an item\r\n  function openItem(itemName) {\r\n    var newPath = currentPath.slice()\r\n    newPath.push(itemName)\r\n    var item = getItemAtPath(newPath)\r\n\r\n    if (item) {\r\n      if (item.type === \"folder\" || item.type === \"drive\") {\r\n        // Navigate to folder\r\n        navigateTo(newPath)\r\n      } else {\r\n        // Open file\r\n        openFile(item, itemName)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Open a file\r\n  function openFile(file, fileName) {\r\n    // Check file extension\r\n    var extension = fileName.split(\".\").pop().toLowerCase()\r\n\r\n    if (extension === \"txt\") {\r\n      // Open text file in a dialog\r\n      showTextFileDialog(fileName, file.content)\r\n    } else if (file.icon === \"image\") {\r\n      // Open image file\r\n      showImageDialog(fileName, file.content)\r\n    } else {\r\n      // Default file handling\r\n      alert(\"Opening file: \" + fileName)\r\n    }\r\n  }\r\n\r\n  // Show text file dialog\r\n  function showTextFileDialog(fileName, content) {\r\n    var dialog = document.createElement(\"div\")\r\n    dialog.className = \"dialog-overlay\"\r\n    dialog.innerHTML = `\r\n      <div class=\"dialog\">\r\n        <div class=\"dialog-title\">${fileName}</div>\r\n        <div class=\"dialog-content\">\r\n          <textarea class=\"dialog-input\" style=\"height: 200px; resize: none;\" readonly>${content}</textarea>\r\n        </div>\r\n        <div class=\"dialog-buttons\">\r\n          <button class=\"dialog-button\" id=\"close-dialog\">Close</button>\r\n        </div>\r\n      </div>\r\n    `\r\n\r\n    document.body.appendChild(dialog)\r\n\r\n    // Add event listener for close button\r\n    document.getElementById(\"close-dialog\").addEventListener(\"click\", () => {\r\n      document.body.removeChild(dialog)\r\n    })\r\n  }\r\n\r\n  // Show image dialog\r\n  function showImageDialog(fileName, url) {\r\n    var dialog = document.createElement(\"div\")\r\n    dialog.className = \"dialog-overlay\"\r\n    dialog.innerHTML = `\r\n      <div class=\"dialog\" style=\"width: auto; max-width: 80vw;\">\r\n        <div class=\"dialog-title\">${fileName}</div>\r\n        <div class=\"dialog-content\" style=\"text-align: center;\">\r\n          <img src=\"${url}\" style=\"max-width: 100%; max-height: 60vh;\" alt=\"${fileName}\">\r\n        </div>\r\n        <div class=\"dialog-buttons\">\r\n          <button class=\"dialog-button\" id=\"close-dialog\">Close</button>\r\n        </div>\r\n      </div>\r\n    `\r\n\r\n    document.body.appendChild(dialog)\r\n\r\n    // Add event listener for close button\r\n    document.getElementById(\"close-dialog\").addEventListener(\"click\", () => {\r\n      document.body.removeChild(dialog)\r\n    })\r\n  }\r\n\r\n  // Create a new folder\r\n  function createNewFolder() {\r\n    var dialog = document.createElement(\"div\")\r\n    dialog.className = \"dialog-overlay\"\r\n    dialog.innerHTML = `\r\n      <div class=\"dialog\">\r\n        <div class=\"dialog-title\">Create New Folder</div>\r\n        <div class=\"dialog-content\">\r\n          <input type=\"text\" class=\"dialog-input\" id=\"folder-name-input\" placeholder=\"Folder Name\">\r\n        </div>\r\n        <div class=\"dialog-buttons\">\r\n          <button class=\"dialog-button\" id=\"cancel-dialog\">Cancel</button>\r\n          <button class=\"dialog-button\" id=\"create-folder\">Create</button>\r\n        </div>\r\n      </div>\r\n    `\r\n\r\n    document.body.appendChild(dialog)\r\n\r\n    // Focus input\r\n    var input = document.getElementById(\"folder-name-input\")\r\n    input.focus()\r\n\r\n    // Add event listeners\r\n    document.getElementById(\"cancel-dialog\").addEventListener(\"click\", () => {\r\n      document.body.removeChild(dialog)\r\n    })\r\n\r\n    document.getElementById(\"create-folder\").addEventListener(\"click\", () => {\r\n      var folderName = input.value.trim()\r\n\r\n      if (folderName) {\r\n        // Create folder\r\n        createFolder(folderName)\r\n        document.body.removeChild(dialog)\r\n      } else {\r\n        alert(\"Please enter a folder name\")\r\n      }\r\n    })\r\n\r\n    // Add event listener for Enter key\r\n    input.addEventListener(\"keydown\", (e) => {\r\n      if (e.key === \"Enter\") {\r\n        document.getElementById(\"create-folder\").click()\r\n      }\r\n    })\r\n  }\r\n\r\n  // Create a new file\r\n  function createNewFile() {\r\n    var dialog = document.createElement(\"div\")\r\n    dialog.className = \"dialog-overlay\"\r\n    dialog.innerHTML = `\r\n      <div class=\"dialog\">\r\n        <div class=\"dialog-title\">Create New File</div>\r\n        <div class=\"dialog-content\">\r\n          <input type=\"text\" class=\"dialog-input\" id=\"file-name-input\" placeholder=\"File Name\">\r\n          <textarea class=\"dialog-input\" id=\"file-content-input\" placeholder=\"File Content\" style=\"height: 150px; resize: none;\"></textarea>\r\n        </div>\r\n        <div class=\"dialog-buttons\">\r\n          <button class=\"dialog-button\" id=\"cancel-dialog\">Cancel</button>\r\n          <button class=\"dialog-button\" id=\"create-file\">Create</button>\r\n        </div>\r\n      </div>\r\n    `\r\n\r\n    document.body.appendChild(dialog)\r\n\r\n    // Focus input\r\n    var input = document.getElementById(\"file-name-input\")\r\n    input.focus()\r\n\r\n    // Add event listeners\r\n    document.getElementById(\"cancel-dialog\").addEventListener(\"click\", () => {\r\n      document.body.removeChild(dialog)\r\n    })\r\n\r\n    document.getElementById(\"create-file\").addEventListener(\"click\", () => {\r\n      var fileName = input.value.trim()\r\n      var fileContent = document.getElementById(\"file-content-input\").value\r\n\r\n      if (fileName) {\r\n        // Create file\r\n        createFile(fileName, fileContent)\r\n        document.body.removeChild(dialog)\r\n      } else {\r\n        alert(\"Please enter a file name\")\r\n      }\r\n    })\r\n\r\n    // Add event listener for Enter key\r\n    input.addEventListener(\"keydown\", (e) => {\r\n      if (e.key === \"Enter\") {\r\n        document.getElementById(\"file-content-input\").focus()\r\n      }\r\n    })\r\n  }\r\n\r\n  // Create a folder\r\n  function createFolder(folderName) {\r\n    // Get current folder\r\n    var currentFolder = getItemAtPath(currentPath)\r\n\r\n    // Check if folder already exists\r\n    if (currentFolder.children[folderName]) {\r\n      alert('A folder or file with the name \"' + folderName + '\" already exists')\r\n      return\r\n    }\r\n\r\n    // Create folder\r\n    currentFolder.children[folderName] = {\r\n      type: \"folder\",\r\n      children: {},\r\n    }\r\n\r\n    // Refresh explorer\r\n    navigateTo(currentPath)\r\n  }\r\n\r\n  // Create a file\r\n  function createFile(fileName, fileContent) {\r\n    // Get current folder\r\n    var currentFolder = getItemAtPath(currentPath)\r\n\r\n    // Check if file already exists\r\n    if (currentFolder.children[fileName]) {\r\n      alert('A folder or file with the name \"' + fileName + '\" already exists')\r\n      return\r\n    }\r\n\r\n    // Determine file icon based on extension\r\n    var fileIcon = \"file\"\r\n    var extension = fileName.split(\".\").pop().toLowerCase()\r\n\r\n    if ([\"jpg\", \"jpeg\", \"png\", \"gif\", \"bmp\"].includes(extension)) {\r\n      fileIcon = \"image\"\r\n    } else if ([\"mp3\", \"wav\", \"ogg\"].includes(extension)) {\r\n      fileIcon = \"audio\"\r\n    } else if ([\"mp4\", \"webm\", \"avi\", \"mov\"].includes(extension)) {\r\n      fileIcon = \"video\"\r\n    }\r\n\r\n    // Create file\r\n    currentFolder.children[fileName] = {\r\n      type: \"file\",\r\n      content: fileContent,\r\n      icon: fileIcon,\r\n    }\r\n\r\n    // Refresh explorer\r\n    navigateTo(currentPath)\r\n  }\r\n\r\n  // Select an item\r\n  function selectItem(itemElement) {\r\n    itemElement.classList.add(\"selected\")\r\n    selectedItems.push(itemElement.getAttribute(\"data-name\"))\r\n    updateStatus()\r\n  }\r\n\r\n  // Toggle item selection\r\n  function toggleItemSelection(itemElement) {\r\n    var itemName = itemElement.getAttribute(\"data-name\")\r\n\r\n    if (itemElement.classList.contains(\"selected\")) {\r\n      // Deselect\r\n      itemElement.classList.remove(\"selected\")\r\n      selectedItems = selectedItems.filter((name) => name !== itemName)\r\n    } else {\r\n      // Select\r\n      itemElement.classList.add(\"selected\")\r\n      selectedItems.push(itemName)\r\n    }\r\n\r\n    updateStatus()\r\n  }\r\n\r\n  // Clear selection\r\n  function clearSelection() {\r\n    var selectedElements = document.querySelectorAll(\".file-explorer-item.selected\")\r\n    selectedElements.forEach((element) => {\r\n      element.classList.remove(\"selected\")\r\n    })\r\n\r\n    selectedItems = []\r\n    updateStatus()\r\n  }\r\n\r\n  // Update status bar\r\n  function updateStatus() {\r\n    var statusBar = document.querySelector(\".file-explorer-status\")\r\n    var itemCount = document.querySelectorAll(\".file-explorer-item\").length\r\n    var selectedCount = selectedItems.length\r\n\r\n    if (selectedCount === 0) {\r\n      statusBar.textContent = itemCount + \" item\" + (itemCount !== 1 ? \"s\" : \"\")\r\n    } else {\r\n      statusBar.textContent = selectedCount + \" of \" + itemCount + \" item\" + (itemCount !== 1 ? \"s\" : \"\") + \" selected\"\r\n    }\r\n  }\r\n\r\n  // Get item at path\r\n  function getItemAtPath(path) {\r\n    var current = fileSystem\r\n\r\n    for (var i = 0; i < path.length; i++) {\r\n      var segment = path[i]\r\n\r\n      if (current[segment]) {\r\n        current = current[segment]\r\n      } else if (current.children && current.children[segment]) {\r\n        current = current.children[segment]\r\n      } else {\r\n        return null\r\n      }\r\n    }\r\n\r\n    return current\r\n  }\r\n\r\n  // Save file system to localStorage\r\n  function saveFileSystem() {\r\n    try {\r\n      localStorage.setItem(\"fileSystem\", JSON.stringify(fileSystem))\r\n    } catch (e) {\r\n      console.error(\"Error saving file system:\", e)\r\n    }\r\n  }\r\n\r\n  // Load file system from localStorage\r\n  function loadFileSystem() {\r\n    try {\r\n      var savedFileSystem = localStorage.getItem(\"fileSystem\")\r\n\r\n      if (savedFileSystem) {\r\n        fileSystem = JSON.parse(savedFileSystem)\r\n      }\r\n    } catch (e) {\r\n      console.error(\"Error loading file system:\", e)\r\n    }\r\n  }\r\n})()\r\n\n\n//# sourceURL=webpack://bbfiller/./src/file-explorer.js?");

/***/ }),

/***/ "./src/folder.js":
/*!***********************!*\
  !*** ./src/folder.js ***!
  \***********************/
/***/ (() => {

eval("document.addEventListener(\"DOMContentLoaded\", () => {\r\n  const folderWindow = document.querySelector(\".folder-window\");\r\n  const folderName = folderWindow.dataset.folderName || \"Folder\";\r\n  folderWindow.querySelector(\".window-header\").textContent = \"📁 \" + folderName;\r\n\r\n  const folderContent = document.getElementById(\"folder-content\");\r\n\r\n  function makeDraggable(icon) {\r\n    icon.setAttribute(\"draggable\", \"true\");\r\n    icon.addEventListener(\"dragstart\", (e) => {\r\n      e.dataTransfer.setData(\"text/plain\", icon.id);\r\n    });\r\n  }\r\n\r\n  function enableDropZone(container) {\r\n    container.addEventListener(\"dragover\", (e) => e.preventDefault());\r\n    container.addEventListener(\"drop\", (e) => {\r\n      e.preventDefault();\r\n      const id = e.dataTransfer.getData(\"text/plain\");\r\n      const icon = document.getElementById(id);\r\n      if (icon && container !== icon.parentElement) {\r\n        container.appendChild(icon);\r\n      }\r\n    });\r\n  }\r\n\r\n  enableDropZone(folderContent);\r\n});\r\n\n\n//# sourceURL=webpack://bbfiller/./src/folder.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _consolidated_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consolidated.js */ \"./src/consolidated.js\");\n/* harmony import */ var _consolidated_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_consolidated_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _accesibility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accesibility.js */ \"./src/accesibility.js\");\n/* harmony import */ var _accesibility_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_accesibility_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _sw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sw.js */ \"./src/sw.js\");\n/* harmony import */ var _sw_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_sw_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _file_explorer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file-explorer.js */ \"./src/file-explorer.js\");\n/* harmony import */ var _file_explorer_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_file_explorer_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _desktop_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./desktop.js */ \"./src/desktop.js\");\n/* harmony import */ var _desktop_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_desktop_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _folder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./folder.js */ \"./src/folder.js\");\n/* harmony import */ var _folder_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_folder_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _lazy_loader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lazy-loader.js */ \"./src/lazy-loader.js\");\n/* harmony import */ var _lazy_loader_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lazy_loader_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _media_loading_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./media-loading.js */ \"./src/media-loading.js\");\n/* harmony import */ var _media_loading_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_media_loading_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _mobile_enhancements_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mobile-enhancements.js */ \"./src/mobile-enhancements.js\");\n/* harmony import */ var _mobile_enhancements_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_mobile_enhancements_js__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_utils_js__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _window_size_fix_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./window-size-fix.js */ \"./src/window-size-fix.js\");\n/* harmony import */ var _window_size_fix_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_window_size_fix_js__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _profile_glitch_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./profile-glitch.js */ \"./src/profile-glitch.js\");\n/* harmony import */ var _profile_glitch_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_profile_glitch_js__WEBPACK_IMPORTED_MODULE_11__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://bbfiller/./src/index.js?");

/***/ }),

/***/ "./src/lazy-loader.js":
/*!****************************!*\
  !*** ./src/lazy-loader.js ***!
  \****************************/
/***/ (() => {

eval("(function() {\r\n\r\n// Lazy loading for videos & iframes\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  const supportsIO = 'IntersectionObserver' in window;\r\n  const ioOptions = { rootMargin: '50px 0px', threshold: 0.1 };\r\n\r\n  // loader knows how to handle video vs iframe\r\n  const loadMedia = el => {\r\n    const src = el.dataset.src;\r\n    if (!src) return;\r\n    console.log(`Loading ${el.tagName.toLowerCase()}: ${src}`);\r\n    el.src = src;\r\n    if (el.tagName === 'VIDEO') el.load();\r\n  };\r\n\r\n  // collect both videos and iframes in one go\r\n  const lazyEls = [\r\n    ...document.querySelectorAll('video[data-src]'),\r\n    ...document.querySelectorAll('iframe[data-src]')\r\n  ];\r\n\r\n  if (supportsIO) {\r\n    const observer = new IntersectionObserver((entries, obs) => {\r\n      entries.forEach(({ isIntersecting, target }) => {\r\n        if (isIntersecting) {\r\n          loadMedia(target);\r\n          obs.unobserve(target);\r\n        }\r\n      });\r\n    }, ioOptions);\r\n    lazyEls.forEach(el => observer.observe(el));\r\n  } else {\r\n    // fallback: load everything immediately\r\n    lazyEls.forEach(loadMedia);\r\n  }\r\n\r\n  // also load media when a window is opened\r\n  document.querySelectorAll('[data-window]').forEach(icon => {\r\n    icon.addEventListener('click', () => {\r\n      const win = document.getElementById(icon.dataset.window);\r\n      if (!win) return;\r\n      win.querySelectorAll('video[data-src],iframe[data-src]').forEach(el => {\r\n        if (!el.src) {\r\n          setTimeout(() => loadMedia(el), 500);\r\n        }\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\n})();\n\n//# sourceURL=webpack://bbfiller/./src/lazy-loader.js?");

/***/ }),

/***/ "./src/media-loading.js":
/*!******************************!*\
  !*** ./src/media-loading.js ***!
  \******************************/
/***/ (() => {

eval("(function() {\r\n\r\n(() => {\r\n  const log = (...msgs) => console.log('🎬', ...msgs);\r\n\r\n  // Helper: detect empty/invalid src\r\n  const isInvalidSrc = src =>\r\n    !src || ['undefined', 'null'].includes(src.trim());\r\n\r\n  // Helper: generate a simple SVG poster\r\n  const makePoster = (text, color = '#00ffff') =>\r\n    `data:image/svg+xml,%3Csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"320\" height=\"240\"%3E` +\r\n    `%3Crect width=\"320\" height=\"240\" fill=\"%23000\"/%3E` +\r\n    `%3Ctext x=\"50%25\" y=\"50%25\" font-family=\"monospace\" font-size=\"14\" text-anchor=\"middle\" fill=\"${encodeURIComponent(color)}\"%3E` +\r\n    `${encodeURIComponent(text)}%3C/text%3E%3C/svg%3E`;\r\n\r\n  // Add a one-time error handler to an element\r\n  const ensureErrorHandler = (el, onError) => {\r\n    if (!el.dataset.errorHandler) {\r\n      el.addEventListener('error', onError);\r\n      el.dataset.errorHandler = 'true';\r\n    }\r\n  };\r\n\r\n  // Core fixer for <video> and <audio>\r\n  const fixMedia = el => {\r\n    try {\r\n      const { tagName, src } = el;\r\n      // 1) Clean up bad src\r\n      if (isInvalidSrc(src)) {\r\n        el.removeAttribute('src');\r\n        if (tagName === 'VIDEO' && !el.querySelector('source')) {\r\n          el.poster ||= makePoster('No Video');\r\n        }\r\n      }\r\n\r\n      // 2) Attach error handler\r\n      ensureErrorHandler(el, e => {\r\n        const msg = e.target.error?.message || 'Unknown error';\r\n        log(`${tagName.toLowerCase()} error:`, msg);\r\n        if (tagName === 'VIDEO' && !el.poster) {\r\n          el.poster = makePoster('Error', '#ff0000');\r\n        }\r\n      });\r\n\r\n      // 3) Tame autoplay policies\r\n      if (el.hasAttribute('autoplay')) {\r\n        el.muted = true;\r\n        el.playsInline = true;\r\n      }\r\n\r\n      // 4) If it’s a video, explicitly call load() after a new src\r\n      if (tagName === 'VIDEO' && el.src && el.autoplay) {\r\n        requestAnimationFrame(() => el.load());\r\n      }\r\n    } catch (err) {\r\n      console.error('Media fix failed for', el, err);\r\n    }\r\n  };\r\n\r\n  // Observe any added <video> or <audio>\r\n  const initMutationObserver = () => {\r\n    const mo = new MutationObserver(muts => {\r\n      muts.forEach(m => {\r\n        m.addedNodes.forEach(node => {\r\n          if (!(node instanceof Element)) return;\r\n          if (['VIDEO','AUDIO'].includes(node.tagName)) {\r\n            fixMedia(node);\r\n          }\r\n          node.querySelectorAll('video,audio').forEach(fixMedia);\r\n        });\r\n      });\r\n    });\r\n    mo.observe(document.body, { childList: true, subtree: true });\r\n  };\r\n\r\n  // Wrap your window-open to re-fix media in newly created windows\r\n  const overrideWindowOpen = () => {\r\n    if (typeof window.openWindow !== 'function') return;\r\n    const original = window.openWindow;\r\n    window.openWindow = id => {\r\n      const win = original(id);\r\n      if (win) {\r\n        // small delay to let content render\r\n        setTimeout(() => {\r\n          win.querySelectorAll('video,audio').forEach(fixMedia);\r\n          log(`Checked media in window:`, id);\r\n        }, 100);\r\n      }\r\n      return win;\r\n    };\r\n  };\r\n\r\n  // Bootstrap on DOM ready\r\n  document.addEventListener('DOMContentLoaded', () => {\r\n    log('Initializing Media Loading Fix…');\r\n    // 1) Fix existing media\r\n    document.querySelectorAll('video,audio').forEach(fixMedia);\r\n    // 2) Watch for future media\r\n    initMutationObserver();\r\n    // 3) Wrap window-open hook\r\n    overrideWindowOpen();\r\n    log('Media Loading Fix initialized');\r\n  });\r\n})();\r\n\r\n})();\n\n//# sourceURL=webpack://bbfiller/./src/media-loading.js?");

/***/ }),

/***/ "./src/mobile-enhancements.js":
/*!************************************!*\
  !*** ./src/mobile-enhancements.js ***!
  \************************************/
/***/ (() => {

eval("(function() {\r\n\r\n/**\r\n * Mobile & Responsive Enhancements\r\n * Improves the experience on mobile devices\r\n */\r\ndocument.addEventListener(\"DOMContentLoaded\", function() {\r\n  console.log(\"📱 Initializing Mobile Enhancements...\");\r\n  \r\n  // Configuration\r\n  const config = {\r\n    // Breakpoints\r\n    breakpoints: {\r\n      mobile: 768,\r\n      tablet: 1024\r\n    },\r\n    \r\n    // Touch settings\r\n    touch: {\r\n      tapThreshold: 10, // px\r\n      doubleTapDelay: 300, // ms\r\n      longPressDelay: 500, // ms\r\n      dragThreshold: 5 // px\r\n    }\r\n  };\r\n  \r\n  // State\r\n  const state = {\r\n    isMobile: false,\r\n    isTablet: false,\r\n    touchStartX: 0,\r\n    touchStartY: 0,\r\n    touchStartTime: 0,\r\n    lastTapTime: 0,\r\n    isDragging: false,\r\n    longPressTimer: null,\r\n    currentLayout: 'desktop'\r\n  };\r\n  \r\n  // Initialize mobile enhancements\r\n  function initMobileEnhancements() {\r\n    // Check device type\r\n    checkDeviceType();\r\n    \r\n    // Add viewport meta tag if missing\r\n    addViewportMeta();\r\n    \r\n    // Add touch event handlers\r\n    addTouchHandlers();\r\n    \r\n    // Add resize handler\r\n    window.addEventListener(\"resize\", handleResize);\r\n    \r\n    // Initial layout adjustment\r\n    adjustLayout();\r\n    \r\n    console.log(`📱 Mobile Enhancements initialized (${state.currentLayout} mode)`);\r\n  }\r\n  \r\n  // Check device type\r\n  function checkDeviceType() {\r\n    const width = window.innerWidth;\r\n    state.isMobile = width <= config.breakpoints.mobile;\r\n    state.isTablet = width > config.breakpoints.mobile && width <= config.breakpoints.tablet;\r\n    \r\n    // Set layout mode\r\n    if (state.isMobile) {\r\n      state.currentLayout = 'mobile';\r\n    } else if (state.isTablet) {\r\n      state.currentLayout = 'tablet';\r\n    } else {\r\n      state.currentLayout = 'desktop';\r\n    }\r\n    \r\n    // Add class to body\r\n    document.body.classList.remove('layout-mobile', 'layout-tablet', 'layout-desktop');\r\n    document.body.classList.add(`layout-${state.currentLayout}`);\r\n  }\r\n  \r\n  // Add viewport meta tag if missing\r\n  function addViewportMeta() {\r\n    if (!document.querySelector('meta[name=\"viewport\"]')) {\r\n      const meta = document.createElement('meta');\r\n      meta.name = 'viewport';\r\n      meta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';\r\n      document.head.appendChild(meta);\r\n      console.log(\"📱 Added viewport meta tag\");\r\n    }\r\n  }\r\n  \r\n  // Add touch event handlers\r\n  function addTouchHandlers() {\r\n    // Desktop icons\r\n    document.querySelectorAll(\".desktop-icon\").forEach(icon => {\r\n      icon.addEventListener(\"touchstart\", handleTouchStart);\r\n      icon.addEventListener(\"touchmove\", handleTouchMove);\r\n      icon.addEventListener(\"touchend\", handleTouchEnd);\r\n    });\r\n    \r\n    // Windows\r\n    document.querySelectorAll(\".popup-window\").forEach(win => {\r\n      // Window headers for dragging\r\n      const header = win.querySelector(\".window-header\");\r\n      if (header) {\r\n        header.addEventListener(\"touchstart\", handleWindowTouchStart);\r\n        header.addEventListener(\"touchmove\", handleWindowTouchMove);\r\n        header.addEventListener(\"touchend\", handleWindowTouchEnd);\r\n      }\r\n      \r\n      // Window content for scrolling\r\n      const content = win.querySelector(\".window-content\");\r\n      if (content) {\r\n        content.addEventListener(\"touchstart\", (e) => {\r\n          // Allow default behavior for scrolling\r\n          e.stopPropagation();\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Taskbar\r\n    const taskbar = document.getElementById(\"start-bar\");\r\n    if (taskbar) {\r\n      taskbar.addEventListener(\"touchstart\", (e) => {\r\n        // Prevent default to avoid triggering clicks on desktop\r\n        e.stopPropagation();\r\n      });\r\n    }\r\n  }\r\n  \r\n  // Handle touch start on desktop icons\r\n  function handleTouchStart(e) {\r\n    // Store touch start position and time\r\n    state.touchStartX = e.touches[0].clientX;\r\n    state.touchStartY = e.touches[0].clientY;\r\n    state.touchStartTime = Date.now();\r\n    state.isDragging = false;\r\n    \r\n    // Set up long press timer\r\n    state.longPressTimer = setTimeout(() => {\r\n      // Trigger long press\r\n      handleLongPress(e);\r\n    }, config.touch.longPressDelay);\r\n  }\r\n  \r\n  // Handle touch move on desktop icons\r\n  function handleTouchMove(e) {\r\n    // Check if dragging\r\n    const touchX = e.touches[0].clientX;\r\n    const touchY = e.touches[0].clientY;\r\n    const deltaX = Math.abs(touchX - state.touchStartX);\r\n    const deltaY = Math.abs(touchY - state.touchStartY);\r\n    \r\n    // If moved beyond threshold, cancel long press and mark as dragging\r\n    if (deltaX > config.touch.dragThreshold || deltaY > config.touch.dragThreshold) {\r\n      clearTimeout(state.longPressTimer);\r\n      state.isDragging = true;\r\n    }\r\n  }\r\n  \r\n  // Handle touch end on desktop icons\r\n  function handleTouchEnd(e) {\r\n    // Clear long press timer\r\n    clearTimeout(state.longPressTimer);\r\n    \r\n    // If not dragging, handle as tap\r\n    if (!state.isDragging) {\r\n      const touchEndTime = Date.now();\r\n      const touchDuration = touchEndTime - state.touchStartTime;\r\n      \r\n      // Check for double tap\r\n      if (touchEndTime - state.lastTapTime < config.touch.doubleTapDelay) {\r\n        // Handle double tap\r\n        handleDoubleTap(e);\r\n        state.lastTapTime = 0; // Reset to prevent triple tap\r\n      } else {\r\n        // Handle single tap\r\n        handleTap(e);\r\n        state.lastTapTime = touchEndTime;\r\n      }\r\n    }\r\n    \r\n    // Reset state\r\n    state.isDragging = false;\r\n  }\r\n  \r\n  // Handle tap on desktop icons\r\n  function handleTap(e) {\r\n    const icon = e.currentTarget;\r\n    \r\n    // Get window ID\r\n    const windowId = icon.getAttribute(\"data-window\") || icon.id.replace(\"icon-\", \"\");\r\n    \r\n    // Open window\r\n    if (typeof openWindow === 'function') {\r\n      openWindow(windowId);\r\n    }\r\n  }\r\n  \r\n  // Handle double tap on desktop icons\r\n  function handleDoubleTap(e) {\r\n    // Same as single tap for now\r\n    handleTap(e);\r\n  }\r\n  \r\n  // Handle long press on desktop icons\r\n  function handleLongPress(e) {\r\n    // Show context menu if available\r\n    const icon = e.currentTarget;\r\n    \r\n    // Create simple context menu if not exists\r\n    let contextMenu = document.getElementById(\"mobile-context-menu\");\r\n    if (!contextMenu) {\r\n      contextMenu = document.createElement(\"div\");\r\n      contextMenu.id = \"mobile-context-menu\";\r\n      contextMenu.style.position = \"fixed\";\r\n      contextMenu.style.backgroundColor = \"rgba(0, 0, 0, 0.9)\";\r\n      contextMenu.style.border = \"1px solid #00ffff\";\r\n      contextMenu.style.borderRadius = \"5px\";\r\n      contextMenu.style.padding = \"10px\";\r\n      contextMenu.style.zIndex = \"10000\";\r\n      document.body.appendChild(contextMenu);\r\n      \r\n      // Close on tap outside\r\n      document.addEventListener(\"touchstart\", (e) => {\r\n        if (contextMenu.style.display === \"block\" && !contextMenu.contains(e.target)) {\r\n          contextMenu.style.display = \"none\";\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Get window ID\r\n    const windowId = icon.getAttribute(\"data-window\") || icon.id.replace(\"icon-\", \"\");\r\n    \r\n    // Clear existing menu items\r\n    contextMenu.innerHTML = \"\";\r\n    \r\n    // Add menu items\r\n    addContextMenuItem(contextMenu, \"Open\", () => {\r\n      if (typeof openWindow === 'function') {\r\n        openWindow(windowId);\r\n      }\r\n      contextMenu.style.display = \"none\";\r\n    });\r\n    \r\n    // Position menu near the icon\r\n    const rect = icon.getBoundingClientRect();\r\n    contextMenu.style.left = `${rect.left}px`;\r\n    contextMenu.style.top = `${rect.bottom + 10}px`;\r\n    \r\n    // Show menu\r\n    contextMenu.style.display = \"block\";\r\n  }\r\n  \r\n  // Add context menu item\r\n  function addContextMenuItem(menu, text, action) {\r\n    const item = document.createElement(\"div\");\r\n    item.textContent = text;\r\n    item.style.padding = \"10px\";\r\n    item.style.color = \"#00ffff\";\r\n    item.style.fontFamily = \"'VT323', monospace\";\r\n    item.style.fontSize = \"16px\";\r\n    item.style.cursor = \"pointer\";\r\n    \r\n    // Add hover effect\r\n    item.addEventListener(\"mouseover\", () => {\r\n      item.style.backgroundColor = \"rgba(0, 255, 255, 0.2)\";\r\n    });\r\n    \r\n    item.addEventListener(\"mouseout\", () => {\r\n      item.style.backgroundColor = \"transparent\";\r\n    });\r\n    \r\n    // Add click handler\r\n    item.addEventListener(\"click\", action);\r\n    \r\n    // Add to menu\r\n    menu.appendChild(item);\r\n    \r\n    return item;\r\n  }\r\n  \r\n  // Handle touch start on window headers\r\n  function handleWindowTouchStart(e) {\r\n    // Store touch start position and time\r\n    state.touchStartX = e.touches[0].clientX;\r\n    state.touchStartY = e.touches[0].clientY;\r\n    state.touchStartTime = Date.now();\r\n    state.isDragging = false;\r\n    \r\n    // Get window\r\n    const header = e.currentTarget;\r\n    const win = header.closest(\".popup-window\");\r\n    \r\n    // Focus window\r\n    if (win && typeof focusWindow === 'function') {\r\n      focusWindow(win.id);\r\n    }\r\n    \r\n    // Set up long press timer\r\n    state.longPressTimer = setTimeout(() => {\r\n      // Trigger long press\r\n      handleWindowLongPress(e);\r\n    }, config.touch.longPressDelay);\r\n  }\r\n  \r\n  // Handle touch move on window headers\r\n  function handleWindowTouchMove(e) {\r\n    // Check if dragging\r\n    const touchX = e.touches[0].clientX;\r\n    const touchY = e.touches[0].clientY;\r\n    const deltaX = Math.abs(touchX - state.touchStartX);\r\n    const deltaY = Math.abs(touchY - state.touchStartY);\r\n    \r\n    // If moved beyond threshold, cancel long press and mark as dragging\r\n    if (deltaX > config.touch.dragThreshold || deltaY > config.touch.dragThreshold) {\r\n      clearTimeout(state.longPressTimer);\r\n      state.isDragging = true;\r\n      \r\n      // Get window\r\n      const header = e.currentTarget;\r\n      const win = header.closest(\".popup-window\");\r\n      \r\n      // Move window\r\n      if (win) {\r\n        // Calculate new position\r\n        const dx = touchX - state.touchStartX;\r\n        const dy = touchY - state.touchStartY;\r\n        \r\n        const left = parseInt(win.style.left || 0) + dx;\r\n        const top = parseInt(win.style.top || 0) + dy;\r\n        \r\n        // Apply new position\r\n        win.style.left = `${left}px`;\r\n        win.style.top = `${top}px`;\r\n        \r\n        // Update touch start position\r\n        state.touchStartX = touchX;\r\n        state.touchStartY = touchY;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Handle touch end on window headers\r\n  function handleWindowTouchEnd(e) {\r\n    // Clear long press timer\r\n    clearTimeout(state.longPressTimer);\r\n    \r\n    // If not dragging, handle as tap\r\n    if (!state.isDragging) {\r\n      const touchEndTime = Date.now();\r\n      \r\n      // Check for double tap\r\n      if (touchEndTime - state.lastTapTime < config.touch.doubleTapDelay) {\r\n        // Handle double tap\r\n        handleWindowDoubleTap(e);\r\n        state.lastTapTime = 0; // Reset to prevent triple tap\r\n      } else {\r\n        // Handle single tap\r\n        handleWindowTap(e);\r\n        state.lastTapTime = touchEndTime;\r\n      }\r\n    }\r\n    \r\n    // Reset state\r\n    state.isDragging = false;\r\n  }\r\n  \r\n  // Handle tap on window headers\r\n  function handleWindowTap(e) {\r\n    // Just focus the window\r\n    const header = e.currentTarget;\r\n    const win = header.closest(\".popup-window\");\r\n    \r\n    if (win && typeof focusWindow === 'function') {\r\n      focusWindow(win.id);\r\n    }\r\n  }\r\n  \r\n  // Handle double tap on window headers\r\n  function handleWindowDoubleTap(e) {\r\n    // Toggle maximize\r\n    const header = e.currentTarget;\r\n    const win = header.closest(\".popup-window\");\r\n    \r\n    if (win && typeof toggleMaximize === 'function') {\r\n      toggleMaximize(win.id);\r\n    }\r\n  }\r\n  \r\n  // Handle long press on window headers\r\n  function handleWindowLongPress(e) {\r\n    // Show window context menu\r\n    const header = e.currentTarget;\r\n    const win = header.closest(\".popup-window\");\r\n    \r\n    if (!win) return;\r\n    \r\n    // Create window context menu if not exists\r\n    let contextMenu = document.getElementById(\"window-context-menu\");\r\n    if (!contextMenu) {\r\n      contextMenu = document.createElement(\"div\");\r\n      contextMenu.id = \"window-context-menu\";\r\n      contextMenu.style.position = \"fixed\";\r\n      contextMenu.style.backgroundColor = \"rgba(0, 0, 0, 0.9)\";\r\n      contextMenu.style.border = \"1px solid #00ffff\";\r\n      contextMenu.style.borderRadius = \"5px\";\r\n      contextMenu.style.padding = \"10px\";\r\n      contextMenu.style.zIndex = \"10000\";\r\n      document.body.appendChild(contextMenu);\r\n      \r\n      // Close on tap outside\r\n      document.addEventListener(\"touchstart\", (e) => {\r\n        if (contextMenu.style.display === \"block\" && !contextMenu.contains(e.target)) {\r\n          contextMenu.style.display = \"none\";\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Clear existing menu items\r\n    contextMenu.innerHTML = \"\";\r\n    \r\n    // Add menu items\r\n    addContextMenuItem(contextMenu, \"Minimize\", () => {\r\n      if (typeof minimizeWindow === 'function') {\r\n        minimizeWindow(win.id);\r\n      }\r\n      contextMenu.style.display = \"none\";\r\n    });\r\n    \r\n    addContextMenuItem(contextMenu, \"Maximize\", () => {\r\n      if (typeof toggleMaximize === 'function') {\r\n        toggleMaximize(win.id);\r\n      }\r\n      contextMenu.style.display = \"none\";\r\n    });\r\n    \r\n    addContextMenuItem(contextMenu, \"Close\", () => {\r\n      if (typeof closeWindow === 'function') {\r\n        closeWindow(win.id);\r\n      }\r\n      contextMenu.style.display = \"none\";\r\n    });\r\n    \r\n    // Position menu near the header\r\n    const rect = header.getBoundingClientRect();\r\n    contextMenu.style.left = `${rect.left}px`;\r\n    contextMenu.style.top = `${rect.bottom + 10}px`;\r\n    \r\n    // Show menu\r\n    contextMenu.style.display = \"block\";\r\n  }\r\n  \r\n  // Handle resize\r\n  function handleResize() {\r\n    // Check device type\r\n    checkDeviceType();\r\n    \r\n    // Adjust layout\r\n    adjustLayout();\r\n  }\r\n  \r\n  // Adjust layout based on device type\r\n  function adjustLayout() {\r\n    if (state.isMobile) {\r\n      // Mobile layout adjustments\r\n      adjustMobileLayout();\r\n    } else if (state.isTablet) {\r\n      // Tablet layout adjustments\r\n      adjustTabletLayout();\r\n    } else {\r\n      // Desktop layout adjustments\r\n      adjustDesktopLayout();\r\n    }\r\n  }\r\n  \r\n  // Adjust layout for mobile\r\n  function adjustMobileLayout() {\r\n    // Make windows full screen when opened\r\n    if (typeof window.openWindow === 'function') {\r\n      const originalOpenWindow = window.openWindow;\r\n      \r\n      window.openWindow = function(id) {\r\n        const win = originalOpenWindow(id);\r\n        \r\n        if (win) {\r\n          // Make window full screen\r\n          win.style.width = \"100%\";\r\n          win.style.height = \"calc(100% - 40px)\"; // Leave space for taskbar\r\n          win.style.left = \"0\";\r\n          win.style.top = \"0\";\r\n          \r\n          // Add mobile class\r\n          win.classList.add(\"mobile-window\");\r\n        }\r\n        \r\n        return win;\r\n      };\r\n    }\r\n    \r\n    // Adjust existing windows\r\n    document.querySelectorAll(\".popup-window\").forEach(win => {\r\n      // Make window full screen\r\n      win.style.width = \"100%\";\r\n      win.style.height = \"calc(100% - 40px)\"; // Leave space for taskbar\r\n      win.style.left = \"0\";\r\n      win.style.top = \"0\";\r\n      \r\n      // Add mobile class\r\n      win.classList.add(\"mobile-window\");\r\n    });\r\n    \r\n    // Adjust desktop icons for mobile\r\n    document.querySelectorAll(\".desktop-icon\").forEach(icon => {\r\n      // Make icons larger and more touch-friendly\r\n      icon.style.width = \"80px\";\r\n      icon.style.height = \"80px\";\r\n      icon.style.margin = \"10px\";\r\n    });\r\n    \r\n    // Adjust taskbar for mobile\r\n    const taskbar = document.getElementById(\"start-bar\");\r\n    if (taskbar) {\r\n      taskbar.style.height = \"50px\"; // Taller for touch\r\n    }\r\n  }\r\n  \r\n  // Adjust layout for tablet\r\n  function adjustTabletLayout() {\r\n    // Make windows larger but not full screen\r\n    if (typeof window.openWindow === 'function') {\r\n      const originalOpenWindow = window.openWindow;\r\n      \r\n      window.openWindow = function(id) {\r\n        const win = originalOpenWindow(id);\r\n        \r\n        if (win) {\r\n          // Make window larger\r\n          win.style.width = \"80%\";\r\n          win.style.height = \"80%\";\r\n          \r\n          // Center window\r\n          win.style.left = \"10%\";\r\n          win.style.top = \"10%\";\r\n          \r\n          // Add tablet class\r\n          win.classList.add(\"tablet-window\");\r\n        }\r\n        \r\n        return win;\r\n      };\r\n    }\r\n    \r\n    // Adjust existing windows\r\n    document.querySelectorAll(\".popup-window\").forEach(win => {\r\n      // Make window larger\r\n      win.style.width = \"80%\";\r\n      win.style.height = \"80%\";\r\n      \r\n      // Center window\r\n      win.style.left = \"10%\";\r\n      win.style.top = \"10%\";\r\n      \r\n      // Add tablet class\r\n      win.classList.add(\"tablet-window\");\r\n    });\r\n    \r\n    // Adjust desktop icons for tablet\r\n    document.querySelectorAll(\".desktop-icon\").forEach(icon => {\r\n      // Make icons slightly larger\r\n      icon.style.width = \"70px\";\r\n      icon.style.height = \"70px\";\r\n      icon.style.margin = \"8px\";\r\n    });\r\n  }\r\n  \r\n  // Adjust layout for desktop\r\n  function adjustDesktopLayout() {\r\n    // Restore windows to their original size and position\r\n    document.querySelectorAll(\".popup-window\").forEach(win => {\r\n      // Remove mobile/tablet classes\r\n      win.classList.remove(\"mobile-window\", \"tablet-window\");\r\n    });\r\n    \r\n    // Restore desktop icons\r\n    document.querySelectorAll(\".desktop-icon\").forEach(icon => {\r\n      // Reset to default size\r\n      icon.style.width = \"\";\r\n      icon.style.height = \"\";\r\n      icon.style.margin = \"\";\r\n    });\r\n    \r\n    // Restore taskbar\r\n    const taskbar = document.getElementById(\"start-bar\");\r\n    if (taskbar) {\r\n      taskbar.style.height = \"\";\r\n    }\r\n  }\r\n  \r\n  // Initialize after a short delay\r\n  setTimeout(initMobileEnhancements, 1000);\r\n});\r\n\r\n})();\n\n//# sourceURL=webpack://bbfiller/./src/mobile-enhancements.js?");

/***/ }),

/***/ "./src/profile-glitch.js":
/*!*******************************!*\
  !*** ./src/profile-glitch.js ***!
  \*******************************/
/***/ (() => {

eval("(function() {\r\n\r\n// ULTRA TRIPPY PROFILE IMAGE EFFECTS\r\ndocument.addEventListener(\"DOMContentLoaded\", function() {\r\n  console.log(\"🌀 Initializing extreme profile image effects\");\r\n  \r\n  // Wait for the profile image to be created by boot-sequence.js\r\n  const checkForProfileImage = setInterval(() => {\r\n    const profileImage = document.querySelector(\".profile-image\");\r\n    const glowEffect = document.querySelector(\".image-glow-effect\");\r\n    \r\n    if (profileImage && glowEffect) {\r\n      clearInterval(checkForProfileImage);\r\n      initTrippyProfileEffects(profileImage, glowEffect);\r\n    }\r\n  }, 100);\r\n  \r\n  function initTrippyProfileEffects(profileImage, glowEffect) {\r\n    console.log(\"🌈 Applying extreme trippy effects to profile image\");\r\n    \r\n    // Create a container for the fractal overlay\r\n    const fractalOverlay = document.createElement(\"div\");\r\n    fractalOverlay.classList.add(\"fractal-overlay\");\r\n    profileImage.parentNode.appendChild(fractalOverlay);\r\n    \r\n    // Create multiple clone layers for the glitch effect\r\n    const layers = 30; // Number of glitch layers\r\n    const glitchLayers = [];\r\n    \r\n    for (let i = 0; i < layers; i++) {\r\n      const layer = document.createElement(\"div\");\r\n      layer.classList.add(\"profile-glitch-layer\");\r\n      layer.style.zIndex = 2 + i;\r\n      layer.style.opacity = 0.7 - (i * 0.1);\r\n      \r\n      // Create image inside layer\r\n      const layerImg = document.createElement(\"img\");\r\n      layerImg.src = profileImage.src;\r\n      layerImg.classList.add(\"layer-img\");\r\n      layer.appendChild(layerImg);\r\n      \r\n      // Add to DOM before the original image\r\n      profileImage.parentNode.insertBefore(layer, profileImage);\r\n      glitchLayers.push(layer);\r\n    }\r\n    \r\n    // Create a canvas for pixel manipulation effects\r\n    const pixelCanvas = document.createElement(\"canvas\");\r\n    pixelCanvas.width = 150;\r\n    pixelCanvas.height = 150;\r\n    pixelCanvas.classList.add(\"pixel-manipulation-canvas\");\r\n    profileImage.parentNode.appendChild(pixelCanvas);\r\n    \r\n    const ctx = pixelCanvas.getContext(\"2d\");\r\n    \r\n    // Load the image into the canvas\r\n    const pixelImg = new Image();\r\n    pixelImg.crossOrigin = \"anonymous\";\r\n    pixelImg.src = profileImage.src;\r\n    pixelImg.onload = function() {\r\n      ctx.drawImage(pixelImg, 0, 0, pixelCanvas.width, pixelCanvas.height);\r\n      // Start pixel manipulation\r\n      requestAnimationFrame(manipulatePixels);\r\n    };\r\n    \r\n    // Create geometric shapes overlay\r\n    const geoShapes = document.createElement(\"div\");\r\n    geoShapes.classList.add(\"geometric-shapes\");\r\n    profileImage.parentNode.appendChild(geoShapes);\r\n    \r\n    // Add shapes\r\n    for (let i = 0; i < 15; i++) {\r\n      const shape = document.createElement(\"div\");\r\n      shape.classList.add(\"geo-shape\");\r\n      \r\n      // Randomize shape type\r\n      const shapeType = Math.floor(Math.random() * 3);\r\n      if (shapeType === 0) {\r\n        shape.classList.add(\"geo-circle\");\r\n      } else if (shapeType === 1) {\r\n        shape.classList.add(\"geo-triangle\");\r\n      } else {\r\n        shape.classList.add(\"geo-square\");\r\n      }\r\n      \r\n      // Randomize position\r\n      shape.style.left = `${Math.random() * 100}%`;\r\n      shape.style.top = `${Math.random() * 100}%`;\r\n      \r\n      // Randomize size\r\n      const size = 5 + Math.random() * 20;\r\n      shape.style.width = `${size}px`;\r\n      shape.style.height = `${size}px`;\r\n      \r\n      // Randomize animation delay\r\n      shape.style.animationDelay = `${Math.random() * 5}s`;\r\n      \r\n      geoShapes.appendChild(shape);\r\n    }\r\n    \r\n    // Apply extreme glitch effects at random intervals\r\n    setInterval(() => {\r\n      if (Math.random() < 0.4) { // Increased probability for more frequent glitches\r\n        applyExtremeGlitch();\r\n      }\r\n    }, 1000);\r\n    \r\n    // Apply continuous subtle glitch\r\n    setInterval(() => {\r\n      applySubtleGlitch();\r\n    }, 100);\r\n    \r\n    // Apply color cycle effect\r\n    let hueRotation = 0;\r\n    setInterval(() => {\r\n      hueRotation = (hueRotation + 10) % 360;\r\n      glowEffect.style.filter = `hue-rotate(${hueRotation}deg)`;\r\n    }, 200);\r\n    \r\n    // Pixel manipulation function\r\n    function manipulatePixels() {\r\n      // Only manipulate sometimes for performance\r\n      if (Math.random() < 0.3) {\r\n        // Get image data\r\n        const imageData = ctx.getImageData(0, 0, pixelCanvas.width, pixelCanvas.height);\r\n        const data = imageData.data;\r\n        \r\n        // Apply different effects based on random choice\r\n        const effectChoice = Math.floor(Math.random() * 5);\r\n        \r\n        if (effectChoice === 0) {\r\n          // RGB shift\r\n          for (let i = 0; i < data.length; i += 4) {\r\n            // Shift red channel\r\n            if (i + 4 < data.length) {\r\n              data[i] = data[i + 4];\r\n            }\r\n            // Shift blue channel\r\n            if (i - 4 >= 0) {\r\n              data[i + 2] = data[i - 4 + 2];\r\n            }\r\n          }\r\n        } else if (effectChoice === 1) {\r\n          // Pixelate sections\r\n          const blockSize = Math.floor(Math.random() * 10) + 5;\r\n          for (let y = 0; y < pixelCanvas.height; y += blockSize) {\r\n            for (let x = 0; x < pixelCanvas.width; x += blockSize) {\r\n              // Only pixelate some blocks\r\n              if (Math.random() < 0.5) {\r\n                // Get the color of the first pixel in the block\r\n                const i = (y * pixelCanvas.width + x) * 4;\r\n                const r = data[i];\r\n                const g = data[i + 1];\r\n                const b = data[i + 2];\r\n                \r\n                // Apply to all pixels in the block\r\n                for (let by = 0; by < blockSize && y + by < pixelCanvas.height; by++) {\r\n                  for (let bx = 0; bx < blockSize && x + bx < pixelCanvas.width; bx++) {\r\n                    const idx = ((y + by) * pixelCanvas.width + (x + bx)) * 4;\r\n                    data[idx] = r;\r\n                    data[idx + 1] = g;\r\n                    data[idx + 2] = b;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else if (effectChoice === 2) {\r\n          // Wave distortion\r\n          const amplitude = Math.random() * 10;\r\n          const frequency = Math.random() * 0.1;\r\n          \r\n          const tempCanvas = document.createElement('canvas');\r\n          tempCanvas.width = pixelCanvas.width;\r\n          tempCanvas.height = pixelCanvas.height;\r\n          const tempCtx = tempCanvas.getContext('2d');\r\n          tempCtx.putImageData(imageData, 0, 0);\r\n          \r\n          ctx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);\r\n          \r\n          for (let y = 0; y < pixelCanvas.height; y++) {\r\n            const xOffset = Math.sin(y * frequency) * amplitude;\r\n            ctx.drawImage(\r\n              tempCanvas, \r\n              0, y, pixelCanvas.width, 1, \r\n              xOffset, y, pixelCanvas.width, 1\r\n            );\r\n          }\r\n          \r\n          // Skip the putImageData since we've already drawn the distorted image\r\n          requestAnimationFrame(manipulatePixels);\r\n          return;\r\n        } else if (effectChoice === 3) {\r\n          // Color inversion in sections\r\n          for (let i = 0; i < data.length; i += 4) {\r\n            // Only invert some pixels\r\n            if (Math.random() < 0.2) {\r\n              data[i] = 255 - data[i];         // Invert red\r\n              data[i + 1] = 255 - data[i + 1]; // Invert green\r\n              data[i + 2] = 255 - data[i + 2]; // Invert blue\r\n            }\r\n          }\r\n        } else {\r\n          // Scanlines effect\r\n          for (let y = 0; y < pixelCanvas.height; y++) {\r\n            if (y % 3 === 0) { // Every third line\r\n              for (let x = 0; x < pixelCanvas.width; x++) {\r\n                const i = (y * pixelCanvas.width + x) * 4;\r\n                // Brighten the line\r\n                data[i] = Math.min(255, data[i] * 1.5);\r\n                data[i + 1] = Math.min(255, data[i + 1] * 1.5);\r\n                data[i + 2] = Math.min(255, data[i + 2] * 1.5);\r\n              }\r\n            } else if (y % 3 === 1) { // Every third line + 1\r\n              for (let x = 0; x < pixelCanvas.width; x++) {\r\n                const i = (y * pixelCanvas.width + x) * 4;\r\n                // Darken the line\r\n                data[i] = data[i] * 0.5;\r\n                data[i + 1] = data[i + 1] * 0.5;\r\n                data[i + 2] = data[i + 2] * 0.5;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        \r\n        // Put the manipulated data back\r\n        ctx.putImageData(imageData, 0, 0);\r\n      }\r\n      \r\n      // Continue the animation\r\n      requestAnimationFrame(manipulatePixels);\r\n    }\r\n    \r\n    // Apply extreme glitch effect\r\n    function applyExtremeGlitch() {\r\n      // Apply to original image\r\n      profileImage.classList.add(\"extreme-glitch\");\r\n      \r\n      // Apply different effects to each layer\r\n      glitchLayers.forEach((layer, index) => {\r\n        // Random offset\r\n        const xOffset = (Math.random() - 0.5) * 20;\r\n        const yOffset = (Math.random() - 0.5) * 20;\r\n        layer.style.transform = `translate(${xOffset}px, ${yOffset}px)`;\r\n        \r\n        // Random filter\r\n        const hue = Math.floor(Math.random() * 360);\r\n        const saturate = 1 + Math.random() * 3;\r\n        const brightness = 0.7 + Math.random() * 0.6;\r\n        const contrast = 0.8 + Math.random() * 0.8;\r\n        const invert = Math.random() < 0.3 ? Math.random() * 0.3 : 0;\r\n        \r\n        layer.style.filter = `\r\n          hue-rotate(${hue}deg) \r\n          saturate(${saturate}) \r\n          brightness(${brightness}) \r\n          contrast(${contrast}) \r\n          invert(${invert})\r\n        `;\r\n        \r\n        // Random blend mode\r\n        const blendModes = ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion'];\r\n        const randomBlend = blendModes[Math.floor(Math.random() * blendModes.length)];\r\n        layer.style.mixBlendMode = randomBlend;\r\n        \r\n        // Random opacity\r\n        layer.style.opacity = 0.3 + Math.random() * 0.7;\r\n        \r\n        // Add specific class for animation\r\n        layer.classList.add(\"layer-glitching\");\r\n        \r\n        // Remove classes after animation completes\r\n        setTimeout(() => {\r\n          layer.classList.remove(\"layer-glitching\");\r\n        }, 500);\r\n      });\r\n      \r\n      // Trigger fractal animation\r\n      fractalOverlay.classList.add(\"fractal-active\");\r\n      \r\n      // Reset original image after effect\r\n      setTimeout(() => {\r\n        profileImage.classList.remove(\"extreme-glitch\");\r\n        \r\n        // Reset layer positions gradually\r\n        glitchLayers.forEach((layer, index) => {\r\n          setTimeout(() => {\r\n            layer.style.transform = \"translate(0, 0)\";\r\n            layer.style.filter = \"none\";\r\n            layer.style.mixBlendMode = \"normal\";\r\n            layer.style.opacity = 0.7 - (index * 0.1);\r\n          }, index * 50);\r\n        });\r\n        \r\n        // Reset fractal\r\n        fractalOverlay.classList.remove(\"fractal-active\");\r\n      }, 500);\r\n    }\r\n    \r\n    // Apply subtle continuous glitch\r\n    function applySubtleGlitch() {\r\n      // Only apply sometimes\r\n      if (Math.random() < 0.3) {\r\n        // Subtle movement\r\n        const xOffset = (Math.random() - 0.5) * 4;\r\n        const yOffset = (Math.random() - 0.5) * 4;\r\n        \r\n        // Apply to a random layer\r\n        const randomLayer = Math.floor(Math.random() * glitchLayers.length);\r\n        glitchLayers[randomLayer].style.transform = `translate(${xOffset}px, ${yOffset}px)`;\r\n        \r\n        // Reset after short delay\r\n        setTimeout(() => {\r\n          glitchLayers[randomLayer].style.transform = \"translate(0, 0)\";\r\n        }, 50);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n})();\n\n//# sourceURL=webpack://bbfiller/./src/profile-glitch.js?");

/***/ }),

/***/ "./src/sw.js":
/*!*******************!*\
  !*** ./src/sw.js ***!
  \*******************/
/***/ (() => {

eval("(function() {\r\n\r\n/**\r\n * Enhanced Service Worker\r\n * Provides robust offline support, advanced caching strategies, and performance optimizations\r\n * for the Cyberpunk OS application.\r\n */\r\n\r\n// ===== Configuration =====\r\nconst CONFIG = {\r\n  // Cache names with versioning\r\n  caches: {\r\n    static: 'cyberpunk-os-static-v1',\r\n    dynamic: 'cyberpunk-os-dynamic-v1',\r\n    assets: 'cyberpunk-os-assets-v1',\r\n    api: 'cyberpunk-os-api-v1'\r\n  },\r\n  \r\n  // Cache expiration (in milliseconds)\r\n  expiration: {\r\n    api: 24 * 60 * 60 * 1000, // 24 hours\r\n    dynamic: 7 * 24 * 60 * 60 * 1000 // 7 days\r\n  },\r\n  \r\n  // Maximum cache size\r\n  maxCacheSize: {\r\n    dynamic: 50, // Maximum number of items in dynamic cache\r\n    assets: 100  // Maximum number of items in assets cache\r\n  },\r\n  \r\n  // Debug mode\r\n  debug: false\r\n};\r\n\r\n// Assets to cache on install (critical app shell)\r\nconst PRECACHE_ASSETS = [\r\n  '/',\r\n  '/index.html',\r\n  '/css/main.css',\r\n  '/css/glitch-effects.css',\r\n  '/js/boot-sequence.js',\r\n  '/js/consolidated.js',\r\n  '/js/utils.js',\r\n  '/js/window-state-manager.js',\r\n  '/js/asset-loader.js',\r\n  '/js/accessibility.js',\r\n  '/js/mobile-enhancements.js',\r\n  '/js/virtual-filesystem.js',\r\n  '/js/clock-manager.js',\r\n  '/js/workers/clock-worker.js',\r\n  '/js/apps/file-explorer.js',\r\n  '/js/apps/terminal.js',\r\n  '/manifest.json',\r\n  '/favicon.ico',\r\n  '/icons/icon-192x192.png',\r\n  '/icons/icon-512x512.png'\r\n];\r\n\r\n// Additional assets to cache after install (non-critical)\r\nconst SECONDARY_ASSETS = [\r\n  '/fonts/vt323-regular.woff2',\r\n  '/fonts/press-start-2p.woff2',\r\n  '/sounds/boot.mp3',\r\n  '/sounds/click.mp3',\r\n  '/images/background.jpg'\r\n];\r\n\r\n// ===== Utility Functions =====\r\n\r\n// Logger with debug mode support\r\nconst log = (message, type = 'info') => {\r\n  if (CONFIG.debug || type === 'error') {\r\n    const emoji = type === 'error' ? '❌' : type === 'warn' ? '⚠️' : '🔧';\r\n    console[type](`[ServiceWorker] ${emoji} ${message}`);\r\n  }\r\n};\r\n\r\n// Cache management utilities\r\nconst cacheUtils = {\r\n  // Add items to a specific cache\r\n  async addToCache(cacheName, items) {\r\n    try {\r\n      const cache = await caches.open(cacheName);\r\n      await cache.addAll(items);\r\n      log(`Added ${items.length} items to ${cacheName}`);\r\n    } catch (error) {\r\n      log(`Failed to add items to ${cacheName}: ${error}`, 'error');\r\n    }\r\n  },\r\n  \r\n  // Trim cache to maximum size\r\n  async trimCache(cacheName, maxItems) {\r\n    try {\r\n      const cache = await caches.open(cacheName);\r\n      const keys = await cache.keys();\r\n      \r\n      if (keys.length > maxItems) {\r\n        log(`Trimming ${cacheName} (${keys.length} items, max: ${maxItems})`, 'warn');\r\n        for (let i = 0; i < keys.length - maxItems; i++) {\r\n          await cache.delete(keys[i]);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      log(`Failed to trim ${cacheName}: ${error}`, 'error');\r\n    }\r\n  },\r\n  \r\n  // Delete expired items from cache\r\n  async deleteExpiredItems(cacheName, maxAge) {\r\n    try {\r\n      const cache = await caches.open(cacheName);\r\n      const keys = await cache.keys();\r\n      const now = Date.now();\r\n      \r\n      let expiredCount = 0;\r\n      for (const request of keys) {\r\n        const response = await cache.match(request);\r\n        if (response) {\r\n          const cachedTime = response.headers.get('sw-cache-timestamp');\r\n          if (cachedTime && (now - parseInt(cachedTime)) > maxAge) {\r\n            await cache.delete(request);\r\n            expiredCount++;\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (expiredCount > 0) {\r\n        log(`Removed ${expiredCount} expired items from ${cacheName}`);\r\n      }\r\n    } catch (error) {\r\n      log(`Failed to delete expired items from ${cacheName}: ${error}`, 'error');\r\n    }\r\n  },\r\n  \r\n  // Add timestamp to response\r\n  addTimestamp(response) {\r\n    if (!response || !response.body) return response;\r\n    \r\n    const headers = new Headers(response.headers);\r\n    headers.set('sw-cache-timestamp', Date.now().toString());\r\n    \r\n    return new Response(response.body, {\r\n      status: response.status,\r\n      statusText: response.statusText,\r\n      headers: headers\r\n    });\r\n  }\r\n};\r\n\r\n// Network utilities\r\nconst networkUtils = {\r\n  // Check if a URL is an API request\r\n  isApiRequest(url) {\r\n    return url.includes('/api/');\r\n  },\r\n  \r\n  // Check if a URL is a static asset\r\n  isStaticAsset(url) {\r\n    const staticExtensions = ['.css', '.js', '.html', '.json', '.ico', '.png', '.jpg', '.svg', '.woff', '.woff2', '.ttf'];\r\n    return staticExtensions.some(ext => url.endsWith(ext));\r\n  },\r\n  \r\n  // Check if a URL is a media asset\r\n  isMediaAsset(url) {\r\n    const mediaExtensions = ['.mp3', '.mp4', '.webm', '.ogg', '.wav'];\r\n    return mediaExtensions.some(ext => url.endsWith(ext));\r\n  },\r\n  \r\n  // Check if a request should be cached\r\n  shouldCache(request) {\r\n    // Skip non-GET requests\r\n    if (request.method !== 'GET') return false;\r\n    \r\n    const url = new URL(request.url);\r\n    \r\n    // Skip cross-origin requests\r\n    if (url.origin !== self.location.origin) return false;\r\n    \r\n    // Skip analytics and tracking requests\r\n    if (url.pathname.includes('/analytics/') || url.pathname.includes('/tracking/')) return false;\r\n    \r\n    return true;\r\n  },\r\n  \r\n  // Network-first strategy with timeout\r\n  async networkFirstWithTimeout(request, cacheName, timeout = 3000) {\r\n    return new Promise(async (resolve) => {\r\n      let timeoutId;\r\n      \r\n      // Set timeout for network request\r\n      const timeoutPromise = new Promise(resolveTimeout => {\r\n        timeoutId = setTimeout(async () => {\r\n          log(`Network request timeout for ${request.url}`, 'warn');\r\n          const cachedResponse = await caches.match(request);\r\n          if (cachedResponse) {\r\n            log(`Serving from cache: ${request.url}`);\r\n            resolveTimeout(cachedResponse);\r\n          } else {\r\n            log(`No cached version available for ${request.url}`, 'warn');\r\n            resolveTimeout(new Response('Network request timed out', { \r\n              status: 408, \r\n              headers: { 'Content-Type': 'text/plain' } \r\n            }));\r\n          }\r\n        }, timeout);\r\n      });\r\n      \r\n      // Try network first\r\n      try {\r\n        const networkPromise = fetch(request).then(async response => {\r\n          clearTimeout(timeoutId);\r\n          \r\n          // Cache successful responses\r\n          if (response.ok) {\r\n            const clonedResponse = response.clone();\r\n            const cache = await caches.open(cacheName);\r\n            await cache.put(request, cacheUtils.addTimestamp(clonedResponse));\r\n            log(`Cached network response: ${request.url}`);\r\n          }\r\n          \r\n          return response;\r\n        });\r\n        \r\n        // Race network request against timeout\r\n        resolve(Promise.race([networkPromise, timeoutPromise]));\r\n      } catch (error) {\r\n        clearTimeout(timeoutId);\r\n        log(`Network error for ${request.url}: ${error}`, 'error');\r\n        \r\n        // Fallback to cache\r\n        const cachedResponse = await caches.match(request);\r\n        if (cachedResponse) {\r\n          log(`Serving from cache after network error: ${request.url}`);\r\n          resolve(cachedResponse);\r\n        } else {\r\n          log(`No cached version available after network error for ${request.url}`, 'error');\r\n          resolve(new Response('Network error and no cached version available', { \r\n            status: 503, \r\n            headers: { 'Content-Type': 'text/plain' } \r\n          }));\r\n        }\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// ===== Event Handlers =====\r\n\r\n// Install event - precache critical assets\r\nself.addEventListener('install', event => {\r\n  log('Installing Service Worker');\r\n  \r\n  event.waitUntil(\r\n    (async () => {\r\n      try {\r\n        // Cache critical app shell assets\r\n        await cacheUtils.addToCache(CONFIG.caches.static, PRECACHE_ASSETS);\r\n        \r\n        // Skip waiting to activate immediately\r\n        await self.skipWaiting();\r\n        log('Service Worker installed successfully');\r\n      } catch (error) {\r\n        log(`Installation failed: ${error}`, 'error');\r\n      }\r\n    })()\r\n  );\r\n});\r\n\r\n// Activate event - clean up old caches and claim clients\r\nself.addEventListener('activate', event => {\r\n  log('Activating Service Worker');\r\n  \r\n  event.waitUntil(\r\n    (async () => {\r\n      try {\r\n        // Get all cache names\r\n        const cacheNames = await caches.keys();\r\n        \r\n        // Valid cache names from config\r\n        const validCacheNames = Object.values(CONFIG.caches);\r\n        \r\n        // Delete old caches\r\n        await Promise.all(\r\n          cacheNames\r\n            .filter(cacheName => !validCacheNames.includes(cacheName))\r\n            .map(cacheName => {\r\n              log(`Removing old cache: ${cacheName}`);\r\n              return caches.delete(cacheName);\r\n            })\r\n        );\r\n        \r\n        // Cache secondary assets in the background\r\n        cacheUtils.addToCache(CONFIG.caches.assets, SECONDARY_ASSETS)\r\n          .catch(error => log(`Failed to cache secondary assets: ${error}`, 'error'));\r\n        \r\n        // Claim all clients\r\n        await self.clients.claim();\r\n        log('Service Worker activated and claimed clients');\r\n      } catch (error) {\r\n        log(`Activation failed: ${error}`, 'error');\r\n      }\r\n    })()\r\n  );\r\n});\r\n\r\n// Fetch event - handle different caching strategies based on request type\r\nself.addEventListener('fetch', event => {\r\n  const request = event.request;\r\n  \r\n  // Skip non-cacheable requests\r\n  if (!networkUtils.shouldCache(request)) {\r\n    return;\r\n  }\r\n  \r\n  // Choose caching strategy based on request type\r\n  if (networkUtils.isApiRequest(request.url)) {\r\n    // API requests: Network-first with fallback to cache\r\n    event.respondWith(\r\n      networkUtils.networkFirstWithTimeout(request, CONFIG.caches.api, 5000)\r\n    );\r\n  } else if (networkUtils.isMediaAsset(request.url)) {\r\n    // Media assets: Cache-first for performance\r\n    event.respondWith(\r\n      (async () => {\r\n        try {\r\n          // Try cache first\r\n          const cachedResponse = await caches.match(request);\r\n          if (cachedResponse) {\r\n            log(`Serving media from cache: ${request.url}`);\r\n            return cachedResponse;\r\n          }\r\n          \r\n          // If not in cache, fetch from network\r\n          const networkResponse = await fetch(request);\r\n          \r\n          // Cache the response if successful\r\n          if (networkResponse.ok) {\r\n            const clonedResponse = networkResponse.clone();\r\n            const cache = await caches.open(CONFIG.caches.assets);\r\n            await cache.put(request, cacheUtils.addTimestamp(clonedResponse));\r\n            \r\n            // Trim cache if needed\r\n            cacheUtils.trimCache(CONFIG.caches.assets, CONFIG.maxCacheSize.assets);\r\n            \r\n            log(`Cached media asset: ${request.url}`);\r\n          }\r\n          \r\n          return networkResponse;\r\n        } catch (error) {\r\n          log(`Failed to fetch media asset: ${request.url}`, 'error');\r\n          return new Response('Failed to fetch media asset', { \r\n            status: 503, \r\n            headers: { 'Content-Type': 'text/plain' } \r\n          });\r\n        }\r\n      })()\r\n    );\r\n  } else if (networkUtils.isStaticAsset(request.url)) {\r\n    // Static assets: Cache-first with network fallback\r\n    event.respondWith(\r\n      (async () => {\r\n        try {\r\n          // Try cache first\r\n          const cachedResponse = await caches.match(request);\r\n          if (cachedResponse) {\r\n            log(`Serving static asset from cache: ${request.url}`);\r\n            \r\n            // Update cache in the background (stale-while-revalidate)\r\n            fetch(request)\r\n              .then(async networkResponse => {\r\n                if (networkResponse.ok) {\r\n                  const cache = await caches.open(CONFIG.caches.static);\r\n                  await cache.put(request, cacheUtils.addTimestamp(networkResponse));\r\n                  log(`Updated cached static asset: ${request.url}`);\r\n                }\r\n              })\r\n              .catch(error => log(`Background fetch failed for ${request.url}: ${error}`, 'warn'));\r\n            \r\n            return cachedResponse;\r\n          }\r\n          \r\n          // If not in cache, fetch from network\r\n          const networkResponse = await fetch(request);\r\n          \r\n          // Cache the response if successful\r\n          if (networkResponse.ok) {\r\n            const clonedResponse = networkResponse.clone();\r\n            const cache = await caches.open(CONFIG.caches.static);\r\n            await cache.put(request, cacheUtils.addTimestamp(clonedResponse));\r\n            log(`Cached static asset: ${request.url}`);\r\n          }\r\n          \r\n          return networkResponse;\r\n        } catch (error) {\r\n          log(`Failed to fetch static asset: ${request.url}`, 'error');\r\n          return new Response('Failed to fetch static asset', { \r\n            status: 503, \r\n            headers: { 'Content-Type': 'text/plain' } \r\n          });\r\n        }\r\n      })()\r\n    );\r\n  } else {\r\n    // Other requests: Network-first with cache fallback\r\n    event.respondWith(\r\n      (async () => {\r\n        try {\r\n          // Try network first\r\n          const networkResponse = await fetch(request);\r\n          \r\n          // Cache the response if successful\r\n          if (networkResponse.ok) {\r\n            const clonedResponse = networkResponse.clone();\r\n            const cache = await caches.open(CONFIG.caches.dynamic);\r\n            await cache.put(request, cacheUtils.addTimestamp(clonedResponse));\r\n            \r\n            // Trim cache if needed\r\n            cacheUtils.trimCache(CONFIG.caches.dynamic, CONFIG.maxCacheSize.dynamic);\r\n            \r\n            log(`Cached dynamic content: ${request.url}`);\r\n          }\r\n          \r\n          return networkResponse;\r\n        } catch (error) {\r\n          log(`Network request failed for ${request.url}: ${error}`, 'warn');\r\n          \r\n          // Fallback to cache\r\n          const cachedResponse = await caches.match(request);\r\n          if (cachedResponse) {\r\n            log(`Serving from cache after network failure: ${request.url}`);\r\n            return cachedResponse;\r\n          }\r\n          \r\n          // If not in cache, try to serve the offline page\r\n          const offlineResponse = await caches.match('/offline.html');\r\n          if (offlineResponse) {\r\n            return offlineResponse;\r\n          }\r\n          \r\n          // Last resort: generic error response\r\n          return new Response('You are offline and the requested resource is not cached', { \r\n            status: 503, \r\n            headers: { 'Content-Type': 'text/plain' } \r\n          });\r\n        }\r\n      })()\r\n    );\r\n  }\r\n});\r\n\r\n// Message event - handle messages from clients\r\nself.addEventListener('message', event => {\r\n  log(`Message received: ${JSON.stringify(event.data)}`);\r\n  \r\n  if (event.data.action === 'skipWaiting') {\r\n    self.skipWaiting();\r\n  } else if (event.data.action === 'clearCache') {\r\n    event.waitUntil(\r\n      (async () => {\r\n        try {\r\n          if (event.data.cacheName) {\r\n            // Clear specific cache\r\n            await caches.delete(event.data.cacheName);\r\n            log(`Cleared cache: ${event.data.cacheName}`);\r\n          } else {\r\n            // Clear all caches\r\n            const cacheNames = await caches.keys();\r\n            await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));\r\n            log('Cleared all caches');\r\n          }\r\n          \r\n          // Notify client\r\n          if (event.source) {\r\n            event.source.postMessage({\r\n              action: 'cacheCleared',\r\n              success: true\r\n            });\r\n          }\r\n        } catch (error) {\r\n          log(`Failed to clear cache: ${error}`, 'error');\r\n          \r\n          // Notify client of failure\r\n          if (event.source) {\r\n            event.source.postMessage({\r\n              action: 'cacheCleared',\r\n              success: false,\r\n              error: error.message\r\n            });\r\n          }\r\n        }\r\n      })()\r\n    );\r\n  } else if (event.data.action === 'precacheAssets') {\r\n    // Precache additional assets on demand\r\n    event.waitUntil(\r\n      (async () => {\r\n        try {\r\n          if (event.data.assets && Array.isArray(event.data.assets)) {\r\n            await cacheUtils.addToCache(CONFIG.caches.assets, event.data.assets);\r\n            \r\n            // Notify client\r\n            if (event.source) {\r\n              event.source.postMessage({\r\n                action: 'assetsPrecached',\r\n                success: true\r\n              });\r\n            }\r\n          }\r\n        } catch (error) {\r\n          log(`Failed to precache assets: ${error}`, 'error');\r\n          \r\n          // Notify client of failure\r\n          if (event.source) {\r\n            event.source.postMessage({\r\n              action: 'assetsPrecached',\r\n              success: false,\r\n              error: error.message\r\n            });\r\n          }\r\n        }\r\n      })()\r\n    );\r\n  } else if (event.data.action === 'setDebugMode') {\r\n    CONFIG.debug = !!event.data.enabled;\r\n    log(`Debug mode ${CONFIG.debug ? 'enabled' : 'disabled'}`);\r\n    \r\n    // Notify client\r\n    if (event.source) {\r\n      event.source.postMessage({\r\n        action: 'debugModeSet',\r\n        enabled: CONFIG.debug\r\n      });\r\n    }\r\n  }\r\n});\r\n\r\n// Periodic cache maintenance\r\nself.addEventListener('periodicsync', event => {\r\n  if (event.tag === 'cache-maintenance') {\r\n    log('Performing periodic cache maintenance');\r\n    \r\n    event.waitUntil(\r\n      (async () => {\r\n        try {\r\n          // Delete expired items from API cache\r\n          await cacheUtils.deleteExpiredItems(CONFIG.caches.api, CONFIG.expiration.api);\r\n          \r\n          // Delete expired items from dynamic cache\r\n          await cacheUtils.deleteExpiredItems(CONFIG.caches.dynamic, CONFIG.expiration.dynamic);\r\n          \r\n          // Trim caches to maximum size\r\n          await cacheUtils.trimCache(CONFIG.caches.dynamic, CONFIG.maxCacheSize.dynamic);\r\n          await cacheUtils.trimCache(CONFIG.caches.assets, CONFIG.maxCacheSize.assets);\r\n          \r\n          log('Cache maintenance completed');\r\n        } catch (error) {\r\n          log(`Cache maintenance failed: ${error}`, 'error');\r\n        }\r\n      })()\r\n    );\r\n  }\r\n});\r\n\r\n// Push notification event\r\nself.addEventListener('push', event => {\r\n  log('Push notification received');\r\n  \r\n  if (!event.data) {\r\n    log('No data in push event', 'warn');\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    const data = event.data.json();\r\n    \r\n    const options = {\r\n      body: data.body || 'New notification',\r\n      icon: data.icon || '/icons/icon-192x192.png',\r\n      badge: data.badge || '/icons/badge-72x72.png',\r\n      vibrate: data.vibrate || [100, 50, 100],\r\n      data: {\r\n        url: data.url || '/'\r\n      }\r\n    };\r\n    \r\n    event.waitUntil(\r\n      self.registration.showNotification(data.title || 'Cyberpunk OS', options)\r\n    );\r\n  } catch (error) {\r\n    log(`Failed to process push notification: ${error}`, 'error');\r\n  }\r\n});\r\n\r\n// Notification click event\r\nself.addEventListener('notificationclick', event => {\r\n  log('Notification clicked');\r\n  \r\n  event.notification.close();\r\n  \r\n  event.waitUntil(\r\n    (async () => {\r\n      try {\r\n        const url = event.notification.data.url || '/';\r\n        const windowClients = await self.clients.matchAll({ type: 'window' });\r\n        \r\n        // Try to find an open window and navigate to the URL\r\n        for (const client of windowClients) {\r\n          if (client.url === url && 'focus' in client) {\r\n            await client.focus();\r\n            return;\r\n          }\r\n        }\r\n        \r\n        // If no window is open, open a new one\r\n        if (self.clients.openWindow) {\r\n          await self.clients.openWindow(url);\r\n        }\r\n      } catch (error) {\r\n        log(`Failed to handle notification click: ${error}`, 'error');\r\n      }\r\n    })()\r\n  );\r\n});\r\n\r\n// Log successful registration\r\nlog('Service Worker registered');\r\n\r\n})();\n\n//# sourceURL=webpack://bbfiller/./src/sw.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ (() => {

eval("(function() {\n  // DOM utilities\n  const DOM = {\n    // Cache for DOM elements\n    cache: new Map(),\n    \n    // Get element by ID with caching\n    get(id) {\n      if (!this.cache.has(id)) {\n        const element = document.getElementById(id);\n        if (element) {\n          this.cache.set(id, element);\n        }\n        return element;\n      }\n      return this.cache.get(id);\n    },\n    \n    // Query selector with caching\n    query(selector, context = document) {\n      const cacheKey = `query:${selector}`;\n      if (!this.cache.has(cacheKey)) {\n        const element = context.querySelector(selector);\n        if (element) {\n          this.cache.set(cacheKey, element);\n        }\n        return element;\n      }\n      return this.cache.get(cacheKey);\n    },\n    \n    // Query selector all (no caching)\n    queryAll(selector, context = document) {\n      return context.querySelectorAll(selector);\n    },\n    \n    // Create element with attributes and children\n    create(tag, attributes = {}, children = []) {\n      const element = document.createElement(tag);\n      \n      // Set attributes\n      Object.entries(attributes).forEach(([key, value]) => {\n        if (key === 'style' && typeof value === 'object') {\n          Object.entries(value).forEach(([prop, val]) => {\n            element.style[prop] = val;\n          });\n        } else if (key === 'classList' && Array.isArray(value)) {\n          value.forEach(cls => element.classList.add(cls));\n        } else if (key === 'dataset' && typeof value === 'object') {\n          Object.entries(value).forEach(([prop, val]) => {\n            element.dataset[prop] = val;\n          });\n        } else if (key === 'events' && typeof value === 'object') {\n          Object.entries(value).forEach(([event, handler]) => {\n            element.addEventListener(event, handler);\n          });\n        } else {\n          element.setAttribute(key, value);\n        }\n      });\n      \n      // Add children\n      children.forEach(child => {\n        if (typeof child === 'string') {\n          element.appendChild(document.createTextNode(child));\n        } else if (child instanceof Node) {\n          element.appendChild(child);\n        }\n      });\n      \n      return element;\n    },\n    \n    // Add event listener with automatic cleanup\n    addEvent(element, event, handler, options) {\n      element.addEventListener(event, handler, options);\n      \n      // Return cleanup function\n      return () => {\n        element.removeEventListener(event, handler, options);\n      };\n    },\n    \n    // Clear cache\n    clearCache() {\n      this.cache.clear();\n    }\n  };\n\n  // Performance utilities\n  const Performance = {\n    // Debounce function\n    debounce(func, wait = 100) {\n      let timeout;\n      return function(...args) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func.apply(this, args), wait);\n      };\n    },\n    \n    // Throttle function\n    throttle(func, limit = 100) {\n      let inThrottle;\n      return function(...args) {\n        if (!inThrottle) {\n          func.apply(this, args);\n          inThrottle = true;\n          setTimeout(() => inThrottle = false, limit);\n        }\n      };\n    },\n    \n    // Request animation frame with callback\n    rafCallback(callback) {\n      let ticking = false;\n      \n      return function(...args) {\n        if (!ticking) {\n          window.requestAnimationFrame(() => {\n            callback.apply(this, args);\n            ticking = false;\n          });\n          ticking = true;\n        }\n      };\n    },\n    \n    // Measure execution time\n    measure(name, func) {\n      const start = performance.now();\n      const result = func();\n      const end = performance.now();\n      console.log(`${name} took ${end - start}ms`);\n      return result;\n    }\n  };\n\n  // Storage utilities\n  const Storage = {\n    // Save data to localStorage\n    save(key, data) {\n      try {\n        localStorage.setItem(key, JSON.stringify(data));\n        return true;\n      } catch (error) {\n        console.error(`Error saving to localStorage: ${error}`);\n        return false;\n      }\n    },\n    \n    // Load data from localStorage\n    load(key, defaultValue = null) {\n      try {\n        const data = localStorage.getItem(key);\n        return data ? JSON.parse(data) : defaultValue;\n      } catch (error) {\n        console.error(`Error loading from localStorage: ${error}`);\n        return defaultValue;\n      }\n    },\n    \n    // Remove data from localStorage\n    remove(key) {\n      try {\n        localStorage.removeItem(key);\n        return true;\n      } catch (error) {\n        console.error(`Error removing from localStorage: ${error}`);\n        return false;\n      }\n    },\n    \n    // Clear all data from localStorage\n    clear() {\n      try {\n        localStorage.clear();\n        return true;\n      } catch (error) {\n        console.error(`Error clearing localStorage: ${error}`);\n        return false;\n      }\n    }\n  };\n\n  // Accessibility utilities\n  const Accessibility = {\n    // Add ARIA attributes to an element\n    setAria(element, attributes) {\n      Object.entries(attributes).forEach(([key, value]) => {\n        element.setAttribute(`aria-${key}`, value);\n      });\n    },\n    \n    // Make an element focusable\n    makeFocusable(element, tabIndex = 0) {\n      element.setAttribute('tabindex', tabIndex);\n    },\n    \n    // Announce a message to screen readers\n    announce(message, politeness = 'polite') {\n      let announcer = document.getElementById('a11y-announcer');\n      \n      if (!announcer) {\n        announcer = document.createElement('div');\n        announcer.id = 'a11y-announcer';\n        announcer.setAttribute('aria-live', politeness);\n        announcer.setAttribute('aria-atomic', 'true');\n        announcer.style.position = 'absolute';\n        announcer.style.width = '1px';\n        announcer.style.height = '1px';\n        announcer.style.padding = '0';\n        announcer.style.overflow = 'hidden';\n        announcer.style.clip = 'rect(0, 0, 0, 0)';\n        announcer.style.whiteSpace = 'nowrap';\n        announcer.style.border = '0';\n        document.body.appendChild(announcer);\n      }\n      \n      // Clear previous message\n      announcer.textContent = '';\n      \n      // Set new message after a small delay\n      setTimeout(() => {\n        announcer.textContent = message;\n      }, 50);\n    }\n  };\n\n  // Device detection\n  const Device = {\n    // Check if device is mobile\n    isMobile() {\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    },\n    \n    // Check if device supports touch\n    isTouch() {\n      return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n    },\n    \n    // Check if device is in portrait orientation\n    isPortrait() {\n      return window.matchMedia('(orientation: portrait)').matches;\n    },\n    \n    // Get device pixel ratio\n    getPixelRatio() {\n      return window.devicePixelRatio || 1;\n    }\n  };\n\n  // Export all utilities as a single object\n  const Utils = {\n    DOM,\n    Performance,\n    Storage,\n    Accessibility,\n    Device\n  };\n\n  // Make available globally\n  window.Utils = Utils;\n})();\n\n//# sourceURL=webpack://bbfiller/./src/utils.js?");

/***/ }),

/***/ "./src/window-size-fix.js":
/*!********************************!*\
  !*** ./src/window-size-fix.js ***!
  \********************************/
/***/ (() => {

eval("(function() {\r\ndocument.addEventListener(\"DOMContentLoaded\", function() {\r\n  console.log(\"🪟 Applying window size fix...\");\r\n  \r\n  // Default window dimensions - larger square format\r\n  const DEFAULT_WINDOW_WIDTH = \"640px\";  // Wider\r\n  const DEFAULT_WINDOW_HEIGHT = \"580px\"; // Taller\r\n  \r\n  // Function to set default window size\r\n  function setDefaultWindowSize() {\r\n    // Get all popup windows\r\n    const windows = document.querySelectorAll(\".popup-window\");\r\n    \r\n    windows.forEach(function(win) {\r\n      // Set default size if not already set\r\n      if (!win.style.width || win.style.width === \"auto\") {\r\n        win.style.width = DEFAULT_WINDOW_WIDTH;\r\n      }\r\n      \r\n      if (!win.style.height || win.style.height === \"auto\") {\r\n        win.style.height = DEFAULT_WINDOW_HEIGHT;\r\n      }\r\n      \r\n      console.log(`🪟 Set default size for window: ${win.id}`);\r\n    });\r\n  }\r\n  \r\n  // Run immediately to set sizes for existing windows\r\n  setDefaultWindowSize();\r\n  \r\n  // Override the openWindow function to ensure new windows use the correct size\r\n  if (typeof window.openWindow === 'function') {\r\n    const originalOpenWindow = window.openWindow;\r\n    \r\n    window.openWindow = function(id) {\r\n      // Call the original function\r\n      const windowElement = originalOpenWindow(id);\r\n      \r\n      // Apply our size settings\r\n      if (windowElement) {\r\n        windowElement.style.width = DEFAULT_WINDOW_WIDTH;\r\n        windowElement.style.height = DEFAULT_WINDOW_HEIGHT;\r\n        \r\n        // Center the window on screen\r\n        centerWindow(windowElement);\r\n        \r\n        console.log(`🪟 Opened window with larger size: ${id}`);\r\n      }\r\n      \r\n      return windowElement;\r\n    };\r\n    \r\n    console.log(\"🪟 Enhanced openWindow function with larger default size\");\r\n  }\r\n  \r\n  // Function to center a window on screen\r\n  function centerWindow(windowElement) {\r\n    const windowWidth = parseInt(windowElement.style.width);\r\n    const windowHeight = parseInt(windowElement.style.height);\r\n    \r\n    const screenWidth = window.innerWidth;\r\n    const screenHeight = window.innerHeight;\r\n    \r\n    const left = Math.max(0, (screenWidth - windowWidth) / 2);\r\n    const top = Math.max(0, (screenHeight - windowHeight) / 2);\r\n    \r\n    windowElement.style.left = `${left}px`;\r\n    windowElement.style.top = `${top}px`;\r\n  }\r\n  \r\n  // Apply to any windows that might be opened later\r\n  const observer = new MutationObserver(function(mutations) {\r\n    mutations.forEach(function(mutation) {\r\n      if (mutation.addedNodes.length) {\r\n        mutation.addedNodes.forEach(function(node) {\r\n          if (node.classList && node.classList.contains(\"popup-window\")) {\r\n            // Set size for newly added windows\r\n            node.style.width = DEFAULT_WINDOW_WIDTH;\r\n            node.style.height = DEFAULT_WINDOW_HEIGHT;\r\n            centerWindow(node);\r\n          }\r\n        });\r\n      }\r\n    });\r\n  });\r\n  \r\n  // Start observing the document body for added nodes\r\n  observer.observe(document.body, { childList: true, subtree: true });\r\n  \r\n  console.log(\"🪟 Window size fix applied\");\r\n});\r\n\r\n})();\n\n//# sourceURL=webpack://bbfiller/./src/window-size-fix.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;