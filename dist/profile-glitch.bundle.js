/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/profile-glitch.js":
/*!*******************************!*\
  !*** ./src/profile-glitch.js ***!
  \*******************************/
/***/ (() => {

eval("// ULTRA TRIPPY PROFILE IMAGE EFFECTS\r\ndocument.addEventListener(\"DOMContentLoaded\", function() {\r\n  console.log(\"ðŸŒ€ Initializing extreme profile image effects\");\r\n  \r\n  // Wait for the profile image to be created by boot-sequence.js\r\n  const checkForProfileImage = setInterval(() => {\r\n    const profileImage = document.querySelector(\".profile-image\");\r\n    const glowEffect = document.querySelector(\".image-glow-effect\");\r\n    \r\n    if (profileImage && glowEffect) {\r\n      clearInterval(checkForProfileImage);\r\n      initTrippyProfileEffects(profileImage, glowEffect);\r\n    }\r\n  }, 100);\r\n  \r\n  function initTrippyProfileEffects(profileImage, glowEffect) {\r\n    console.log(\"ðŸŒˆ Applying extreme trippy effects to profile image\");\r\n    \r\n    // Create a container for the fractal overlay\r\n    const fractalOverlay = document.createElement(\"div\");\r\n    fractalOverlay.classList.add(\"fractal-overlay\");\r\n    profileImage.parentNode.appendChild(fractalOverlay);\r\n    \r\n    // Create multiple clone layers for the glitch effect\r\n    const layers = 30; // Number of glitch layers\r\n    const glitchLayers = [];\r\n    \r\n    for (let i = 0; i < layers; i++) {\r\n      const layer = document.createElement(\"div\");\r\n      layer.classList.add(\"profile-glitch-layer\");\r\n      layer.style.zIndex = 2 + i;\r\n      layer.style.opacity = 0.7 - (i * 0.1);\r\n      \r\n      // Create image inside layer\r\n      const layerImg = document.createElement(\"img\");\r\n      layerImg.src = profileImage.src;\r\n      layerImg.classList.add(\"layer-img\");\r\n      layer.appendChild(layerImg);\r\n      \r\n      // Add to DOM before the original image\r\n      profileImage.parentNode.insertBefore(layer, profileImage);\r\n      glitchLayers.push(layer);\r\n    }\r\n    \r\n    // Create a canvas for pixel manipulation effects\r\n    const pixelCanvas = document.createElement(\"canvas\");\r\n    pixelCanvas.width = 150;\r\n    pixelCanvas.height = 150;\r\n    pixelCanvas.classList.add(\"pixel-manipulation-canvas\");\r\n    profileImage.parentNode.appendChild(pixelCanvas);\r\n    \r\n    const ctx = pixelCanvas.getContext(\"2d\");\r\n    \r\n    // Load the image into the canvas\r\n    const pixelImg = new Image();\r\n    pixelImg.crossOrigin = \"anonymous\";\r\n    pixelImg.src = profileImage.src;\r\n    pixelImg.onload = function() {\r\n      ctx.drawImage(pixelImg, 0, 0, pixelCanvas.width, pixelCanvas.height);\r\n      // Start pixel manipulation\r\n      requestAnimationFrame(manipulatePixels);\r\n    };\r\n    \r\n    // Create geometric shapes overlay\r\n    const geoShapes = document.createElement(\"div\");\r\n    geoShapes.classList.add(\"geometric-shapes\");\r\n    profileImage.parentNode.appendChild(geoShapes);\r\n    \r\n    // Add shapes\r\n    for (let i = 0; i < 15; i++) {\r\n      const shape = document.createElement(\"div\");\r\n      shape.classList.add(\"geo-shape\");\r\n      \r\n      // Randomize shape type\r\n      const shapeType = Math.floor(Math.random() * 3);\r\n      if (shapeType === 0) {\r\n        shape.classList.add(\"geo-circle\");\r\n      } else if (shapeType === 1) {\r\n        shape.classList.add(\"geo-triangle\");\r\n      } else {\r\n        shape.classList.add(\"geo-square\");\r\n      }\r\n      \r\n      // Randomize position\r\n      shape.style.left = `${Math.random() * 100}%`;\r\n      shape.style.top = `${Math.random() * 100}%`;\r\n      \r\n      // Randomize size\r\n      const size = 5 + Math.random() * 20;\r\n      shape.style.width = `${size}px`;\r\n      shape.style.height = `${size}px`;\r\n      \r\n      // Randomize animation delay\r\n      shape.style.animationDelay = `${Math.random() * 5}s`;\r\n      \r\n      geoShapes.appendChild(shape);\r\n    }\r\n    \r\n    // Apply extreme glitch effects at random intervals\r\n    setInterval(() => {\r\n      if (Math.random() < 0.4) { // Increased probability for more frequent glitches\r\n        applyExtremeGlitch();\r\n      }\r\n    }, 1000);\r\n    \r\n    // Apply continuous subtle glitch\r\n    setInterval(() => {\r\n      applySubtleGlitch();\r\n    }, 100);\r\n    \r\n    // Apply color cycle effect\r\n    let hueRotation = 0;\r\n    setInterval(() => {\r\n      hueRotation = (hueRotation + 10) % 360;\r\n      glowEffect.style.filter = `hue-rotate(${hueRotation}deg)`;\r\n    }, 200);\r\n    \r\n    // Pixel manipulation function\r\n    function manipulatePixels() {\r\n      // Only manipulate sometimes for performance\r\n      if (Math.random() < 0.3) {\r\n        // Get image data\r\n        const imageData = ctx.getImageData(0, 0, pixelCanvas.width, pixelCanvas.height);\r\n        const data = imageData.data;\r\n        \r\n        // Apply different effects based on random choice\r\n        const effectChoice = Math.floor(Math.random() * 5);\r\n        \r\n        if (effectChoice === 0) {\r\n          // RGB shift\r\n          for (let i = 0; i < data.length; i += 4) {\r\n            // Shift red channel\r\n            if (i + 4 < data.length) {\r\n              data[i] = data[i + 4];\r\n            }\r\n            // Shift blue channel\r\n            if (i - 4 >= 0) {\r\n              data[i + 2] = data[i - 4 + 2];\r\n            }\r\n          }\r\n        } else if (effectChoice === 1) {\r\n          // Pixelate sections\r\n          const blockSize = Math.floor(Math.random() * 10) + 5;\r\n          for (let y = 0; y < pixelCanvas.height; y += blockSize) {\r\n            for (let x = 0; x < pixelCanvas.width; x += blockSize) {\r\n              // Only pixelate some blocks\r\n              if (Math.random() < 0.5) {\r\n                // Get the color of the first pixel in the block\r\n                const i = (y * pixelCanvas.width + x) * 4;\r\n                const r = data[i];\r\n                const g = data[i + 1];\r\n                const b = data[i + 2];\r\n                \r\n                // Apply to all pixels in the block\r\n                for (let by = 0; by < blockSize && y + by < pixelCanvas.height; by++) {\r\n                  for (let bx = 0; bx < blockSize && x + bx < pixelCanvas.width; bx++) {\r\n                    const idx = ((y + by) * pixelCanvas.width + (x + bx)) * 4;\r\n                    data[idx] = r;\r\n                    data[idx + 1] = g;\r\n                    data[idx + 2] = b;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else if (effectChoice === 2) {\r\n          // Wave distortion\r\n          const amplitude = Math.random() * 10;\r\n          const frequency = Math.random() * 0.1;\r\n          \r\n          const tempCanvas = document.createElement('canvas');\r\n          tempCanvas.width = pixelCanvas.width;\r\n          tempCanvas.height = pixelCanvas.height;\r\n          const tempCtx = tempCanvas.getContext('2d');\r\n          tempCtx.putImageData(imageData, 0, 0);\r\n          \r\n          ctx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);\r\n          \r\n          for (let y = 0; y < pixelCanvas.height; y++) {\r\n            const xOffset = Math.sin(y * frequency) * amplitude;\r\n            ctx.drawImage(\r\n              tempCanvas, \r\n              0, y, pixelCanvas.width, 1, \r\n              xOffset, y, pixelCanvas.width, 1\r\n            );\r\n          }\r\n          \r\n          // Skip the putImageData since we've already drawn the distorted image\r\n          requestAnimationFrame(manipulatePixels);\r\n          return;\r\n        } else if (effectChoice === 3) {\r\n          // Color inversion in sections\r\n          for (let i = 0; i < data.length; i += 4) {\r\n            // Only invert some pixels\r\n            if (Math.random() < 0.2) {\r\n              data[i] = 255 - data[i];         // Invert red\r\n              data[i + 1] = 255 - data[i + 1]; // Invert green\r\n              data[i + 2] = 255 - data[i + 2]; // Invert blue\r\n            }\r\n          }\r\n        } else {\r\n          // Scanlines effect\r\n          for (let y = 0; y < pixelCanvas.height; y++) {\r\n            if (y % 3 === 0) { // Every third line\r\n              for (let x = 0; x < pixelCanvas.width; x++) {\r\n                const i = (y * pixelCanvas.width + x) * 4;\r\n                // Brighten the line\r\n                data[i] = Math.min(255, data[i] * 1.5);\r\n                data[i + 1] = Math.min(255, data[i + 1] * 1.5);\r\n                data[i + 2] = Math.min(255, data[i + 2] * 1.5);\r\n              }\r\n            } else if (y % 3 === 1) { // Every third line + 1\r\n              for (let x = 0; x < pixelCanvas.width; x++) {\r\n                const i = (y * pixelCanvas.width + x) * 4;\r\n                // Darken the line\r\n                data[i] = data[i] * 0.5;\r\n                data[i + 1] = data[i + 1] * 0.5;\r\n                data[i + 2] = data[i + 2] * 0.5;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        \r\n        // Put the manipulated data back\r\n        ctx.putImageData(imageData, 0, 0);\r\n      }\r\n      \r\n      // Continue the animation\r\n      requestAnimationFrame(manipulatePixels);\r\n    }\r\n    \r\n    // Apply extreme glitch effect\r\n    function applyExtremeGlitch() {\r\n      // Apply to original image\r\n      profileImage.classList.add(\"extreme-glitch\");\r\n      \r\n      // Apply different effects to each layer\r\n      glitchLayers.forEach((layer, index) => {\r\n        // Random offset\r\n        const xOffset = (Math.random() - 0.5) * 20;\r\n        const yOffset = (Math.random() - 0.5) * 20;\r\n        layer.style.transform = `translate(${xOffset}px, ${yOffset}px)`;\r\n        \r\n        // Random filter\r\n        const hue = Math.floor(Math.random() * 360);\r\n        const saturate = 1 + Math.random() * 3;\r\n        const brightness = 0.7 + Math.random() * 0.6;\r\n        const contrast = 0.8 + Math.random() * 0.8;\r\n        const invert = Math.random() < 0.3 ? Math.random() * 0.3 : 0;\r\n        \r\n        layer.style.filter = `\r\n          hue-rotate(${hue}deg) \r\n          saturate(${saturate}) \r\n          brightness(${brightness}) \r\n          contrast(${contrast}) \r\n          invert(${invert})\r\n        `;\r\n        \r\n        // Random blend mode\r\n        const blendModes = ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion'];\r\n        const randomBlend = blendModes[Math.floor(Math.random() * blendModes.length)];\r\n        layer.style.mixBlendMode = randomBlend;\r\n        \r\n        // Random opacity\r\n        layer.style.opacity = 0.3 + Math.random() * 0.7;\r\n        \r\n        // Add specific class for animation\r\n        layer.classList.add(\"layer-glitching\");\r\n        \r\n        // Remove classes after animation completes\r\n        setTimeout(() => {\r\n          layer.classList.remove(\"layer-glitching\");\r\n        }, 500);\r\n      });\r\n      \r\n      // Trigger fractal animation\r\n      fractalOverlay.classList.add(\"fractal-active\");\r\n      \r\n      // Reset original image after effect\r\n      setTimeout(() => {\r\n        profileImage.classList.remove(\"extreme-glitch\");\r\n        \r\n        // Reset layer positions gradually\r\n        glitchLayers.forEach((layer, index) => {\r\n          setTimeout(() => {\r\n            layer.style.transform = \"translate(0, 0)\";\r\n            layer.style.filter = \"none\";\r\n            layer.style.mixBlendMode = \"normal\";\r\n            layer.style.opacity = 0.7 - (index * 0.1);\r\n          }, index * 50);\r\n        });\r\n        \r\n        // Reset fractal\r\n        fractalOverlay.classList.remove(\"fractal-active\");\r\n      }, 500);\r\n    }\r\n    \r\n    // Apply subtle continuous glitch\r\n    function applySubtleGlitch() {\r\n      // Only apply sometimes\r\n      if (Math.random() < 0.3) {\r\n        // Subtle movement\r\n        const xOffset = (Math.random() - 0.5) * 4;\r\n        const yOffset = (Math.random() - 0.5) * 4;\r\n        \r\n        // Apply to a random layer\r\n        const randomLayer = Math.floor(Math.random() * glitchLayers.length);\r\n        glitchLayers[randomLayer].style.transform = `translate(${xOffset}px, ${yOffset}px)`;\r\n        \r\n        // Reset after short delay\r\n        setTimeout(() => {\r\n          glitchLayers[randomLayer].style.transform = \"translate(0, 0)\";\r\n        }, 50);\r\n      }\r\n    }\r\n  }\r\n});\n\n//# sourceURL=webpack://bbfiller/./src/profile-glitch.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/profile-glitch.js"]();
/******/ 	
/******/ })()
;