/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/sw.js":
/*!*******************!*\
  !*** ./src/sw.js ***!
  \*******************/
/***/ (() => {

eval("/**\r\n * Enhanced Service Worker\r\n * Provides robust offline support, advanced caching strategies, and performance optimizations\r\n * for the Cyberpunk OS application.\r\n */\r\n\r\n// ===== Configuration =====\r\nconst CONFIG = {\r\n  // Cache names with versioning\r\n  caches: {\r\n    static: 'cyberpunk-os-static-v1',\r\n    dynamic: 'cyberpunk-os-dynamic-v1',\r\n    assets: 'cyberpunk-os-assets-v1',\r\n    api: 'cyberpunk-os-api-v1'\r\n  },\r\n  \r\n  // Cache expiration (in milliseconds)\r\n  expiration: {\r\n    api: 24 * 60 * 60 * 1000, // 24 hours\r\n    dynamic: 7 * 24 * 60 * 60 * 1000 // 7 days\r\n  },\r\n  \r\n  // Maximum cache size\r\n  maxCacheSize: {\r\n    dynamic: 50, // Maximum number of items in dynamic cache\r\n    assets: 100  // Maximum number of items in assets cache\r\n  },\r\n  \r\n  // Debug mode\r\n  debug: false\r\n};\r\n\r\n// Assets to cache on install (critical app shell)\r\nconst PRECACHE_ASSETS = [\r\n  '/',\r\n  '/index.html',\r\n  '/css/main.css',\r\n  '/css/glitch-effects.css',\r\n  '/js/boot-sequence.js',\r\n  '/js/consolidated.js',\r\n  '/js/utils.js',\r\n  '/js/window-state-manager.js',\r\n  '/js/asset-loader.js',\r\n  '/js/accessibility.js',\r\n  '/js/mobile-enhancements.js',\r\n  '/js/virtual-filesystem.js',\r\n  '/js/clock-manager.js',\r\n  '/js/workers/clock-worker.js',\r\n  '/js/apps/file-explorer.js',\r\n  '/js/apps/terminal.js',\r\n  '/manifest.json',\r\n  '/favicon.ico',\r\n  '/icons/icon-192x192.png',\r\n  '/icons/icon-512x512.png'\r\n];\r\n\r\n// Additional assets to cache after install (non-critical)\r\nconst SECONDARY_ASSETS = [\r\n  '/fonts/vt323-regular.woff2',\r\n  '/fonts/press-start-2p.woff2',\r\n  '/sounds/boot.mp3',\r\n  '/sounds/click.mp3',\r\n  '/images/background.jpg'\r\n];\r\n\r\n// ===== Utility Functions =====\r\n\r\n// Logger with debug mode support\r\nconst log = (message, type = 'info') => {\r\n  if (CONFIG.debug || type === 'error') {\r\n    const emoji = type === 'error' ? 'âŒ' : type === 'warn' ? 'âš ï¸' : 'ðŸ”§';\r\n    console[type](`[ServiceWorker] ${emoji} ${message}`);\r\n  }\r\n};\r\n\r\n// Cache management utilities\r\nconst cacheUtils = {\r\n  // Add items to a specific cache\r\n  async addToCache(cacheName, items) {\r\n    try {\r\n      const cache = await caches.open(cacheName);\r\n      await cache.addAll(items);\r\n      log(`Added ${items.length} items to ${cacheName}`);\r\n    } catch (error) {\r\n      log(`Failed to add items to ${cacheName}: ${error}`, 'error');\r\n    }\r\n  },\r\n  \r\n  // Trim cache to maximum size\r\n  async trimCache(cacheName, maxItems) {\r\n    try {\r\n      const cache = await caches.open(cacheName);\r\n      const keys = await cache.keys();\r\n      \r\n      if (keys.length > maxItems) {\r\n        log(`Trimming ${cacheName} (${keys.length} items, max: ${maxItems})`, 'warn');\r\n        for (let i = 0; i < keys.length - maxItems; i++) {\r\n          await cache.delete(keys[i]);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      log(`Failed to trim ${cacheName}: ${error}`, 'error');\r\n    }\r\n  },\r\n  \r\n  // Delete expired items from cache\r\n  async deleteExpiredItems(cacheName, maxAge) {\r\n    try {\r\n      const cache = await caches.open(cacheName);\r\n      const keys = await cache.keys();\r\n      const now = Date.now();\r\n      \r\n      let expiredCount = 0;\r\n      for (const request of keys) {\r\n        const response = await cache.match(request);\r\n        if (response) {\r\n          const cachedTime = response.headers.get('sw-cache-timestamp');\r\n          if (cachedTime && (now - parseInt(cachedTime)) > maxAge) {\r\n            await cache.delete(request);\r\n            expiredCount++;\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (expiredCount > 0) {\r\n        log(`Removed ${expiredCount} expired items from ${cacheName}`);\r\n      }\r\n    } catch (error) {\r\n      log(`Failed to delete expired items from ${cacheName}: ${error}`, 'error');\r\n    }\r\n  },\r\n  \r\n  // Add timestamp to response\r\n  addTimestamp(response) {\r\n    if (!response || !response.body) return response;\r\n    \r\n    const headers = new Headers(response.headers);\r\n    headers.set('sw-cache-timestamp', Date.now().toString());\r\n    \r\n    return new Response(response.body, {\r\n      status: response.status,\r\n      statusText: response.statusText,\r\n      headers: headers\r\n    });\r\n  }\r\n};\r\n\r\n// Network utilities\r\nconst networkUtils = {\r\n  // Check if a URL is an API request\r\n  isApiRequest(url) {\r\n    return url.includes('/api/');\r\n  },\r\n  \r\n  // Check if a URL is a static asset\r\n  isStaticAsset(url) {\r\n    const staticExtensions = ['.css', '.js', '.html', '.json', '.ico', '.png', '.jpg', '.svg', '.woff', '.woff2', '.ttf'];\r\n    return staticExtensions.some(ext => url.endsWith(ext));\r\n  },\r\n  \r\n  // Check if a URL is a media asset\r\n  isMediaAsset(url) {\r\n    const mediaExtensions = ['.mp3', '.mp4', '.webm', '.ogg', '.wav'];\r\n    return mediaExtensions.some(ext => url.endsWith(ext));\r\n  },\r\n  \r\n  // Check if a request should be cached\r\n  shouldCache(request) {\r\n    // Skip non-GET requests\r\n    if (request.method !== 'GET') return false;\r\n    \r\n    const url = new URL(request.url);\r\n    \r\n    // Skip cross-origin requests\r\n    if (url.origin !== self.location.origin) return false;\r\n    \r\n    // Skip analytics and tracking requests\r\n    if (url.pathname.includes('/analytics/') || url.pathname.includes('/tracking/')) return false;\r\n    \r\n    return true;\r\n  },\r\n  \r\n  // Network-first strategy with timeout\r\n  async networkFirstWithTimeout(request, cacheName, timeout = 3000) {\r\n    return new Promise(async (resolve) => {\r\n      let timeoutId;\r\n      \r\n      // Set timeout for network request\r\n      const timeoutPromise = new Promise(resolveTimeout => {\r\n        timeoutId = setTimeout(async () => {\r\n          log(`Network request timeout for ${request.url}`, 'warn');\r\n          const cachedResponse = await caches.match(request);\r\n          if (cachedResponse) {\r\n            log(`Serving from cache: ${request.url}`);\r\n            resolveTimeout(cachedResponse);\r\n          } else {\r\n            log(`No cached version available for ${request.url}`, 'warn');\r\n            resolveTimeout(new Response('Network request timed out', { \r\n              status: 408, \r\n              headers: { 'Content-Type': 'text/plain' } \r\n            }));\r\n          }\r\n        }, timeout);\r\n      });\r\n      \r\n      // Try network first\r\n      try {\r\n        const networkPromise = fetch(request).then(async response => {\r\n          clearTimeout(timeoutId);\r\n          \r\n          // Cache successful responses\r\n          if (response.ok) {\r\n            const clonedResponse = response.clone();\r\n            const cache = await caches.open(cacheName);\r\n            await cache.put(request, cacheUtils.addTimestamp(clonedResponse));\r\n            log(`Cached network response: ${request.url}`);\r\n          }\r\n          \r\n          return response;\r\n        });\r\n        \r\n        // Race network request against timeout\r\n        resolve(Promise.race([networkPromise, timeoutPromise]));\r\n      } catch (error) {\r\n        clearTimeout(timeoutId);\r\n        log(`Network error for ${request.url}: ${error}`, 'error');\r\n        \r\n        // Fallback to cache\r\n        const cachedResponse = await caches.match(request);\r\n        if (cachedResponse) {\r\n          log(`Serving from cache after network error: ${request.url}`);\r\n          resolve(cachedResponse);\r\n        } else {\r\n          log(`No cached version available after network error for ${request.url}`, 'error');\r\n          resolve(new Response('Network error and no cached version available', { \r\n            status: 503, \r\n            headers: { 'Content-Type': 'text/plain' } \r\n          }));\r\n        }\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// ===== Event Handlers =====\r\n\r\n// Install event - precache critical assets\r\nself.addEventListener('install', event => {\r\n  log('Installing Service Worker');\r\n  \r\n  event.waitUntil(\r\n    (async () => {\r\n      try {\r\n        // Cache critical app shell assets\r\n        await cacheUtils.addToCache(CONFIG.caches.static, PRECACHE_ASSETS);\r\n        \r\n        // Skip waiting to activate immediately\r\n        await self.skipWaiting();\r\n        log('Service Worker installed successfully');\r\n      } catch (error) {\r\n        log(`Installation failed: ${error}`, 'error');\r\n      }\r\n    })()\r\n  );\r\n});\r\n\r\n// Activate event - clean up old caches and claim clients\r\nself.addEventListener('activate', event => {\r\n  log('Activating Service Worker');\r\n  \r\n  event.waitUntil(\r\n    (async () => {\r\n      try {\r\n        // Get all cache names\r\n        const cacheNames = await caches.keys();\r\n        \r\n        // Valid cache names from config\r\n        const validCacheNames = Object.values(CONFIG.caches);\r\n        \r\n        // Delete old caches\r\n        await Promise.all(\r\n          cacheNames\r\n            .filter(cacheName => !validCacheNames.includes(cacheName))\r\n            .map(cacheName => {\r\n              log(`Removing old cache: ${cacheName}`);\r\n              return caches.delete(cacheName);\r\n            })\r\n        );\r\n        \r\n        // Cache secondary assets in the background\r\n        cacheUtils.addToCache(CONFIG.caches.assets, SECONDARY_ASSETS)\r\n          .catch(error => log(`Failed to cache secondary assets: ${error}`, 'error'));\r\n        \r\n        // Claim all clients\r\n        await self.clients.claim();\r\n        log('Service Worker activated and claimed clients');\r\n      } catch (error) {\r\n        log(`Activation failed: ${error}`, 'error');\r\n      }\r\n    })()\r\n  );\r\n});\r\n\r\n// Fetch event - handle different caching strategies based on request type\r\nself.addEventListener('fetch', event => {\r\n  const request = event.request;\r\n  \r\n  // Skip non-cacheable requests\r\n  if (!networkUtils.shouldCache(request)) {\r\n    return;\r\n  }\r\n  \r\n  // Choose caching strategy based on request type\r\n  if (networkUtils.isApiRequest(request.url)) {\r\n    // API requests: Network-first with fallback to cache\r\n    event.respondWith(\r\n      networkUtils.networkFirstWithTimeout(request, CONFIG.caches.api, 5000)\r\n    );\r\n  } else if (networkUtils.isMediaAsset(request.url)) {\r\n    // Media assets: Cache-first for performance\r\n    event.respondWith(\r\n      (async () => {\r\n        try {\r\n          // Try cache first\r\n          const cachedResponse = await caches.match(request);\r\n          if (cachedResponse) {\r\n            log(`Serving media from cache: ${request.url}`);\r\n            return cachedResponse;\r\n          }\r\n          \r\n          // If not in cache, fetch from network\r\n          const networkResponse = await fetch(request);\r\n          \r\n          // Cache the response if successful\r\n          if (networkResponse.ok) {\r\n            const clonedResponse = networkResponse.clone();\r\n            const cache = await caches.open(CONFIG.caches.assets);\r\n            await cache.put(request, cacheUtils.addTimestamp(clonedResponse));\r\n            \r\n            // Trim cache if needed\r\n            cacheUtils.trimCache(CONFIG.caches.assets, CONFIG.maxCacheSize.assets);\r\n            \r\n            log(`Cached media asset: ${request.url}`);\r\n          }\r\n          \r\n          return networkResponse;\r\n        } catch (error) {\r\n          log(`Failed to fetch media asset: ${request.url}`, 'error');\r\n          return new Response('Failed to fetch media asset', { \r\n            status: 503, \r\n            headers: { 'Content-Type': 'text/plain' } \r\n          });\r\n        }\r\n      })()\r\n    );\r\n  } else if (networkUtils.isStaticAsset(request.url)) {\r\n    // Static assets: Cache-first with network fallback\r\n    event.respondWith(\r\n      (async () => {\r\n        try {\r\n          // Try cache first\r\n          const cachedResponse = await caches.match(request);\r\n          if (cachedResponse) {\r\n            log(`Serving static asset from cache: ${request.url}`);\r\n            \r\n            // Update cache in the background (stale-while-revalidate)\r\n            fetch(request)\r\n              .then(async networkResponse => {\r\n                if (networkResponse.ok) {\r\n                  const cache = await caches.open(CONFIG.caches.static);\r\n                  await cache.put(request, cacheUtils.addTimestamp(networkResponse));\r\n                  log(`Updated cached static asset: ${request.url}`);\r\n                }\r\n              })\r\n              .catch(error => log(`Background fetch failed for ${request.url}: ${error}`, 'warn'));\r\n            \r\n            return cachedResponse;\r\n          }\r\n          \r\n          // If not in cache, fetch from network\r\n          const networkResponse = await fetch(request);\r\n          \r\n          // Cache the response if successful\r\n          if (networkResponse.ok) {\r\n            const clonedResponse = networkResponse.clone();\r\n            const cache = await caches.open(CONFIG.caches.static);\r\n            await cache.put(request, cacheUtils.addTimestamp(clonedResponse));\r\n            log(`Cached static asset: ${request.url}`);\r\n          }\r\n          \r\n          return networkResponse;\r\n        } catch (error) {\r\n          log(`Failed to fetch static asset: ${request.url}`, 'error');\r\n          return new Response('Failed to fetch static asset', { \r\n            status: 503, \r\n            headers: { 'Content-Type': 'text/plain' } \r\n          });\r\n        }\r\n      })()\r\n    );\r\n  } else {\r\n    // Other requests: Network-first with cache fallback\r\n    event.respondWith(\r\n      (async () => {\r\n        try {\r\n          // Try network first\r\n          const networkResponse = await fetch(request);\r\n          \r\n          // Cache the response if successful\r\n          if (networkResponse.ok) {\r\n            const clonedResponse = networkResponse.clone();\r\n            const cache = await caches.open(CONFIG.caches.dynamic);\r\n            await cache.put(request, cacheUtils.addTimestamp(clonedResponse));\r\n            \r\n            // Trim cache if needed\r\n            cacheUtils.trimCache(CONFIG.caches.dynamic, CONFIG.maxCacheSize.dynamic);\r\n            \r\n            log(`Cached dynamic content: ${request.url}`);\r\n          }\r\n          \r\n          return networkResponse;\r\n        } catch (error) {\r\n          log(`Network request failed for ${request.url}: ${error}`, 'warn');\r\n          \r\n          // Fallback to cache\r\n          const cachedResponse = await caches.match(request);\r\n          if (cachedResponse) {\r\n            log(`Serving from cache after network failure: ${request.url}`);\r\n            return cachedResponse;\r\n          }\r\n          \r\n          // If not in cache, try to serve the offline page\r\n          const offlineResponse = await caches.match('/offline.html');\r\n          if (offlineResponse) {\r\n            return offlineResponse;\r\n          }\r\n          \r\n          // Last resort: generic error response\r\n          return new Response('You are offline and the requested resource is not cached', { \r\n            status: 503, \r\n            headers: { 'Content-Type': 'text/plain' } \r\n          });\r\n        }\r\n      })()\r\n    );\r\n  }\r\n});\r\n\r\n// Message event - handle messages from clients\r\nself.addEventListener('message', event => {\r\n  log(`Message received: ${JSON.stringify(event.data)}`);\r\n  \r\n  if (event.data.action === 'skipWaiting') {\r\n    self.skipWaiting();\r\n  } else if (event.data.action === 'clearCache') {\r\n    event.waitUntil(\r\n      (async () => {\r\n        try {\r\n          if (event.data.cacheName) {\r\n            // Clear specific cache\r\n            await caches.delete(event.data.cacheName);\r\n            log(`Cleared cache: ${event.data.cacheName}`);\r\n          } else {\r\n            // Clear all caches\r\n            const cacheNames = await caches.keys();\r\n            await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));\r\n            log('Cleared all caches');\r\n          }\r\n          \r\n          // Notify client\r\n          if (event.source) {\r\n            event.source.postMessage({\r\n              action: 'cacheCleared',\r\n              success: true\r\n            });\r\n          }\r\n        } catch (error) {\r\n          log(`Failed to clear cache: ${error}`, 'error');\r\n          \r\n          // Notify client of failure\r\n          if (event.source) {\r\n            event.source.postMessage({\r\n              action: 'cacheCleared',\r\n              success: false,\r\n              error: error.message\r\n            });\r\n          }\r\n        }\r\n      })()\r\n    );\r\n  } else if (event.data.action === 'precacheAssets') {\r\n    // Precache additional assets on demand\r\n    event.waitUntil(\r\n      (async () => {\r\n        try {\r\n          if (event.data.assets && Array.isArray(event.data.assets)) {\r\n            await cacheUtils.addToCache(CONFIG.caches.assets, event.data.assets);\r\n            \r\n            // Notify client\r\n            if (event.source) {\r\n              event.source.postMessage({\r\n                action: 'assetsPrecached',\r\n                success: true\r\n              });\r\n            }\r\n          }\r\n        } catch (error) {\r\n          log(`Failed to precache assets: ${error}`, 'error');\r\n          \r\n          // Notify client of failure\r\n          if (event.source) {\r\n            event.source.postMessage({\r\n              action: 'assetsPrecached',\r\n              success: false,\r\n              error: error.message\r\n            });\r\n          }\r\n        }\r\n      })()\r\n    );\r\n  } else if (event.data.action === 'setDebugMode') {\r\n    CONFIG.debug = !!event.data.enabled;\r\n    log(`Debug mode ${CONFIG.debug ? 'enabled' : 'disabled'}`);\r\n    \r\n    // Notify client\r\n    if (event.source) {\r\n      event.source.postMessage({\r\n        action: 'debugModeSet',\r\n        enabled: CONFIG.debug\r\n      });\r\n    }\r\n  }\r\n});\r\n\r\n// Periodic cache maintenance\r\nself.addEventListener('periodicsync', event => {\r\n  if (event.tag === 'cache-maintenance') {\r\n    log('Performing periodic cache maintenance');\r\n    \r\n    event.waitUntil(\r\n      (async () => {\r\n        try {\r\n          // Delete expired items from API cache\r\n          await cacheUtils.deleteExpiredItems(CONFIG.caches.api, CONFIG.expiration.api);\r\n          \r\n          // Delete expired items from dynamic cache\r\n          await cacheUtils.deleteExpiredItems(CONFIG.caches.dynamic, CONFIG.expiration.dynamic);\r\n          \r\n          // Trim caches to maximum size\r\n          await cacheUtils.trimCache(CONFIG.caches.dynamic, CONFIG.maxCacheSize.dynamic);\r\n          await cacheUtils.trimCache(CONFIG.caches.assets, CONFIG.maxCacheSize.assets);\r\n          \r\n          log('Cache maintenance completed');\r\n        } catch (error) {\r\n          log(`Cache maintenance failed: ${error}`, 'error');\r\n        }\r\n      })()\r\n    );\r\n  }\r\n});\r\n\r\n// Push notification event\r\nself.addEventListener('push', event => {\r\n  log('Push notification received');\r\n  \r\n  if (!event.data) {\r\n    log('No data in push event', 'warn');\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    const data = event.data.json();\r\n    \r\n    const options = {\r\n      body: data.body || 'New notification',\r\n      icon: data.icon || '/icons/icon-192x192.png',\r\n      badge: data.badge || '/icons/badge-72x72.png',\r\n      vibrate: data.vibrate || [100, 50, 100],\r\n      data: {\r\n        url: data.url || '/'\r\n      }\r\n    };\r\n    \r\n    event.waitUntil(\r\n      self.registration.showNotification(data.title || 'Cyberpunk OS', options)\r\n    );\r\n  } catch (error) {\r\n    log(`Failed to process push notification: ${error}`, 'error');\r\n  }\r\n});\r\n\r\n// Notification click event\r\nself.addEventListener('notificationclick', event => {\r\n  log('Notification clicked');\r\n  \r\n  event.notification.close();\r\n  \r\n  event.waitUntil(\r\n    (async () => {\r\n      try {\r\n        const url = event.notification.data.url || '/';\r\n        const windowClients = await self.clients.matchAll({ type: 'window' });\r\n        \r\n        // Try to find an open window and navigate to the URL\r\n        for (const client of windowClients) {\r\n          if (client.url === url && 'focus' in client) {\r\n            await client.focus();\r\n            return;\r\n          }\r\n        }\r\n        \r\n        // If no window is open, open a new one\r\n        if (self.clients.openWindow) {\r\n          await self.clients.openWindow(url);\r\n        }\r\n      } catch (error) {\r\n        log(`Failed to handle notification click: ${error}`, 'error');\r\n      }\r\n    })()\r\n  );\r\n});\r\n\r\n// Log successful registration\r\nlog('Service Worker registered');\n\n//# sourceURL=webpack://bbfiller/./src/sw.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/sw.js"]();
/******/ 	
/******/ })()
;